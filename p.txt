{
  "version": 2,
  "builds": [
    {
      "src": "src/main.ts",
      "use": "@vercel/node"
    }
  ],
  "routes": [
    {
      "src": "/api/(.*)",
      "dest": "src/main.ts",
      "methods": ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS", "HEAD"]
    }
  ]
}
import { IsEnum, IsOptional, IsString } from 'class-validator';
import { ProductStatus } from '../../common/enums/product-status.enum';

export class AdminUpdateProductDto {
  @IsEnum(ProductStatus)
  @IsOptional()
  status?: ProductStatus;

  @IsString()
  @IsOptional()
  rejectionReason?: string;
}

export class AdminProductActionDto {
  @IsString()
  action: 'approve' | 'reject' | 'flag' | 'delete';

  @IsString()
  @IsOptional()
  reason?: string;
}
import { IsString, IsOptional, IsEnum, IsBoolean, IsEmail } from 'class-validator';
import { Role } from '../../common/enums/role.enum';

export class AdminUpdateUserDto {
  @IsString()
  @IsOptional()
  firstName?: string;

  @IsString()
  @IsOptional()
  lastName?: string;

  @IsEmail()
  @IsOptional()
  email?: string;

  @IsString()
  @IsOptional()
  phone?: string;

  @IsEnum(Role)
  @IsOptional()
  role?: Role;

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;

  @IsBoolean()
  @IsOptional()
  isEmailVerified?: boolean;
}

export class AdminCreateUserDto {
  @IsString()
  firstName: string;

  @IsString()
  lastName: string;

  @IsEmail()
  email: string;

  @IsString()
  password: string;

  @IsString()
  phone: string;

  @IsEnum(Role)
  @IsOptional()
  role?: Role = Role.USER;
}import { IsBoolean, IsOptional, IsString } from 'class-validator';

export class AdminUpdateVendorDto {
  @IsBoolean()
  @IsOptional()
  isActive?: boolean;

  @IsBoolean()
  @IsOptional()
  isVerified?: boolean;

  @IsBoolean()
  @IsOptional()
  isFeatured?: boolean;

  @IsString()
  @IsOptional()
  rejectionReason?: string;
}

export class AdminVendorActionDto {
  @IsString()
  action: 'approve' | 'reject' | 'suspend' | 'feature' | 'unfeature';

  @IsString()
  @IsOptional()
  reason?: string;
}
export interface DashboardStats {
  users: {
    total: number;
    active: number;
    newThisMonth: number;
    byRole: { role: string; count: number }[];
  };
  vendors: {
    total: number;
    verified: number;
    pending: number;
    featured: number;
    newThisMonth: number;
  };
  products: {
    total: number;
    approved: number;
    pending: number;
    rejected: number;
    newThisMonth: number;
  };
  locations: {
    states: number;
    areas: number;
    markets: number;
  };
  activity: {
    totalViews: number;
    totalSearches: number;
  };
}

export interface RecentActivity {
  type: 'user_registered' | 'vendor_created' | 'product_added' | 'vendor_verified';
  message: string;
  timestamp: Date;
  data?: any;
}
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  UseGuards,
} from '@nestjs/common';
import { AdminService } from './admin.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { Role } from '../common/enums/role.enum';
import { ProductStatus } from '../common/enums/product-status.enum';
import { AdminUpdateUserDto, AdminCreateUserDto } from './dto/admin-update-user.dto';
import { AdminUpdateVendorDto, AdminVendorActionDto } from './dto/admin-update-vendor.dto';
import { AdminUpdateProductDto, AdminProductActionDto } from './dto/admin-update-product.dto';
import { AdminSeeder } from '../database/seeders/admin.seeder';

@Controller('admin')
@UseGuards(JwtAuthGuard, RolesGuard)
@Roles(Role.ADMIN, Role.SUPER_ADMIN)
export class AdminController {
  constructor(private adminService: AdminService,  private adminSeeder: AdminSeeder, ) {}



  @Post('seed/admins')
@Roles(Role.SUPER_ADMIN)
async seedAdmins() {
  await this.adminSeeder.seed();
  return { message: 'Admins seeded successfully' };
}

@Get('seed/admins/list')
@Roles(Role.SUPER_ADMIN)
async listSeededAdmins() {
  return this.adminSeeder.listAdmins();
}

  // ==================== DASHBOARD ====================

  @Get('dashboard/stats')
  getDashboardStats() {
    return this.adminService.getDashboardStats();
  }

  @Get('dashboard/activity')
  getRecentActivity(@Query('limit') limit?: number) {
    return this.adminService.getRecentActivity(limit);
  }

  // ==================== USER MANAGEMENT ====================

  @Get('users')
  getAllUsers(
    @Query('page') page?: number,
    @Query('limit') limit?: number,
    @Query('role') role?: Role,
    @Query('search') search?: string,
    @Query('isActive') isActive?: boolean,
  ) {
    return this.adminService.getAllUsers({ page, limit, role, search, isActive });
  }

  @Get('users/:id')
  getUserById(@Param('id') id: string) {
    return this.adminService.getUserById(id);
  }

  @Post('users')
  @Roles(Role.SUPER_ADMIN)
  createUser(@Body() dto: AdminCreateUserDto) {
    return this.adminService.createUser(dto);
  }

  @Put('users/:id')
  updateUser(@Param('id') id: string, @Body() dto: AdminUpdateUserDto) {
    return this.adminService.updateUser(id, dto);
  }

  @Delete('users/:id')
  @Roles(Role.SUPER_ADMIN)
  deleteUser(@Param('id') id: string) {
    return this.adminService.deleteUser(id);
  }

  @Put('users/:id/role')
  @Roles(Role.SUPER_ADMIN)
  changeUserRole(@Param('id') id: string, @Body('role') role: Role) {
    return this.adminService.changeUserRole(id, role);
  }

  // ==================== VENDOR MANAGEMENT ====================

  @Get('vendors')
  getAllVendors(
    @Query('page') page?: number,
    @Query('limit') limit?: number,
    @Query('isVerified') isVerified?: boolean,
    @Query('isFeatured') isFeatured?: boolean,
    @Query('search') search?: string,
  ) {
    return this.adminService.getAllVendors({ page, limit, isVerified, isFeatured, search });
  }

  @Get('vendors/pending')
  getPendingVendors() {
    return this.adminService.getPendingVendors();
  }

  @Get('vendors/:id')
  getVendorById(@Param('id') id: string) {
    return this.adminService.getVendorById(id);
  }

  @Put('vendors/:id')
  updateVendor(@Param('id') id: string, @Body() dto: AdminUpdateVendorDto) {
    return this.adminService.updateVendor(id, dto);
  }

  @Post('vendors/:id/action')
  vendorAction(@Param('id') id: string, @Body() dto: AdminVendorActionDto) {
    return this.adminService.vendorAction(id, dto);
  }

  // ==================== PRODUCT MANAGEMENT ====================

  @Get('products')
  getAllProducts(
    @Query('page') page?: number,
    @Query('limit') limit?: number,
    @Query('status') status?: ProductStatus,
    @Query('search') search?: string,
    @Query('vendorId') vendorId?: string,
  ) {
    return this.adminService.getAllProducts({ page, limit, status, search, vendorId });
  }

  @Get('products/pending')
  getPendingProducts() {
    return this.adminService.getPendingProducts();
  }

  @Get('products/:id')
  getProductById(@Param('id') id: string) {
    return this.adminService.getProductById(id);
  }

  @Put('products/:id')
  updateProduct(@Param('id') id: string, @Body() dto: AdminUpdateProductDto) {
    return this.adminService.updateProduct(id, dto);
  }

  @Post('products/:id/action')
  productAction(@Param('id') id: string, @Body() dto: AdminProductActionDto) {
    return this.adminService.productAction(id, dto);
  }

  @Post('products/bulk-approve')
  bulkApproveProducts(@Body('ids') ids: string[]) {
    return this.adminService.bulkApproveProducts(ids);
  }

  @Post('products/bulk-reject')
  bulkRejectProducts(@Body('ids') ids: string[], @Body('reason') reason?: string) {
    return this.adminService.bulkRejectProducts(ids, reason);
  }
}
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { AdminController } from './admin.controller';
import { AdminService } from './admin.service';
import { AdminSeeder } from '../database/seeders/admin.seeder';
import { User, UserSchema } from '../users/schemas/user.schema';
import { Vendor, VendorSchema } from '../vendors/schemas/vendor.schema';
import { Product, ProductSchema } from '../products/schemas/product.schema';
import { State, StateSchema } from '../states/schemas/state.schema';
import { Area, AreaSchema } from '../areas/schemas/area.schema';
import { Market, MarketSchema } from '../markets/schemas/market.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: User.name, schema: UserSchema },
      { name: Vendor.name, schema: VendorSchema },
      { name: Product.name, schema: ProductSchema },
      { name: State.name, schema: StateSchema },
      { name: Area.name, schema: AreaSchema },
      { name: Market.name, schema: MarketSchema },
    ]),
  ],
  controllers: [AdminController],
  providers: [AdminService, AdminSeeder],
  exports: [AdminService, AdminSeeder],
})
export class AdminModule {}
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import * as bcrypt from 'bcryptjs';
import { User } from '../users/schemas/user.schema';
import { Vendor } from '../vendors/schemas/vendor.schema';
import { Product } from '../products/schemas/product.schema';
import { State } from '../states/schemas/state.schema';
import { Area } from '../areas/schemas/area.schema';
import { Market } from '../markets/schemas/market.schema';
import { Role } from '../common/enums/role.enum';
import { ProductStatus } from '../common/enums/product-status.enum';
import { AdminUpdateUserDto, AdminCreateUserDto } from './dto/admin-update-user.dto';
import { AdminUpdateVendorDto, AdminVendorActionDto } from './dto/admin-update-vendor.dto';
import { AdminUpdateProductDto, AdminProductActionDto } from './dto/admin-update-product.dto';
import { DashboardStats, RecentActivity } from './dto/dashboard-stats.dto';

@Injectable()
export class AdminService {
  constructor(
    @InjectModel(User.name) private userModel: Model<User>,
    @InjectModel(Vendor.name) private vendorModel: Model<Vendor>,
    @InjectModel(Product.name) private productModel: Model<Product>,
    @InjectModel(State.name) private stateModel: Model<State>,
    @InjectModel(Area.name) private areaModel: Model<Area>,
    @InjectModel(Market.name) private marketModel: Model<Market>,
  ) {}

  // ==================== DASHBOARD ====================

  async getDashboardStats(): Promise<DashboardStats> {
    const now = new Date();
    const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);

    const [
      totalUsers,
      activeUsers,
      newUsersThisMonth,
      usersByRole,
      totalVendors,
      verifiedVendors,
      pendingVendors,
      featuredVendors,
      newVendorsThisMonth,
      totalProducts,
      approvedProducts,
      pendingProducts,
      rejectedProducts,
      newProductsThisMonth,
      totalStates,
      totalAreas,
      totalMarkets,
      totalViews,
      totalSearches,
    ] = await Promise.all([
      this.userModel.countDocuments(),
      this.userModel.countDocuments({ isActive: true }),
      this.userModel.countDocuments({ createdAt: { $gte: startOfMonth } }),
      this.userModel.aggregate([
        { $group: { _id: '$role', count: { $sum: 1 } } },
      ]),
      this.vendorModel.countDocuments(),
      this.vendorModel.countDocuments({ isVerified: true }),
      this.vendorModel.countDocuments({ isVerified: false, isActive: true }),
      this.vendorModel.countDocuments({ isFeatured: true }),
      this.vendorModel.countDocuments({ createdAt: { $gte: startOfMonth } }),
      this.productModel.countDocuments(),
      this.productModel.countDocuments({ status: ProductStatus.APPROVED }),
      this.productModel.countDocuments({ status: ProductStatus.PENDING }),
      this.productModel.countDocuments({ status: ProductStatus.REJECTED }),
      this.productModel.countDocuments({ createdAt: { $gte: startOfMonth } }),
      this.stateModel.countDocuments(),
      this.areaModel.countDocuments(),
      this.marketModel.countDocuments(),
      this.vendorModel.aggregate([
        { $group: { _id: null, total: { $sum: '$totalViews' } } },
      ]),
      this.productModel.aggregate([
        { $group: { _id: null, total: { $sum: '$searchAppearances' } } },
      ]),
    ]);

    return {
      users: {
        total: totalUsers,
        active: activeUsers,
        newThisMonth: newUsersThisMonth,
        byRole: usersByRole.map((r) => ({ role: r._id, count: r.count })),
      },
      vendors: {
        total: totalVendors,
        verified: verifiedVendors,
        pending: pendingVendors,
        featured: featuredVendors,
        newThisMonth: newVendorsThisMonth,
      },
      products: {
        total: totalProducts,
        approved: approvedProducts,
        pending: pendingProducts,
        rejected: rejectedProducts,
        newThisMonth: newProductsThisMonth,
      },
      locations: {
        states: totalStates,
        areas: totalAreas,
        markets: totalMarkets,
      },
      activity: {
        totalViews: totalViews[0]?.total || 0,
        totalSearches: totalSearches[0]?.total || 0,
      },
    };
  }

  async getRecentActivity(limit: number = 20): Promise<RecentActivity[]> {
    const [recentUsers, recentVendors, recentProducts] = await Promise.all([
      this.userModel
        .find()
        .sort({ createdAt: -1 })
        .limit(limit)
        .select('firstName lastName email createdAt'),
      this.vendorModel
        .find()
        .sort({ createdAt: -1 })
        .limit(limit)
        .select('businessName isVerified createdAt'),
      this.productModel
        .find()
        .sort({ createdAt: -1 })
        .limit(limit)
        .select('name status createdAt'),
    ]);

    const activities: RecentActivity[] = [];

    recentUsers.forEach((user) => {
      activities.push({
        type: 'user_registered',
        message: `New user registered: ${user.firstName} ${user.lastName}`,
        timestamp: user.createdAt as any,
        data: { userId: user._id, email: user.email },
      });
    });

    recentVendors.forEach((vendor) => {
      activities.push({
        type: vendor.isVerified ? 'vendor_verified' : 'vendor_created',
        message: vendor.isVerified
          ? `Vendor verified: ${vendor.businessName}`
          : `New vendor created: ${vendor.businessName}`,
        timestamp: vendor.createdAt as any,
        data: { vendorId: vendor._id },
      });
    });

    recentProducts.forEach((product) => {
      activities.push({
        type: 'product_added',
        message: `New product added: ${product.name}`,
        timestamp: product.createdAt as any,
        data: { productId: product._id, status: product.status },
      });
    });

    // Sort by timestamp descending
    activities.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());

    return activities.slice(0, limit);
  }

  // ==================== USER MANAGEMENT ====================

  async getAllUsers(filters: {
    page?: number;
    limit?: number;
    role?: Role;
    search?: string;
    isActive?: boolean;
  }): Promise<{ users: User[]; total: number; page: number; totalPages: number }> {
    const { page = 1, limit = 20, role, search, isActive } = filters;
    const skip = (page - 1) * limit;

    const query: any = {};
    if (role) query.role = role;
    if (isActive !== undefined) query.isActive = isActive;
    if (search) {
      query.$or = [
        { firstName: { $regex: search, $options: 'i' } },
        { lastName: { $regex: search, $options: 'i' } },
        { email: { $regex: search, $options: 'i' } },
      ];
    }

    const [users, total] = await Promise.all([
      this.userModel
        .find(query)
        .select('-password')
        .skip(skip)
        .limit(limit)
        .sort({ createdAt: -1 }),
      this.userModel.countDocuments(query),
    ]);

    return {
      users,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async getUserById(id: string): Promise<User> {
    const user = await this.userModel.findById(id).select('-password');
    if (!user) throw new NotFoundException('User not found');
    return user;
  }

  async createUser(dto: AdminCreateUserDto): Promise<User> {
    const exists = await this.userModel.findOne({ email: dto.email.toLowerCase() });
    if (exists) throw new BadRequestException('Email already exists');

    const hashedPassword = await bcrypt.hash(dto.password, 12);
    return this.userModel.create({
      ...dto,
      email: dto.email.toLowerCase(),
      password: hashedPassword,
    });
  }

  async updateUser(id: string, dto: AdminUpdateUserDto): Promise<User> {
    const user = await this.userModel
      .findByIdAndUpdate(id, dto, { new: true })
      .select('-password');
    if (!user) throw new NotFoundException('User not found');
    return user;
  }

  async deleteUser(id: string): Promise<void> {
    const result = await this.userModel.deleteOne({ _id: id });
    if (result.deletedCount === 0) throw new NotFoundException('User not found');
  }

  async changeUserRole(id: string, role: Role): Promise<User> {
    const user = await this.userModel
      .findByIdAndUpdate(id, { role }, { new: true })
      .select('-password');
    if (!user) throw new NotFoundException('User not found');
    return user;
  }

  // ==================== VENDOR MANAGEMENT ====================

  async getAllVendors(filters: {
    page?: number;
    limit?: number;
    isVerified?: boolean;
    isFeatured?: boolean;
    search?: string;
  }): Promise<{ vendors: Vendor[]; total: number; page: number; totalPages: number }> {
    const { page = 1, limit = 20, isVerified, isFeatured, search } = filters;
    const skip = (page - 1) * limit;

    const query: any = {};
    if (isVerified !== undefined) query.isVerified = isVerified;
    if (isFeatured !== undefined) query.isFeatured = isFeatured;
    if (search) {
      query.$or = [
        { businessName: { $regex: search, $options: 'i' } },
        { businessDescription: { $regex: search, $options: 'i' } },
      ];
    }

    const [vendors, total] = await Promise.all([
      this.vendorModel
        .find(query)
        .populate('userId', 'firstName lastName email')
        .populate('stateId', 'name')
        .populate('areaId', 'name')
        .populate('marketId', 'name')
        .skip(skip)
        .limit(limit)
        .sort({ createdAt: -1 }),
      this.vendorModel.countDocuments(query),
    ]);

    return {
      vendors,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async getVendorById(id: string): Promise<Vendor> {
    const vendor = await this.vendorModel
      .findById(id)
      .populate('userId', 'firstName lastName email phone')
      .populate('stateId', 'name')
      .populate('areaId', 'name')
      .populate('marketId', 'name');
    if (!vendor) throw new NotFoundException('Vendor not found');
    return vendor;
  }

  async updateVendor(id: string, dto: AdminUpdateVendorDto): Promise<Vendor> {
    const vendor = await this.vendorModel.findByIdAndUpdate(id, dto, { new: true });
    if (!vendor) throw new NotFoundException('Vendor not found');
    return vendor;
  }

  async vendorAction(id: string, dto: AdminVendorActionDto): Promise<Vendor> {
    const vendor = await this.vendorModel.findById(id);
    if (!vendor) throw new NotFoundException('Vendor not found');

    const updates: any = {};

    switch (dto.action) {
      case 'approve':
        updates.isVerified = true;
        updates.isActive = true;
        break;
      case 'reject':
        updates.isVerified = false;
        updates.isActive = false;
        break;
      case 'suspend':
        updates.isActive = false;
        break;
      case 'feature':
        updates.isFeatured = true;
        break;
      case 'unfeature':
        updates.isFeatured = false;
        break;
    }

    const updated = await this.vendorModel.findByIdAndUpdate(id, updates, { new: true });
    if (!updated) throw new NotFoundException('Vendor not found');
    return updated;
  }

  async getPendingVendors(): Promise<Vendor[]> {
    return this.vendorModel
      .find({ isVerified: false, isActive: true })
      .populate('userId', 'firstName lastName email')
      .populate('stateId', 'name')
      .populate('areaId', 'name')
      .sort({ createdAt: -1 });
  }

  // ==================== PRODUCT MANAGEMENT ====================

  async getAllProducts(filters: {
    page?: number;
    limit?: number;
    status?: ProductStatus;
    search?: string;
    vendorId?: string;
  }): Promise<{ products: Product[]; total: number; page: number; totalPages: number }> {
    const { page = 1, limit = 20, status, search, vendorId } = filters;
    const skip = (page - 1) * limit;

    const query: any = {};
    if (status) query.status = status;
    if (vendorId) query.vendorId = vendorId;
    if (search) {
      query.$or = [
        { name: { $regex: search, $options: 'i' } },
        { description: { $regex: search, $options: 'i' } },
      ];
    }

    const [products, total] = await Promise.all([
      this.productModel
        .find(query)
        .populate({
          path: 'vendorId',
          select: 'businessName isVerified',
        })
        .skip(skip)
        .limit(limit)
        .sort({ createdAt: -1 }),
      this.productModel.countDocuments(query),
    ]);

    return {
      products,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async getProductById(id: string): Promise<Product> {
    const product = await this.productModel
      .findById(id)
      .populate('vendorId');
    if (!product) throw new NotFoundException('Product not found');
    return product;
  }

  async updateProduct(id: string, dto: AdminUpdateProductDto): Promise<Product> {
    const product = await this.productModel.findByIdAndUpdate(id, dto, { new: true });
    if (!product) throw new NotFoundException('Product not found');
    return product;
  }

  async productAction(id: string, dto: AdminProductActionDto): Promise<Product> {
    const product = await this.productModel.findById(id);
    if (!product) throw new NotFoundException('Product not found');

    const updates: any = {};

    switch (dto.action) {
      case 'approve':
        updates.status = ProductStatus.APPROVED;
        break;
      case 'reject':
        updates.status = ProductStatus.REJECTED;
        break;
      case 'flag':
        updates.status = ProductStatus.PENDING;
        break;
      case 'delete':
        await this.productModel.deleteOne({ _id: id });
        return product;
    }
    const updated = await this.productModel.findByIdAndUpdate(id, updates, { new: true });
    if (!updated) throw new NotFoundException('Product not found');
    return updated;
  }

  async getPendingProducts(): Promise<Product[]> {
    return this.productModel
      .find({ status: ProductStatus.PENDING })
      .populate('vendorId', 'businessName')
      .sort({ createdAt: -1 });
  }

  async bulkApproveProducts(ids: string[]): Promise<number> {
    const result = await this.productModel.updateMany(
      { _id: { $in: ids } },
      { status: ProductStatus.APPROVED },
    );
    return result.modifiedCount;
  }

  async bulkRejectProducts(ids: string[], reason?: string): Promise<number> {
    const result = await this.productModel.updateMany(
      { _id: { $in: ids } },
      { status: ProductStatus.REJECTED },
    );
    return result.modifiedCount;
  }
}
import { IsString, IsOptional, IsArray, IsNumber, IsMongoId } from 'class-validator';

export class CreateAreaDto {
  @IsString()
  name: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsMongoId()
  stateId: string;

  @IsString()
  @IsOptional()
  localGovernment?: string;

  @IsArray()
  @IsNumber({}, { each: true })
  @IsOptional()
  coordinates?: [number, number];

  @IsString()
  @IsOptional()
  postalCode?: string;
}
import { IsString, IsOptional, IsArray, IsNumber, IsBoolean } from 'class-validator';

export class UpdateAreaDto {
  @IsString()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsString()
  @IsOptional()
  localGovernment?: string;

  @IsArray()
  @IsNumber({}, { each: true })
  @IsOptional()
  coordinates?: [number, number];

  @IsString()
  @IsOptional()
  postalCode?: string;

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;
}
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ timestamps: true })
export class Area extends Document {
  @Prop({ required: true })
  name: string;

  @Prop()
  description?: string;

  @Prop({ type: Types.ObjectId, ref: 'State', required: true })
  stateId: Types.ObjectId;

  @Prop()
  localGovernment?: string;

  @Prop({ type: { type: String, enum: ['Point'], default: 'Point' }, coordinates: [Number] })
  location?: {
    type: 'Point';
    coordinates: [number, number];
  };

  @Prop()
  postalCode?: string;

  @Prop({ default: true })
  isActive: boolean;
}

export const AreaSchema = SchemaFactory.createForClass(Area);

AreaSchema.index({ location: '2dsphere' });
AreaSchema.index({ stateId: 1 });
AreaSchema.index({ name: 1, stateId: 1 });
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  UseGuards,
} from '@nestjs/common';
import { AreasService } from './areas.service';
import { CreateAreaDto } from './dto/create-area.dto';
import { UpdateAreaDto } from './dto/update-area.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { Role } from '../common/enums/role.enum';

@Controller('areas')
export class AreasController {
  constructor(private areasService: AreasService) {}

  @Get()
  findAll() {
    return this.areasService.findAll();
  }

  @Get('state/:stateId')
  findByState(@Param('stateId') stateId: string) {
    return this.areasService.findByState(stateId);
  }

  @Get('nearby')
  findNearby(
    @Query('longitude') longitude: number,
    @Query('latitude') latitude: number,
    @Query('distance') distance?: number,
  ) {
    return this.areasService.findNearby(longitude, latitude, distance);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.areasService.findById(id);
  }

  @Post()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  create(@Body() dto: CreateAreaDto) {
    return this.areasService.create(dto);
  }

  @Put(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  update(@Param('id') id: string, @Body() dto: UpdateAreaDto) {
    return this.areasService.update(id, dto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.SUPER_ADMIN)
  delete(@Param('id') id: string) {
    return this.areasService.delete(id);
  }
}
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { AreasService } from './areas.service';
import { AreasController } from './areas.controller';
import { Area, AreaSchema } from './schemas/area.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: Area.name, schema: AreaSchema }]),
  ],
  controllers: [AreasController],
  providers: [AreasService],
  exports: [AreasService],
})
export class AreasModule {}
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Area } from './schemas/area.schema';
import { CreateAreaDto } from './dto/create-area.dto';
import { UpdateAreaDto } from './dto/update-area.dto';

@Injectable()
export class AreasService {
  constructor(@InjectModel(Area.name) private areaModel: Model<Area>) {}

  async create(dto: CreateAreaDto): Promise<Area> {
    const areaData: any = { ...dto };
    if (dto.coordinates) {
      areaData.location = {
        type: 'Point',
        coordinates: dto.coordinates,
      };
    }
    delete areaData.coordinates;
    return this.areaModel.create(areaData);
  }

  async findAll(): Promise<Area[]> {
    return this.areaModel
      .find({ isActive: true })
      .populate('stateId', 'name code')
      .sort({ name: 1 });
  }

  async findByState(stateId: string): Promise<Area[]> {
    // ✅ Convert string to ObjectId — MongoDB stores stateId as ObjectId
    const objectId = new Types.ObjectId(stateId);

    return this.areaModel
      .find({ stateId: objectId, isActive: true })
      .populate('stateId', 'name code')
      .sort({ name: 1 });
  }

  async findById(id: string): Promise<Area> {
    const area = await this.areaModel
      .findById(id)
      .populate('stateId', 'name code');
    if (!area) {
      throw new NotFoundException('Area not found');
    }
    return area;
  }

  async findNearby(
    longitude: number,
    latitude: number,
    maxDistanceKm: number = 10,
  ): Promise<Area[]> {
    return this.areaModel.find({
      location: {
        $near: {
          $geometry: {
            type: 'Point',
            coordinates: [longitude, latitude],
          },
          $maxDistance: maxDistanceKm * 1000,
        },
      },
      isActive: true,
    }).populate('stateId', 'name code');
  }

  async update(id: string, dto: UpdateAreaDto): Promise<Area> {
    const updateData: any = { ...dto };
    if (dto.coordinates) {
      updateData.location = {
        type: 'Point',
        coordinates: dto.coordinates,
      };
    }
    delete updateData.coordinates;

    const area = await this.areaModel
      .findByIdAndUpdate(id, updateData, { new: true })
      .populate('stateId', 'name code');
    if (!area) {
      throw new NotFoundException('Area not found');
    }
    return area;
  }

  async delete(id: string): Promise<void> {
    const result = await this.areaModel.deleteOne({ _id: id });
    if (result.deletedCount === 0) {
      throw new NotFoundException('Area not found');
    }
  }
}
import { SetMetadata } from '@nestjs/common';
import { Role } from '../../common/enums/role.enum';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: Role[]) => SetMetadata(ROLES_KEY, roles);
import { IsEmail, IsString } from 'class-validator';

export class LoginDto {
  @IsEmail()
  email: string;

  @IsString()
  password: string;
}
import { IsEmail, IsString, MinLength, IsOptional, IsEnum } from 'class-validator';
import { Role } from '../../common/enums/role.enum';

export class RegisterDto {
  @IsString()
  @MinLength(2)
  firstName: string;

  @IsString()
  @MinLength(2)
  lastName: string;

  @IsEmail()
  email: string;

  @IsString()
  @MinLength(6)
  password: string;

  @IsString()
  phone: string;

  @IsEnum(Role)
  @IsOptional()
  role?: Role = Role.USER;
}
import { Injectable, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  canActivate(context: ExecutionContext) {
    return super.canActivate(context);
  }

  handleRequest(err: any, user: any, info: any) {
    if (err || !user) {
      throw err || new UnauthorizedException('Authentication required');
    }
    return user;
  }
}
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Role } from '../../common/enums/role.enum';
import { ROLES_KEY } from '../decorators/roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<Role[]>(ROLES_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (!requiredRoles) {
      return true;
    }

    const { user } = context.switchToHttp().getRequest();
    return requiredRoles.some((role) => user.role === role);
  }
}
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
import { UsersService } from '../../users/users.service';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(
    configService: ConfigService,
    private usersService: UsersService,
  ) {
    const jwtSecret = configService.get<string>('JWT_SECRET');
    if (!jwtSecret) {
      throw new Error('JWT_SECRET is not defined');
    }
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: jwtSecret,
    });
  }

  async validate(payload: any) {
    const user = await this.usersService.findById(payload.sub);
    if (!user) {
      throw new UnauthorizedException('User not found');
    }
    return {
      id: user._id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      role: user.role,
    };
  }
}
import {
  Controller,
  Post,
  Body,
  Get,
  UseGuards,
  Request,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';
import { JwtAuthGuard } from './guards/jwt-auth.guard';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Post('register')
  register(@Body() dto: RegisterDto) {
    return this.authService.register(dto);
  }

  @Post('login')
  login(@Body() dto: LoginDto) {
    return this.authService.login(dto);
  }

  @UseGuards(JwtAuthGuard)
  @Get('me')
  getMe(@Request() req) {
    return req.user;
  }

  @Get('health')
  health() {
    return { status: 'ok', timestamp: new Date().toISOString() };
  }
}
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { JwtStrategy } from './strategies/jwt.strategy';
import { UsersModule } from '../users/users.module';

@Module({
  imports: [
    UsersModule,
    PassportModule.register({ defaultStrategy: 'jwt' }),
    ConfigModule,
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_SECRET'),
        signOptions: {
          expiresIn: configService.get<string>('JWT_EXPIRES_IN') as any || '7d',
        },
      }),
      inject: [ConfigService],
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy],
  exports: [JwtStrategy, PassportModule, AuthService],
})
export class AuthModule {}
import {
  Injectable,
  UnauthorizedException,
  ConflictException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import * as bcrypt from 'bcryptjs';
import { UsersService } from '../users/users.service';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService,
    private configService: ConfigService,
  ) {}

  async register(dto: RegisterDto) {
    const exists = await this.usersService.findByEmail(dto.email);
    if (exists) {
      throw new ConflictException('Email already exists');
    }

    const hashedPassword = await bcrypt.hash(dto.password, 12);
    const user = await this.usersService.create({
      ...dto,
      password: hashedPassword,
    });

    const token = this.generateToken(user);

    return {
      access_token: token,
      user: {
        id: user._id,
        firstName: user.firstName,
        lastName: user.lastName,
        email: user.email,
        role: user.role,
      },
    };
  }

  async login(dto: LoginDto) {
    const user = await this.usersService.findByEmail(dto.email);
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const isValid = await bcrypt.compare(dto.password, user.password);
    if (!isValid) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const token = this.generateToken(user);

    return {
      access_token: token,
      user: {
        id: user._id,
        firstName: user.firstName,
        lastName: user.lastName,
        email: user.email,
        role: user.role,
      },
    };
  }

  private generateToken(user: any): string {
    return this.jwtService.sign(
      {
        sub: user._id.toString(),
        email: user.email,
        role: user.role,
      },
      { secret: this.configService.get<string>('JWT_SECRET') },
    );
  }
}
import { IsString, IsOptional, IsArray, IsObject } from 'class-validator';

export class CreateCatalogItemDto {
  @IsString()
  name: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsString()
  @IsOptional()
  sku?: string;

  @IsString()
  @IsOptional()
  barcode?: string;

  @IsString()
  @IsOptional()
  brand?: string;

  @IsString()
  category: string;

  @IsString()
  @IsOptional()
  subcategory?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  tags?: string[];

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  images?: string[];

  @IsObject()
  @IsOptional()
  specifications?: Record<string, any>;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  alternateNames?: string[];
}
import { IsOptional, IsString, IsNumber } from 'class-validator';
import { Type } from 'class-transformer';

export class FilterCatalogDto {
  @IsOptional()
  @IsString()
  search?: string;

  @IsOptional()
  @IsString()
  category?: string;

  @IsOptional()
  @IsString()
  subcategory?: string;

  @IsOptional()
  @IsString()
  brand?: string;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  limit?: number = 20;
}
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ timestamps: true })
export class CatalogItem extends Document {
  @Prop({ required: true })
  name: string;

  @Prop()
  description?: string;

  @Prop({ unique: true, sparse: true })
  sku?: string;

  @Prop({ unique: true, sparse: true })
  barcode?: string;

  @Prop()
  brand?: string;

  @Prop({ required: true })
  category: string;

  @Prop()
  subcategory?: string;

  @Prop([String])
  tags?: string[];

  @Prop([String])
  images?: string[];

  @Prop({ type: Object })
  specifications?: Record<string, any>;

  @Prop([String])
  alternateNames?: string[];

  @Prop({ default: 0 })
  totalListings: number;

  @Prop({ default: 0 })
  lowestPrice: number;

  @Prop({ default: 0 })
  highestPrice: number;

  @Prop({ default: 0 })
  averagePrice: number;

  @Prop({ default: true })
  isActive: boolean;
}

export const CatalogItemSchema = SchemaFactory.createForClass(CatalogItem);

CatalogItemSchema.index({ name: 'text', description: 'text', brand: 'text', tags: 'text' });
CatalogItemSchema.index({ category: 1, subcategory: 1 });
CatalogItemSchema.index({ sku: 1 });
CatalogItemSchema.index({ barcode: 1 });
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Query,
  UseGuards,
} from '@nestjs/common';
import { CatalogService } from './catalog.service';
import { CreateCatalogItemDto } from './dto/create-catalog-item.dto';
import { FilterCatalogDto } from './dto/filter-catalog.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { Role } from '../common/enums/role.enum';

@Controller('catalog')
export class CatalogController {
  constructor(private catalogService: CatalogService) {}

  @Get()
  findAll(@Query() filterDto: FilterCatalogDto) {
    return this.catalogService.findAll(filterDto);
  }

  @Get('categories')
  getCategories() {
    return this.catalogService.getCategories();
  }

  @Get('brands')
  getBrands(@Query('category') category?: string) {
    return this.catalogService.getBrands(category);
  }

  @Get('search')
  searchByName(@Query('name') name: string) {
    return this.catalogService.searchByName(name);
  }

  @Get('sku/:sku')
  findBySku(@Param('sku') sku: string) {
    return this.catalogService.findBySku(sku);
  }

  @Get('barcode/:barcode')
  findByBarcode(@Param('barcode') barcode: string) {
    return this.catalogService.findByBarcode(barcode);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.catalogService.findById(id);
  }

  @Post()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  create(@Body() dto: CreateCatalogItemDto) {
    return this.catalogService.create(dto);
  }
}
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CatalogController } from './catalog.controller';
import { CatalogService } from './catalog.service';
import { CatalogItem, CatalogItemSchema } from './schemas/catalog-item.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: CatalogItem.name, schema: CatalogItemSchema },
    ]),
  ],
  controllers: [CatalogController],
  providers: [CatalogService],
  exports: [CatalogService],
})
export class CatalogModule {}
import { Injectable, NotFoundException, ConflictException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CatalogItem } from './schemas/catalog-item.schema';
import { CreateCatalogItemDto } from './dto/create-catalog-item.dto';
import { FilterCatalogDto } from './dto/filter-catalog.dto';

@Injectable()
export class CatalogService {
  constructor(
    @InjectModel(CatalogItem.name) private catalogModel: Model<CatalogItem>,
  ) {}

  async create(dto: CreateCatalogItemDto): Promise<CatalogItem> {
    // Check for duplicates
    const exists = await this.catalogModel.findOne({
      $or: [
        { sku: dto.sku },
        { barcode: dto.barcode },
        { name: { $regex: `^${dto.name}$`, $options: 'i' } },
      ],
    });

    if (exists) {
      throw new ConflictException('Catalog item already exists');
    }

    return this.catalogModel.create(dto);
  }

  async findAll(filterDto: FilterCatalogDto): Promise<{
    items: CatalogItem[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const { page = 1, limit = 20, search, category, subcategory, brand } = filterDto;
    const skip = (page - 1) * limit;

    const query: Record<string, any> = { isActive: true };

    if (search) {
      query.$or = [
        { name: { $regex: search, $options: 'i' } },
        { description: { $regex: search, $options: 'i' } },
        { brand: { $regex: search, $options: 'i' } },
        { tags: { $in: [new RegExp(search, 'i')] } },
        { alternateNames: { $in: [new RegExp(search, 'i')] } },
      ];
    }

    if (category) query.category = category;
    if (subcategory) query.subcategory = subcategory;
    if (brand) query.brand = { $regex: brand, $options: 'i' };

    const [items, total] = await Promise.all([
      this.catalogModel
        .find(query)
        .skip(skip)
        .limit(limit)
        .sort({ totalListings: -1, name: 1 }),
      this.catalogModel.countDocuments(query),
    ]);

    return {
      items,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async findById(id: string): Promise<CatalogItem> {
    const item = await this.catalogModel.findById(id);
    if (!item) {
      throw new NotFoundException('Catalog item not found');
    }
    return item;
  }

  async findBySku(sku: string): Promise<CatalogItem | null> {
    return this.catalogModel.findOne({ sku });
  }

  async findByBarcode(barcode: string): Promise<CatalogItem | null> {
    return this.catalogModel.findOne({ barcode });
  }

  async searchByName(name: string): Promise<CatalogItem[]> {
    return this.catalogModel.find({
      $or: [
        { name: { $regex: name, $options: 'i' } },
        { alternateNames: { $in: [new RegExp(name, 'i')] } },
      ],
      isActive: true,
    }).limit(10);
  }

  async updatePriceStats(catalogItemId: string, prices: number[]): Promise<void> {
    if (prices.length === 0) return;

    const lowestPrice = Math.min(...prices);
    const highestPrice = Math.max(...prices);
    const averagePrice = prices.reduce((a, b) => a + b, 0) / prices.length;

    await this.catalogModel.findByIdAndUpdate(catalogItemId, {
      lowestPrice,
      highestPrice,
      averagePrice: Math.round(averagePrice * 100) / 100,
      totalListings: prices.length,
    });
  }

  async getCategories(): Promise<{ category: string; count: number }[]> {
    return this.catalogModel.aggregate([
      { $match: { isActive: true } },
      {
        $group: {
          _id: '$category',
          count: { $sum: 1 },
        },
      },
      { $sort: { count: -1 } },
      {
        $project: {
          category: '$_id',
          count: 1,
          _id: 0,
        },
      },
    ]);
  }

  async getBrands(category?: string): Promise<{ brand: string; count: number }[]> {
    const match: Record<string, any> = { isActive: true, brand: { $exists: true, $ne: null } };
    if (category) match.category = category;

    return this.catalogModel.aggregate([
      { $match: match },
      {
        $group: {
          _id: '$brand',
          count: { $sum: 1 },
        },
      },
      { $sort: { count: -1 } },
      { $limit: 50 },
      {
        $project: {
          brand: '$_id',
          count: 1,
          _id: 0,
        },
      },
    ]);
  }
}
import { NestFactory } from '@nestjs/core';
import { AppModule } from '../app.module';
import { MasterSeeder, AdminSeeder, StatesSeeder, AreasSeeder, MarketsSeeder, CategoriesSeeder } from '../database/seeders';
import { Logger } from '@nestjs/common';

async function bootstrap() {
  const logger = new Logger('SeedCommand');

  try {
    logger.log('Initializing application...');
    const app = await NestFactory.createApplicationContext(AppModule);

    const masterSeeder = app.get(MasterSeeder);
    const adminSeeder = app.get(AdminSeeder);
    const statesSeeder = app.get(StatesSeeder);
    const areasSeeder = app.get(AreasSeeder);
    const marketsSeeder = app.get(MarketsSeeder);
    const categoriesSeeder = app.get(CategoriesSeeder);

    const args = process.argv.slice(2);
    const command = args[0];

    switch (command) {
      case 'all':
        await masterSeeder.seedAll();
        break;

      case 'locations':
        await masterSeeder.seedLocations();
        break;

      case 'admins':
        await adminSeeder.seed();
        break;

      case 'states':
        await statesSeeder.seed();
        break;

      case 'areas':
        await areasSeeder.seed();
        break;

      case 'markets':
        await marketsSeeder.seed();
        break;

      case 'categories':
        await categoriesSeeder.seed();
        break;

      case 'admins:list':
        const admins = await adminSeeder.listAdmins();
        console.table(
          admins.map((a) => ({
            id: a._id.toString(),
            name: `${a.firstName} ${a.lastName}`,
            email: a.email,
            role: a.role,
          })),
        );
        break;

      default:
        logger.log('Available commands:');
        logger.log('  npm run seed all        - Seed everything');
        logger.log('  npm run seed locations  - Seed states, areas, markets');
        logger.log('  npm run seed admins     - Seed admin users');
        logger.log('  npm run seed states     - Seed Nigerian states');
        logger.log('  npm run seed areas      - Seed areas');
        logger.log('  npm run seed markets    - Seed markets');
        logger.log('  npm run seed categories - Seed product categories');
        logger.log('  npm run seed admins:list - List all admins');
        break;
    }

    await app.close();
    logger.log('Done!');
    process.exit(0);
  } catch (error) {
    logger.error(`Seed failed: ${error.message}`);
    process.exit(1);
  }
}

bootstrap();
export enum MarketType {
  TRADITIONAL_MARKET = 'traditional_market',
  SHOPPING_MALL = 'shopping_mall',
  PLAZA = 'plaza',
  SHOPPING_COMPLEX = 'shopping_complex',
  STREET_MARKET = 'street_market',
}
export enum ProductStatus {
  DRAFT = 'draft',
  PENDING = 'pending',
  APPROVED = 'approved',
  REJECTED = 'rejected',
  OUT_OF_STOCK = 'out_of_stock',
  DISCONTINUED = 'discontinued',
}

export enum ProductType {
  SALE = 'sale',
  LEASE = 'lease',
  RENT = 'rent',
  SERVICE = 'service',
}
export enum Role {
  USER = 'user',
  VENDOR = 'vendor',
  ADMIN = 'admin',
  SUPER_ADMIN = 'super_admin',
}
export enum VendorType {
  MARKET_SHOP = 'market_shop',
  MALL_SHOP = 'mall_shop',
  HOME_BASED = 'home_based',
  STREET_SHOP = 'street_shop',
  ONLINE_ONLY = 'online_only',
}
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import { Request, Response } from 'express';

@Catch()
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    let status = HttpStatus.INTERNAL_SERVER_ERROR;
    let message = 'Internal server error';
    let errors: any = null;

    if (exception instanceof HttpException) {
      status = exception.getStatus();
      const exceptionResponse = exception.getResponse();

      if (typeof exceptionResponse === 'string') {
        message = exceptionResponse;
      } else if (typeof exceptionResponse === 'object') {
        const responseObj = exceptionResponse as any;
        message = responseObj.message || message;
        errors = responseObj.errors || null;
      }
    } else if (exception instanceof Error) {
      message = exception.message;
    }

    response.status(status).json({
      success: false,
      statusCode: status,
      message: Array.isArray(message) ? message[0] : message,
      errors: errors,
      timestamp: new Date().toISOString(),
      path: request.url,
    });
  }
}
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

export interface Response<T> {
  success: boolean;
  data: T;
  message?: string;
  timestamp: string;
}

@Injectable()
export class TransformInterceptor<T>
  implements NestInterceptor<T, Response<T>>
{
  intercept(
    context: ExecutionContext,
    next: CallHandler,
  ): Observable<Response<T>> {
    return next.handle().pipe(
      map((data) => ({
        success: true,
        data: data,
        message: 'Operation successful',
        timestamp: new Date().toISOString(),
      })),
    );
  }
}
export interface GeoLocation {
  type: 'Point';
  coordinates: [number, number]; // [longitude, latitude]
}

export interface Address {
  street?: string;
  landmark?: string;
  city: string;
  state: string;
  country: string;
  postalCode?: string;
}

export interface BankDetails {
  bankName: string;
  accountName: string;
  accountNumber: string;
  bankCode?: string;
}

export interface ContactDetails {
  phone: string;
  alternatePhone?: string;
  email?: string;
  whatsapp?: string;
  instagram?: string;
  facebook?: string;
  twitter?: string;
  website?: string;
}

export interface ShopImages {
  entrancePhoto?: string;
  logo?: string;
  layoutMap?: string;
  additionalImages?: string[];
}
import { Injectable, Logger } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import * as bcrypt from 'bcryptjs';
import { User } from '../../users/schemas/user.schema';
import { Role } from '../../common/enums/role.enum';

export interface AdminSeedData {
  firstName: string;
  lastName: string;
  email: string;
  password: string;
  phone: string;
  role: Role;
}

@Injectable()
export class AdminSeeder {
  private readonly logger = new Logger(AdminSeeder.name);

  constructor(@InjectModel(User.name) private userModel: Model<User>) {}

  private getDefaultAdmins(): AdminSeedData[] {
    return [
      {
        firstName: 'Super',
        lastName: 'Admin',
        email: 'superadmin@sureshops.com',
        password: 'SuperAdmin@123!',
        phone: '08000000001',
        role: Role.SUPER_ADMIN,
      },
      {
        firstName: 'Admin',
        lastName: 'User',
        email: 'admin@sureshops.com',
        password: 'Admin@123!',
        phone: '08000000002',
        role: Role.ADMIN,
      },
      {
        firstName: 'Test',
        lastName: 'Vendor',
        email: 'vendor@sureshops.com',
        password: 'Vendor@123!',
        phone: '08000000003',
        role: Role.VENDOR,
      },
      {
        firstName: 'Test',
        lastName: 'User',
        email: 'user@sureshops.com',
        password: 'User@123!',
        phone: '08000000004',
        role: Role.USER,
      },
    ];
  }

  async seed(): Promise<void> {
    this.logger.log('Starting admin seeder...');

    const admins = this.getDefaultAdmins();

    for (const admin of admins) {
      try {
        const exists = await this.userModel.findOne({ email: admin.email.toLowerCase() });

        if (exists) {
          this.logger.warn(`User already exists: ${admin.email}`);
          continue;
        }

        const hashedPassword = await bcrypt.hash(admin.password, 12);

        await this.userModel.create({
          firstName: admin.firstName,
          lastName: admin.lastName,
          email: admin.email.toLowerCase(),
          password: hashedPassword,
          phone: admin.phone,
          role: admin.role,
          isActive: true,
          isEmailVerified: true,
        });

        this.logger.log(`Created ${admin.role}: ${admin.email}`);
      } catch (error) {
        this.logger.error(`Failed to create ${admin.email}: ${error.message}`);
      }
    }

    this.logger.log('Admin seeder completed!');
  }

  async seedCustomAdmin(data: AdminSeedData): Promise<User> {
    const exists = await this.userModel.findOne({ email: data.email.toLowerCase() });

    if (exists) {
      throw new Error(`User already exists: ${data.email}`);
    }

    const hashedPassword = await bcrypt.hash(data.password, 12);

    const user = await this.userModel.create({
      firstName: data.firstName,
      lastName: data.lastName,
      email: data.email.toLowerCase(),
      password: hashedPassword,
      phone: data.phone,
      role: data.role,
      isActive: true,
      isEmailVerified: true,
    });

    this.logger.log(`Created custom admin: ${data.email}`);
    return user;
  }

  async removeSeededAdmins(): Promise<void> {
    const admins = this.getDefaultAdmins();
    const emails = admins.map((a) => a.email.toLowerCase());

    await this.userModel.deleteMany({ email: { $in: emails } });
    this.logger.log('Removed all seeded admins');
  }

  async listAdmins(): Promise<User[]> {
    return this.userModel
      .find({ role: { $in: [Role.ADMIN, Role.SUPER_ADMIN] } })
      .select('-password')
      .sort({ createdAt: -1 });
  }
}
import { Injectable, Logger } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Area } from '../../areas/schemas/area.schema';
import { State } from '../../states/schemas/state.schema';

@Injectable()
export class AreasSeeder {
  private readonly logger = new Logger(AreasSeeder.name);

  constructor(
    @InjectModel(Area.name) private areaModel: Model<Area>,
    @InjectModel(State.name) private stateModel: Model<State>,
  ) {}

  private getAreasData() {
    return {
      LA: [
        { name: 'Ikeja', localGovernment: 'Ikeja', coordinates: [3.3517, 6.5963] },
        { name: 'Lekki', localGovernment: 'Eti-Osa', coordinates: [3.4746, 6.4698] },
        { name: 'Victoria Island', localGovernment: 'Eti-Osa', coordinates: [3.4219, 6.4281] },
        { name: 'Surulere', localGovernment: 'Surulere', coordinates: [3.3569, 6.4969] },
        { name: 'Yaba', localGovernment: 'Yaba', coordinates: [3.3792, 6.5097] },
        { name: 'Lagos Island', localGovernment: 'Lagos Island', coordinates: [3.3903, 6.4549] },
        { name: 'Ikoyi', localGovernment: 'Eti-Osa', coordinates: [3.4373, 6.4500] },
        { name: 'Ajah', localGovernment: 'Eti-Osa', coordinates: [3.5777, 6.4698] },
        { name: 'Festac', localGovernment: 'Amuwo-Odofin', coordinates: [3.2833, 6.4667] },
        { name: 'Oshodi', localGovernment: 'Oshodi-Isolo', coordinates: [3.3408, 6.5564] },
        { name: 'Maryland', localGovernment: 'Kosofe', coordinates: [3.3681, 6.5714] },
        { name: 'Gbagada', localGovernment: 'Kosofe', coordinates: [3.3922, 6.5539] },
        { name: 'Magodo', localGovernment: 'Kosofe', coordinates: [3.3833, 6.6167] },
        { name: 'Ogba', localGovernment: 'Ikeja', coordinates: [3.3425, 6.6183] },
        { name: 'Ikorodu', localGovernment: 'Ikorodu', coordinates: [3.5100, 6.6194] },
      ],
      FC: [
        { name: 'Garki', localGovernment: 'AMAC', coordinates: [7.4892, 9.0312] },
        { name: 'Wuse', localGovernment: 'AMAC', coordinates: [7.4675, 9.0678] },
        { name: 'Maitama', localGovernment: 'AMAC', coordinates: [7.4925, 9.0881] },
        { name: 'Asokoro', localGovernment: 'AMAC', coordinates: [7.5306, 9.0531] },
        { name: 'Gwarinpa', localGovernment: 'Bwari', coordinates: [7.4000, 9.1167] },
        { name: 'Kubwa', localGovernment: 'Bwari', coordinates: [7.3167, 9.1500] },
        { name: 'Lugbe', localGovernment: 'AMAC', coordinates: [7.3833, 8.9833] },
        { name: 'Nyanya', localGovernment: 'Nasarawa', coordinates: [7.5500, 9.0167] },
        { name: 'Jabi', localGovernment: 'AMAC', coordinates: [7.4247, 9.0728] },
        { name: 'Utako', localGovernment: 'AMAC', coordinates: [7.4397, 9.0764] },
      ],
      RI: [
        { name: 'Port Harcourt', localGovernment: 'Port Harcourt', coordinates: [7.0134, 4.8156] },
        { name: 'GRA Phase 1', localGovernment: 'Obio-Akpor', coordinates: [6.9903, 4.8239] },
        { name: 'GRA Phase 2', localGovernment: 'Obio-Akpor', coordinates: [6.9850, 4.8350] },
        { name: 'Rumuola', localGovernment: 'Obio-Akpor', coordinates: [6.9939, 4.8447] },
        { name: 'Rumuokwuta', localGovernment: 'Obio-Akpor', coordinates: [6.9917, 4.8553] },
        { name: 'Trans Amadi', localGovernment: 'Obio-Akpor', coordinates: [7.0333, 4.7833] },
        { name: 'Elelenwo', localGovernment: 'Obio-Akpor', coordinates: [7.0500, 4.8333] },
        { name: 'Choba', localGovernment: 'Obio-Akpor', coordinates: [6.9167, 4.8833] },
      ],
      KN: [
        { name: 'Kano Municipal', localGovernment: 'Kano Municipal', coordinates: [8.5200, 12.0000] },
        { name: 'Sabon Gari', localGovernment: 'Fagge', coordinates: [8.5167, 11.9833] },
        { name: 'Tarauni', localGovernment: 'Tarauni', coordinates: [8.5333, 11.9667] },
        { name: 'Nassarawa', localGovernment: 'Nassarawa', coordinates: [8.5500, 11.9500] },
        { name: 'Gwale', localGovernment: 'Gwale', coordinates: [8.5000, 12.0167] },
      ],
      OY: [
        { name: 'Ibadan North', localGovernment: 'Ibadan North', coordinates: [3.9000, 7.4000] },
        { name: 'Ibadan South', localGovernment: 'Ibadan South East', coordinates: [3.8833, 7.3667] },
        { name: 'Bodija', localGovernment: 'Ibadan North', coordinates: [3.9167, 7.4167] },
        { name: 'Challenge', localGovernment: 'Ibadan South East', coordinates: [3.8500, 7.3833] },
        { name: 'Ring Road', localGovernment: 'Ibadan South West', coordinates: [3.8667, 7.3833] },
        { name: 'Dugbe', localGovernment: 'Ibadan North West', coordinates: [3.8833, 7.3833] },
      ],
    };
  }

  async seed(): Promise<Area[]> {
    this.logger.log('Seeding areas...');
    const areasData = this.getAreasData();
    const createdAreas: Area[] = [];

    for (const [stateCode, areas] of Object.entries(areasData)) {
      const state = await this.stateModel.findOne({ code: stateCode });
      if (!state) {
        this.logger.warn(`State not found: ${stateCode}`);
        continue;
      }

      for (const areaData of areas) {
        const exists = await this.areaModel.findOne({
          name: areaData.name,
          stateId: state._id,
        });

        if (!exists) {
          const area = await this.areaModel.create({
            name: areaData.name,
            stateId: state._id,
            localGovernment: areaData.localGovernment,
            location: {
              type: 'Point',
              coordinates: areaData.coordinates,
            },
            isActive: true,
          });
          createdAreas.push(area);
          this.logger.log(`Created area: ${areaData.name} in ${state.name}`);
        }
      }
    }

    this.logger.log(`Areas seeding complete. Created ${createdAreas.length} areas.`);
    return createdAreas;
  }
}
import { Injectable, Logger } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CatalogItem } from '../../catalog/schemas/catalog-item.schema';

@Injectable()
export class CategoriesSeeder {
  private readonly logger = new Logger(CategoriesSeeder.name);

  constructor(
    @InjectModel(CatalogItem.name) private catalogModel: Model<CatalogItem>,
  ) {}

  private getCategories() {
    return [
      {
        category: 'Electronics',
        subcategories: ['Phones', 'Laptops', 'TVs', 'Audio', 'Cameras', 'Accessories', 'Gaming'],
        items: [
          { name: 'iPhone 15 Pro Max', brand: 'Apple', tags: ['smartphone', 'apple', 'ios'] },
          { name: 'iPhone 15 Pro', brand: 'Apple', tags: ['smartphone', 'apple', 'ios'] },
          { name: 'iPhone 15', brand: 'Apple', tags: ['smartphone', 'apple', 'ios'] },
          { name: 'Samsung Galaxy S24 Ultra', brand: 'Samsung', tags: ['smartphone', 'android', 'samsung'] },
          { name: 'Samsung Galaxy S24', brand: 'Samsung', tags: ['smartphone', 'android'] },
          { name: 'MacBook Pro 16', brand: 'Apple', tags: ['laptop', 'apple', 'macbook'] },
          { name: 'MacBook Air M3', brand: 'Apple', tags: ['laptop', 'apple', 'macbook'] },
          { name: 'HP Pavilion', brand: 'HP', tags: ['laptop', 'windows'] },
          { name: 'Dell XPS 15', brand: 'Dell', tags: ['laptop', 'windows'] },
          { name: 'PlayStation 5', brand: 'Sony', tags: ['gaming', 'console', 'ps5'] },
          { name: 'Xbox Series X', brand: 'Microsoft', tags: ['gaming', 'console', 'xbox'] },
          { name: 'Nintendo Switch', brand: 'Nintendo', tags: ['gaming', 'console'] },
          { name: 'AirPods Pro', brand: 'Apple', tags: ['audio', 'earbuds', 'wireless'] },
          { name: 'Sony WH-1000XM5', brand: 'Sony', tags: ['audio', 'headphones', 'wireless'] },
          { name: 'Samsung 55" QLED TV', brand: 'Samsung', tags: ['tv', 'smart tv'] },
          { name: 'LG 65" OLED TV', brand: 'LG', tags: ['tv', 'smart tv', 'oled'] },
        ],
      },
      {
        category: 'Fashion',
        subcategories: ['Men', 'Women', 'Kids', 'Shoes', 'Bags', 'Accessories', 'Jewelry'],
        items: [
          { name: 'Nike Air Jordan 1', brand: 'Nike', tags: ['shoes', 'sneakers', 'jordan'] },
          { name: 'Adidas Yeezy Boost 350', brand: 'Adidas', tags: ['shoes', 'sneakers', 'yeezy'] },
          { name: 'Louis Vuitton Neverfull', brand: 'Louis Vuitton', tags: ['bag', 'luxury'] },
          { name: 'Gucci GG Marmont', brand: 'Gucci', tags: ['bag', 'luxury'] },
          { name: 'Rolex Submariner', brand: 'Rolex', tags: ['watch', 'luxury'] },
          { name: 'Apple Watch Series 9', brand: 'Apple', tags: ['watch', 'smartwatch'] },
        ],
      },
      {
        category: 'Home & Garden',
        subcategories: ['Furniture', 'Kitchen', 'Bedroom', 'Bathroom', 'Garden', 'Decor'],
        items: [
          { name: 'Dyson V15 Vacuum', brand: 'Dyson', tags: ['appliance', 'cleaning'] },
          { name: 'Samsung French Door Refrigerator', brand: 'Samsung', tags: ['appliance', 'kitchen'] },
          { name: 'LG Washing Machine', brand: 'LG', tags: ['appliance', 'laundry'] },
          { name: 'KitchenAid Stand Mixer', brand: 'KitchenAid', tags: ['appliance', 'kitchen', 'baking'] },
        ],
      },
      {
        category: 'Health & Beauty',
        subcategories: ['Skincare', 'Makeup', 'Haircare', 'Fragrance', 'Personal Care', 'Supplements'],
        items: [
          { name: 'La Mer Moisturizing Cream', brand: 'La Mer', tags: ['skincare', 'luxury'] },
          { name: 'Chanel No. 5', brand: 'Chanel', tags: ['fragrance', 'perfume'] },
          { name: 'Dior Sauvage', brand: 'Dior', tags: ['fragrance', 'cologne'] },
          { name: 'MAC Ruby Woo Lipstick', brand: 'MAC', tags: ['makeup', 'lipstick'] },
        ],
      },
      {
        category: 'Sports & Outdoors',
        subcategories: ['Fitness', 'Outdoor', 'Team Sports', 'Water Sports', 'Cycling'],
        items: [
          { name: 'Peloton Bike+', brand: 'Peloton', tags: ['fitness', 'cycling', 'exercise'] },
          { name: 'Nike Dri-FIT Running Shoes', brand: 'Nike', tags: ['shoes', 'running', 'sports'] },
          { name: 'Adidas Football', brand: 'Adidas', tags: ['football', 'soccer', 'ball'] },
        ],
      },
    ];
  }

  async seed(): Promise<CatalogItem[]> {
    this.logger.log('Seeding categories and catalog items...');
    const categories = this.getCategories();
    const createdItems: CatalogItem[] = [];

    for (const cat of categories) {
      for (const item of cat.items) {
        const exists = await this.catalogModel.findOne({ name: item.name });
        if (!exists) {
          const catalogItem = await this.catalogModel.create({
            name: item.name,
            brand: item.brand,
            category: cat.category,
            tags: item.tags,
            isActive: true,
          });
          createdItems.push(catalogItem);
          this.logger.log(`Created catalog item: ${item.name}`);
        }
      }
    }

    this.logger.log(`Categories seeding complete. Created ${createdItems.length} items.`);
    return createdItems;
  }
}
export * from './admin.seeder';
export * from './states.seeder';
export * from './areas.seeder';
export * from './markets.seeder';
export * from './categories.seeder';
export * from './master.seeder';
import { Injectable, Logger } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Market } from '../../markets/schemas/market.schema';
import { Area } from '../../areas/schemas/area.schema';
import { State } from '../../states/schemas/state.schema';
import { MarketType } from '../../common/enums/market-type.enum';

interface MarketSeedData {
  name: string;
  type: MarketType;
  address: string;
  landmark?: string;
  openingTime: string;
  closingTime: string;
  operatingDays?: string[];
  coordinates?: [number, number];  // ✅ Optional real coordinates
}

interface LocationSeedData {
  stateCode: string;
  areaName: string;
  markets: MarketSeedData[];
}

@Injectable()
export class MarketsSeeder {
  private readonly logger = new Logger(MarketsSeeder.name);

  constructor(
    @InjectModel(Market.name) private marketModel: Model<Market>,
    @InjectModel(Area.name) private areaModel: Model<Area>,
    @InjectModel(State.name) private stateModel: Model<State>,
  ) {}

  private getMarketsData(): LocationSeedData[] {
    return [
      // Lagos Markets
      {
        stateCode: 'LA',
        areaName: 'Ikeja',
        markets: [
          {
            name: 'Computer Village',
            type: MarketType.TRADITIONAL_MARKET,
            address: 'Ikeja, Lagos',
            landmark: 'Near Ikeja City Mall',
            openingTime: '08:00',
            closingTime: '18:00',
            operatingDays: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            coordinates: [3.3470, 6.6018],    // ✅ [longitude, latitude]
          },
          {
            name: 'Ikeja City Mall',
            type: MarketType.SHOPPING_MALL,
            address: 'Alausa, Ikeja, Lagos',
            landmark: 'Opposite Lagos State Secretariat',
            openingTime: '09:00',
            closingTime: '21:00',
            operatingDays: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'],
            coordinates: [3.3515, 6.6105],
          },
        ],
      },
      {
        stateCode: 'LA',
        areaName: 'Lekki',
        markets: [
          {
            name: 'The Palms Shopping Mall',
            type: MarketType.SHOPPING_MALL,
            address: 'Lekki Phase 1, Lagos',
            landmark: 'Lekki Expressway',
            openingTime: '09:00',
            closingTime: '21:00',
            operatingDays: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'],
            coordinates: [3.4653, 6.4381],
          },
          {
            name: 'Circle Mall Lekki',
            type: MarketType.SHOPPING_MALL,
            address: 'Lekki, Lagos',
            openingTime: '09:00',
            closingTime: '21:00',
            coordinates: [3.5400, 6.4437],
          },
        ],
      },
      {
        stateCode: 'LA',
        areaName: 'Victoria Island',
        markets: [
          {
            name: 'Mega Plaza',
            type: MarketType.PLAZA,
            address: 'Victoria Island, Lagos',
            openingTime: '08:00',
            closingTime: '20:00',
            coordinates: [3.4226, 6.4281],
          },
        ],
      },
      {
        stateCode: 'LA',
        areaName: 'Lagos Island',
        markets: [
          {
            name: 'Balogun Market',
            type: MarketType.TRADITIONAL_MARKET,
            address: 'Lagos Island',
            landmark: 'Near Tinubu Square',
            openingTime: '06:00',
            closingTime: '19:00',
            operatingDays: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            coordinates: [3.3903, 6.4530],
          },
          {
            name: 'Idumota Market',
            type: MarketType.TRADITIONAL_MARKET,
            address: 'Lagos Island',
            openingTime: '06:00',
            closingTime: '19:00',
            coordinates: [3.3925, 6.4560],
          },
        ],
      },
      {
        stateCode: 'LA',
        areaName: 'Yaba',
        markets: [
          {
            name: 'Yaba Market',
            type: MarketType.TRADITIONAL_MARKET,
            address: 'Yaba, Lagos',
            openingTime: '07:00',
            closingTime: '18:00',
            coordinates: [3.3750, 6.5090],
          },
          {
            name: 'Tejuosho Market',
            type: MarketType.TRADITIONAL_MARKET,
            address: 'Yaba, Lagos',
            openingTime: '07:00',
            closingTime: '18:00',
            coordinates: [3.3725, 6.5115],
          },
        ],
      },
      // FCT Markets
      {
        stateCode: 'FC',
        areaName: 'Wuse',
        markets: [
          {
            name: 'Wuse Market',
            type: MarketType.TRADITIONAL_MARKET,
            address: 'Wuse Zone 5, Abuja',
            openingTime: '07:00',
            closingTime: '18:00',
            coordinates: [7.4760, 9.0700],
          },
          {
            name: 'Ceddi Plaza',
            type: MarketType.PLAZA,
            address: 'Wuse Zone 4, Abuja',
            openingTime: '09:00',
            closingTime: '20:00',
            coordinates: [7.4800, 9.0650],
          },
        ],
      },
      {
        stateCode: 'FC',
        areaName: 'Garki',
        markets: [
          {
            name: 'Garki Model Market',
            type: MarketType.TRADITIONAL_MARKET,
            address: 'Area 10, Garki, Abuja',
            openingTime: '07:00',
            closingTime: '18:00',
            coordinates: [7.4905, 9.0430],
          },
        ],
      },
      {
        stateCode: 'FC',
        areaName: 'Jabi',
        markets: [
          {
            name: 'Jabi Lake Mall',
            type: MarketType.SHOPPING_MALL,
            address: 'Jabi District, Abuja',
            openingTime: '09:00',
            closingTime: '21:00',
            operatingDays: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'],
            coordinates: [7.4150, 9.0720],
          },
        ],
      },
      // Rivers Markets
      {
        stateCode: 'RI',
        areaName: 'Port Harcourt',
        markets: [
          {
            name: 'Mile 1 Market',
            type: MarketType.TRADITIONAL_MARKET,
            address: 'Mile 1, Port Harcourt',
            openingTime: '07:00',
            closingTime: '18:00',
            coordinates: [7.0134, 4.7753],
          },
          {
            name: 'Mile 3 Market',
            type: MarketType.TRADITIONAL_MARKET,
            address: 'Mile 3, Port Harcourt',
            openingTime: '07:00',
            closingTime: '18:00',
            coordinates: [7.0200, 4.7850],
          },
          {
            name: 'Port Harcourt Mall',
            type: MarketType.SHOPPING_MALL,
            address: 'Azikiwe Road, Port Harcourt',
            openingTime: '09:00',
            closingTime: '21:00',
            coordinates: [7.0074, 4.7731],
          },
        ],
      },
      // Kano Markets
      {
        stateCode: 'KN',
        areaName: 'Kano Municipal',
        markets: [
          {
            name: 'Kurmi Market',
            type: MarketType.TRADITIONAL_MARKET,
            address: 'Kano City',
            openingTime: '07:00',
            closingTime: '18:00',
            coordinates: [8.5167, 12.0000],
          },
          {
            name: 'Singer Market',
            type: MarketType.TRADITIONAL_MARKET,
            address: 'Kano City',
            openingTime: '07:00',
            closingTime: '18:00',
            coordinates: [8.5200, 11.9960],
          },
        ],
      },
      {
        stateCode: 'KN',
        areaName: 'Sabon Gari',
        markets: [
          {
            name: 'Sabon Gari Market',
            type: MarketType.TRADITIONAL_MARKET,
            address: 'Sabon Gari, Kano',
            openingTime: '07:00',
            closingTime: '18:00',
            coordinates: [8.5230, 11.9820],
          },
        ],
      },
      // Oyo Markets
      {
        stateCode: 'OY',
        areaName: 'Ibadan North',
        markets: [
          {
            name: 'Bodija Market',
            type: MarketType.TRADITIONAL_MARKET,
            address: 'Bodija, Ibadan',
            openingTime: '06:00',
            closingTime: '18:00',
            coordinates: [3.9100, 7.4167],
          },
          {
            name: 'Palms Mall Ibadan',
            type: MarketType.SHOPPING_MALL,
            address: 'Ring Road, Ibadan',
            openingTime: '09:00',
            closingTime: '21:00',
            coordinates: [3.8950, 7.3800],
          },
        ],
      },
      {
        stateCode: 'OY',
        areaName: 'Dugbe',
        markets: [
          {
            name: 'Dugbe Market',
            type: MarketType.TRADITIONAL_MARKET,
            address: 'Dugbe, Ibadan',
            openingTime: '06:00',
            closingTime: '18:00',
            coordinates: [3.8780, 7.3880],
          },
        ],
      },
    ];
  }

  async seed(): Promise<Market[]> {
    this.logger.log('Seeding markets...');
    const marketsData = this.getMarketsData();
    const createdMarkets: Market[] = [];

    for (const location of marketsData) {
      const state = await this.stateModel.findOne({ code: location.stateCode });
      if (!state) continue;

      const area = await this.areaModel.findOne({
        name: location.areaName,
        stateId: state._id,
      });
      if (!area) continue;

      for (const marketData of location.markets) {
        const exists = await this.marketModel.findOne({
          name: marketData.name,
          areaId: area._id,
        });

        if (!exists) {
          // ✅ Build document — only include location when coordinates exist
          const marketDoc: Record<string, any> = {
            name: marketData.name,
            type: marketData.type,
            stateId: state._id,
            areaId: area._id,
            address: marketData.address,
            landmark: marketData.landmark,
            openingTime: marketData.openingTime,
            closingTime: marketData.closingTime,
            operatingDays: marketData.operatingDays || [
              'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday',
            ],
            isActive: true,
          };

          // ✅ Only set location when we have real coordinates
          if (marketData.coordinates) {
            marketDoc.location = {
              type: 'Point',
              coordinates: marketData.coordinates,
            };
          }

          const market = await this.marketModel.create(marketDoc);
          createdMarkets.push(market);
          this.logger.log(`Created market: ${marketData.name}`);
        }
      }
    }

    this.logger.log(`Markets seeding complete. Created ${createdMarkets.length} markets.`);
    return createdMarkets;
  }
}
import { Injectable, Logger } from '@nestjs/common';
import { AdminSeeder } from './admin.seeder';
import { StatesSeeder } from './states.seeder';
import { AreasSeeder } from './areas.seeder';
import { MarketsSeeder } from './markets.seeder';
import { CategoriesSeeder } from './categories.seeder';

@Injectable()
export class MasterSeeder {
  private readonly logger = new Logger(MasterSeeder.name);

  constructor(
    private adminSeeder: AdminSeeder,
    private statesSeeder: StatesSeeder,
    private areasSeeder: AreasSeeder,
    private marketsSeeder: MarketsSeeder,
    private categoriesSeeder: CategoriesSeeder,
  ) {}

  async seedAll(): Promise<void> {
    this.logger.log('Starting master seed...');

    try {
      // Seed in order of dependencies
      await this.statesSeeder.seed();
      await this.areasSeeder.seed();
      await this.marketsSeeder.seed();
      await this.categoriesSeeder.seed();
      await this.adminSeeder.seed();

      this.logger.log('Master seed completed successfully!');
    } catch (error) {
      this.logger.error(`Master seed failed: ${error.message}`);
      throw error;
    }
  }

  async seedLocations(): Promise<void> {
    await this.statesSeeder.seed();
    await this.areasSeeder.seed();
    await this.marketsSeeder.seed();
  }

  async seedUsers(): Promise<void> {
    await this.adminSeeder.seed();
  }

  async seedCatalog(): Promise<void> {
    await this.categoriesSeeder.seed();
  }
}
import { Injectable, Logger } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { State } from '../../states/schemas/state.schema';

@Injectable()
export class StatesSeeder {
  private readonly logger = new Logger(StatesSeeder.name);

  constructor(@InjectModel(State.name) private stateModel: Model<State>) {}

  private getNigerianStates() {
    return [
      { name: 'Abia', code: 'AB', capital: 'Umuahia', coordinates: [7.5248, 5.5320] },
      { name: 'Adamawa', code: 'AD', capital: 'Yola', coordinates: [12.4634, 9.3265] },
      { name: 'Akwa Ibom', code: 'AK', capital: 'Uyo', coordinates: [7.9304, 5.0377] },
      { name: 'Anambra', code: 'AN', capital: 'Awka', coordinates: [7.0068, 6.2209] },
      { name: 'Bauchi', code: 'BA', capital: 'Bauchi', coordinates: [9.8442, 10.3158] },
      { name: 'Bayelsa', code: 'BY', capital: 'Yenagoa', coordinates: [6.2638, 4.9316] },
      { name: 'Benue', code: 'BE', capital: 'Makurdi', coordinates: [8.5391, 7.7322] },
      { name: 'Borno', code: 'BO', capital: 'Maiduguri', coordinates: [13.1510, 11.8333] },
      { name: 'Cross River', code: 'CR', capital: 'Calabar', coordinates: [8.3417, 4.9757] },
      { name: 'Delta', code: 'DE', capital: 'Asaba', coordinates: [6.7540, 6.1981] },
      { name: 'Ebonyi', code: 'EB', capital: 'Abakaliki', coordinates: [8.1137, 6.3249] },
      { name: 'Edo', code: 'ED', capital: 'Benin City', coordinates: [5.6145, 6.3350] },
      { name: 'Ekiti', code: 'EK', capital: 'Ado-Ekiti', coordinates: [5.2194, 7.6256] },
      { name: 'Enugu', code: 'EN', capital: 'Enugu', coordinates: [7.4951, 6.4584] },
      { name: 'FCT', code: 'FC', capital: 'Abuja', coordinates: [7.4951, 9.0579] },
      { name: 'Gombe', code: 'GO', capital: 'Gombe', coordinates: [11.1728, 10.2897] },
      { name: 'Imo', code: 'IM', capital: 'Owerri', coordinates: [7.0352, 5.4836] },
      { name: 'Jigawa', code: 'JI', capital: 'Dutse', coordinates: [9.3399, 11.7574] },
      { name: 'Kaduna', code: 'KD', capital: 'Kaduna', coordinates: [7.4388, 10.5105] },
      { name: 'Kano', code: 'KN', capital: 'Kano', coordinates: [8.5364, 11.9964] },
      { name: 'Katsina', code: 'KT', capital: 'Katsina', coordinates: [7.6006, 13.0059] },
      { name: 'Kebbi', code: 'KE', capital: 'Birnin Kebbi', coordinates: [4.1994, 12.4539] },
      { name: 'Kogi', code: 'KO', capital: 'Lokoja', coordinates: [6.7429, 7.8023] },
      { name: 'Kwara', code: 'KW', capital: 'Ilorin', coordinates: [4.5418, 8.4966] },
      { name: 'Lagos', code: 'LA', capital: 'Ikeja', coordinates: [3.3792, 6.5244] },
      { name: 'Nasarawa', code: 'NA', capital: 'Lafia', coordinates: [8.5200, 8.5200] },
      { name: 'Niger', code: 'NI', capital: 'Minna', coordinates: [6.5569, 9.6139] },
      { name: 'Ogun', code: 'OG', capital: 'Abeokuta', coordinates: [3.3515, 7.1604] },
      { name: 'Ondo', code: 'ON', capital: 'Akure', coordinates: [5.1950, 7.2526] },
      { name: 'Osun', code: 'OS', capital: 'Osogbo', coordinates: [4.5624, 7.7827] },
      { name: 'Oyo', code: 'OY', capital: 'Ibadan', coordinates: [3.8963, 7.3775] },
      { name: 'Plateau', code: 'PL', capital: 'Jos', coordinates: [8.8921, 9.8965] },
      { name: 'Rivers', code: 'RI', capital: 'Port Harcourt', coordinates: [7.0134, 4.8156] },
      { name: 'Sokoto', code: 'SO', capital: 'Sokoto', coordinates: [5.2476, 13.0533] },
      { name: 'Taraba', code: 'TA', capital: 'Jalingo', coordinates: [11.3596, 8.8929] },
      { name: 'Yobe', code: 'YO', capital: 'Damaturu', coordinates: [11.9610, 11.7480] },
      { name: 'Zamfara', code: 'ZA', capital: 'Gusau', coordinates: [6.6542, 12.1628] },
    ];
  }

  async seed(): Promise<State[]> {
    this.logger.log('Seeding Nigerian states...');
    const states = this.getNigerianStates();
    const createdStates: State[] = [];

    for (const stateData of states) {
      const exists = await this.stateModel.findOne({ code: stateData.code });
      if (!exists) {
        const state = await this.stateModel.create({
          name: stateData.name,
          code: stateData.code,
          capital: stateData.capital,
          location: {
            type: 'Point',
            coordinates: stateData.coordinates,
          },
          isActive: true,
        });
        createdStates.push(state);
        this.logger.log(`Created state: ${stateData.name}`);
      }
    }

    this.logger.log(`States seeding complete. Created ${createdStates.length} states.`);
    return createdStates;
  }

  async getStateByCode(code: string): Promise<State | null> {
    return this.stateModel.findOne({ code });
  }
}
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { User, UserSchema } from '../users/schemas/user.schema';
import { State, StateSchema } from '../states/schemas/state.schema';
import { Area, AreaSchema } from '../areas/schemas/area.schema';
import { Market, MarketSchema } from '../markets/schemas/market.schema';
import { CatalogItem, CatalogItemSchema } from '../catalog/schemas/catalog-item.schema';
import {
  AdminSeeder,
  StatesSeeder,
  AreasSeeder,
  MarketsSeeder,
  CategoriesSeeder,
  MasterSeeder,
} from './seeders';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: User.name, schema: UserSchema },
      { name: State.name, schema: StateSchema },
      { name: Area.name, schema: AreaSchema },
      { name: Market.name, schema: MarketSchema },
      { name: CatalogItem.name, schema: CatalogItemSchema },
    ]),
  ],
  providers: [
    AdminSeeder,
    StatesSeeder,
    AreasSeeder,
    MarketsSeeder,
    CategoriesSeeder,
    MasterSeeder,
  ],
  exports: [
    AdminSeeder,
    StatesSeeder,
    AreasSeeder,
    MarketsSeeder,
    CategoriesSeeder,
    MasterSeeder,
  ],
})
export class DatabaseModule {}
import { IsEnum, IsMongoId } from 'class-validator';
import { FavoriteType } from '../schemas/favorite.schema';

export class CreateFavoriteDto {
  @IsEnum(FavoriteType)
  type: FavoriteType;

  @IsMongoId()
  itemId: string;
}

export class ToggleFavoriteDto {
  @IsEnum(FavoriteType)
  type: FavoriteType;

  @IsMongoId()
  itemId: string;
}
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export enum FavoriteType {
  PRODUCT = 'product',
  VENDOR = 'vendor',
}

@Schema({ timestamps: true })
export class Favorite extends Document {
  @Prop({ type: Types.ObjectId, ref: 'User', required: true })
  userId: Types.ObjectId;

  @Prop({ type: String, enum: FavoriteType, required: true })
  type: FavoriteType;

  @Prop({ type: Types.ObjectId, refPath: 'type', required: true })
  itemId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Product' })
  productId?: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Vendor' })
  vendorId?: Types.ObjectId;
}

export const FavoriteSchema = SchemaFactory.createForClass(Favorite);

FavoriteSchema.index({ userId: 1, type: 1, itemId: 1 }, { unique: true });
FavoriteSchema.index({ userId: 1, type: 1 });
import {
  Controller,
  Get,
  Post,
  Delete,
  Body,
  Param,
  Query,
  UseGuards,
  Request,
} from '@nestjs/common';
import { FavoritesService } from './favorites.service';
import { CreateFavoriteDto, ToggleFavoriteDto } from './dto/create-favorite.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { FavoriteType } from './schemas/favorite.schema';

@Controller('favorites')
@UseGuards(JwtAuthGuard)
export class FavoritesController {
  constructor(private favoritesService: FavoritesService) {}

  @Get()
  getUserFavorites(@Request() req, @Query('type') type?: FavoriteType) {
    return this.favoritesService.getUserFavorites(req.user.id, type);
  }

  @Get('products')
  getFavoriteProducts(@Request() req) {
    return this.favoritesService.getFavoriteProducts(req.user.id);
  }

  @Get('vendors')
  getFavoriteVendors(@Request() req) {
    return this.favoritesService.getFavoriteVendors(req.user.id);
  }

  @Get('count')
  getFavoriteCount(@Request() req) {
    return this.favoritesService.getFavoriteCount(req.user.id);
  }

  @Get('check/:type/:itemId')
  checkIsFavorite(
    @Request() req,
    @Param('type') type: FavoriteType,
    @Param('itemId') itemId: string,
  ) {
    return this.favoritesService.isFavorite(req.user.id, type, itemId);
  }

  @Post('check-multiple')
  checkMultipleFavorites(
    @Request() req,
    @Body() items: { type: FavoriteType; itemId: string }[],
  ) {
    return this.favoritesService.checkFavorites(req.user.id, items);
  }

  @Post()
  addFavorite(@Request() req, @Body() dto: CreateFavoriteDto) {
    return this.favoritesService.addFavorite(req.user.id, dto);
  }

  @Post('toggle')
  toggleFavorite(@Request() req, @Body() dto: ToggleFavoriteDto) {
    return this.favoritesService.toggleFavorite(req.user.id, dto);
  }

  @Delete(':type/:itemId')
  removeFavorite(
    @Request() req,
    @Param('type') type: FavoriteType,
    @Param('itemId') itemId: string,
  ) {
    return this.favoritesService.removeFavorite(req.user.id, type, itemId);
  }
}
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { FavoritesController } from './favorites.controller';
import { FavoritesService } from './favorites.service';
import { Favorite, FavoriteSchema } from './schemas/favorite.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: Favorite.name, schema: FavoriteSchema }]),
  ],
  controllers: [FavoritesController],
  providers: [FavoritesService],
  exports: [FavoritesService],
})
export class FavoritesModule {}
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Favorite, FavoriteType } from './schemas/favorite.schema';
import { CreateFavoriteDto } from './dto/create-favorite.dto';

@Injectable()
export class FavoritesService {
  constructor(
    @InjectModel(Favorite.name) private favoriteModel: Model<Favorite>,
  ) {}

  async addFavorite(userId: string, dto: CreateFavoriteDto): Promise<Favorite> {
    const existing = await this.favoriteModel.findOne({
      userId,
      type: dto.type,
      itemId: dto.itemId,
    });

    if (existing) {
      return existing;
    }

    const favoriteData: any = {
      userId,
      type: dto.type,
      itemId: dto.itemId,
    };

    if (dto.type === FavoriteType.PRODUCT) {
      favoriteData.productId = dto.itemId;
    } else {
      favoriteData.vendorId = dto.itemId;
    }

    return this.favoriteModel.create(favoriteData);
  }

  async removeFavorite(userId: string, type: FavoriteType, itemId: string): Promise<void> {
    await this.favoriteModel.deleteOne({ userId, type, itemId });
  }

  async toggleFavorite(userId: string, dto: CreateFavoriteDto): Promise<{ isFavorite: boolean }> {
    const existing = await this.favoriteModel.findOne({
      userId,
      type: dto.type,
      itemId: dto.itemId,
    });

    if (existing) {
      await this.favoriteModel.deleteOne({ _id: existing._id });
      return { isFavorite: false };
    }

    await this.addFavorite(userId, dto);
    return { isFavorite: true };
  }

  async getUserFavorites(
    userId: string,
    type?: FavoriteType,
  ): Promise<Favorite[]> {
    const query: any = { userId };
    if (type) query.type = type;

    return this.favoriteModel
      .find(query)
      .populate({
        path: 'productId',
        select: 'name price images category vendorId',
        populate: {
          path: 'vendorId',
          select: 'businessName shopImages',
        },
      })
      .populate({
        path: 'vendorId',
        select: 'businessName businessDescription shopImages rating totalProducts',
      })
      .sort({ createdAt: -1 });
  }

  async getFavoriteProducts(userId: string): Promise<Favorite[]> {
    return this.getUserFavorites(userId, FavoriteType.PRODUCT);
  }

  async getFavoriteVendors(userId: string): Promise<Favorite[]> {
    return this.getUserFavorites(userId, FavoriteType.VENDOR);
  }

  async isFavorite(userId: string, type: FavoriteType, itemId: string): Promise<boolean> {
    const count = await this.favoriteModel.countDocuments({ userId, type, itemId });
    return count > 0;
  }

  async checkFavorites(
    userId: string,
    items: { type: FavoriteType; itemId: string }[],
  ): Promise<{ [key: string]: boolean }> {
    const favorites = await this.favoriteModel.find({
      userId,
      $or: items.map((item) => ({ type: item.type, itemId: item.itemId })),
    });

    const result: { [key: string]: boolean } = {};
    items.forEach((item) => {
      const key = `${item.type}_${item.itemId}`;
      result[key] = favorites.some(
        (f) => f.type === item.type && f.itemId.toString() === item.itemId,
      );
    });

    return result;
  }

  async getFavoriteCount(userId: string): Promise<{ products: number; vendors: number }> {
    const [products, vendors] = await Promise.all([
      this.favoriteModel.countDocuments({ userId, type: FavoriteType.PRODUCT }),
      this.favoriteModel.countDocuments({ userId, type: FavoriteType.VENDOR }),
    ]);
    return { products, vendors };
  }
}
import {
  IsString,
  IsOptional,
  IsArray,
  IsNumber,
  IsMongoId,
  IsEnum,
  IsEmail,
} from 'class-validator';
import { MarketType } from '../../common/enums/market-type.enum';

export class CreateMarketDto {
  @IsString()
  name: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsEnum(MarketType)
  type: MarketType;

  @IsMongoId()
  stateId: string;

  @IsMongoId()
  areaId: string;

  @IsString()
  @IsOptional()
  address?: string;

  @IsString()
  @IsOptional()
  landmark?: string;

  @IsArray()
  @IsNumber({}, { each: true })
  @IsOptional()
  coordinates?: [number, number];

  @IsString()
  @IsOptional()
  entrancePhoto?: string;

  @IsString()
  @IsOptional()
  layoutMap?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  additionalPhotos?: string[];

  @IsString()
  @IsOptional()
  openingTime?: string;

  @IsString()
  @IsOptional()
  closingTime?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  operatingDays?: string[];

  @IsString()
  @IsOptional()
  contactPhone?: string;

  @IsEmail()
  @IsOptional()
  contactEmail?: string;
}
import { IsOptional, IsString, IsEnum, IsNumber, IsMongoId } from 'class-validator';
import { Type } from 'class-transformer';
import { MarketType } from '../../common/enums/market-type.enum';

export class FilterMarketDto {
  @IsOptional()
  @IsMongoId()
  stateId?: string;

  @IsOptional()
  @IsMongoId()
  areaId?: string;

  @IsOptional()
  @IsEnum(MarketType)
  type?: MarketType;

  @IsOptional()
  @IsString()
  search?: string;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  longitude?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  latitude?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  maxDistance?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  limit?: number = 20;
}
import {
  IsString,
  IsOptional,
  IsArray,
  IsNumber,
  IsEnum,
  IsEmail,
  IsBoolean,
} from 'class-validator';
import { MarketType } from '../../common/enums/market-type.enum';

export class UpdateMarketDto {
  @IsString()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsEnum(MarketType)
  @IsOptional()
  type?: MarketType;

  @IsString()
  @IsOptional()
  address?: string;

  @IsString()
  @IsOptional()
  landmark?: string;

  @IsArray()
  @IsNumber({}, { each: true })
  @IsOptional()
  coordinates?: [number, number];

  @IsString()
  @IsOptional()
  entrancePhoto?: string;

  @IsString()
  @IsOptional()
  layoutMap?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  additionalPhotos?: string[];

  @IsString()
  @IsOptional()
  openingTime?: string;

  @IsString()
  @IsOptional()
  closingTime?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  operatingDays?: string[];

  @IsString()
  @IsOptional()
  contactPhone?: string;

  @IsEmail()
  @IsOptional()
  contactEmail?: string;

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;

  @IsBoolean()
  @IsOptional()
  isVerified?: boolean;
}
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types, Schema as MongooseSchema } from 'mongoose';
import { MarketType } from '../../common/enums/market-type.enum';

@Schema({ timestamps: true })
export class Market extends Document {
  @Prop({ required: true })
  name: string;

  @Prop()
  description?: string;

  @Prop({ type: String, enum: MarketType, required: true })
  type: MarketType;

  @Prop({ type: Types.ObjectId, ref: 'State', required: true })
  stateId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Area', required: true })
  areaId: Types.ObjectId;

  @Prop()
  address?: string;

  @Prop()
  landmark?: string;

  // ✅ FIX: Simple type declaration — schema defined below
  @Prop({ type: Object })
  location?: {
    type: 'Point';
    coordinates: [number, number];
  };

  @Prop()
  entrancePhoto?: string;

  @Prop()
  layoutMap?: string;

  @Prop({ type: [String], default: [] })
  additionalPhotos?: string[];

  @Prop()
  openingTime?: string;

  @Prop()
  closingTime?: string;

  @Prop({ type: [String] })
  operatingDays?: string[];

  @Prop()
  contactPhone?: string;

  @Prop()
  contactEmail?: string;

  @Prop({ default: 0 })
  totalShops: number;

  @Prop({ default: true })
  isActive: boolean;

  @Prop({ default: false })
  isVerified: boolean;
}

export const MarketSchema = SchemaFactory.createForClass(Market);

// ✅ FIX: Define the location path AFTER schema creation
//         This gives us full control over the sub-schema
MarketSchema.path('location', new MongooseSchema(
  {
    type: {
      type: String,
      enum: ['Point'],
      required: true,
    },
    coordinates: {
      type: [Number],
      required: true,
    },
  },
  { _id: false }
));

// ✅ Make location not required at the document level
MarketSchema.path('location').required(false);

// ✅ sparse: true — skips documents where location is absent
MarketSchema.index({ location: '2dsphere' }, { sparse: true });
MarketSchema.index({ stateId: 1, areaId: 1 });
MarketSchema.index({ type: 1 });
MarketSchema.index({ name: 'text', address: 'text' });
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  UseGuards,
} from '@nestjs/common';
import { MarketsService } from './markets.service';
import { CreateMarketDto } from './dto/create-market.dto';
import { UpdateMarketDto } from './dto/update-market.dto';
import { FilterMarketDto } from './dto/filter-market.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { Role } from '../common/enums/role.enum';

@Controller('markets')
export class MarketsController {
  constructor(private marketsService: MarketsService) {}

  @Get()
  findAll(@Query() filterDto: FilterMarketDto) {
    return this.marketsService.findAll(filterDto);
  }

  @Get('area/:areaId')
  findByArea(@Param('areaId') areaId: string) {
    return this.marketsService.findByArea(areaId);
  }

  @Get('nearby')
  findNearby(
    @Query('longitude') longitude: number,
    @Query('latitude') latitude: number,
    @Query('distance') distance?: number,
  ) {
    return this.marketsService.findNearby(longitude, latitude, distance);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.marketsService.findById(id);
  }

  @Post()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  create(@Body() dto: CreateMarketDto) {
    return this.marketsService.create(dto);
  }

  @Put(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  update(@Param('id') id: string, @Body() dto: UpdateMarketDto) {
    return this.marketsService.update(id, dto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.SUPER_ADMIN)
  delete(@Param('id') id: string) {
    return this.marketsService.delete(id);
  }
}
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { MarketsService } from './markets.service';
import { MarketsController } from './markets.controller';
import { Market, MarketSchema } from './schemas/market.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: Market.name, schema: MarketSchema }]),
  ],
  controllers: [MarketsController],
  providers: [MarketsService],
  exports: [MarketsService],
})
export class MarketsModule {}
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Market } from './schemas/market.schema';
import { CreateMarketDto } from './dto/create-market.dto';
import { UpdateMarketDto } from './dto/update-market.dto';
import { FilterMarketDto } from './dto/filter-market.dto';

@Injectable()
export class MarketsService {
  constructor(@InjectModel(Market.name) private marketModel: Model<Market>) {}

  async create(dto: CreateMarketDto): Promise<Market> {
    const marketData: any = { ...dto };
    if (dto.coordinates) {
      marketData.location = {
        type: 'Point',
        coordinates: dto.coordinates,
      };
    }
    delete marketData.coordinates;
    return this.marketModel.create(marketData);
  }

  async findAll(filterDto: FilterMarketDto): Promise<{
    markets: Market[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const { page = 1, limit = 20, stateId, areaId, type, search, longitude, latitude, maxDistance } = filterDto;

    const query: Record<string, any> = { isActive: true };

    // ✅ Convert string IDs to ObjectId
    if (stateId) query.stateId = new Types.ObjectId(stateId);
    if (areaId) query.areaId = new Types.ObjectId(areaId);
    if (type) query.type = type;

    if (search) {
      query.$or = [
        { name: { $regex: search, $options: 'i' } },
        { address: { $regex: search, $options: 'i' } },
      ];
    }

    if (longitude && latitude) {
      query.location = {
        $near: {
          $geometry: {
            type: 'Point',
            coordinates: [longitude, latitude],
          },
          $maxDistance: (maxDistance || 10) * 1000,
        },
      };
    }

    const skip = (page - 1) * limit;
    const [markets, total] = await Promise.all([
      this.marketModel
        .find(query)
        .populate('stateId', 'name code')
        .populate('areaId', 'name')
        .skip(skip)
        .limit(limit)
        .sort({ createdAt: -1 }),
      this.marketModel.countDocuments(query),
    ]);

    return {
      markets,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async findById(id: string): Promise<Market> {
    const market = await this.marketModel
      .findById(id)
      .populate('stateId', 'name code')
      .populate('areaId', 'name localGovernment');
    if (!market) {
      throw new NotFoundException('Market not found');
    }
    return market;
  }

  async findByArea(areaId: string): Promise<Market[]> {
    // ✅ Convert string to ObjectId
    return this.marketModel
      .find({ areaId: new Types.ObjectId(areaId), isActive: true })
      .populate('stateId', 'name code')
      .populate('areaId', 'name')
      .sort({ name: 1 });
  }

  async findNearby(
    longitude: number,
    latitude: number,
    maxDistanceKm: number = 5,
  ): Promise<Market[]> {
    return this.marketModel.find({
      location: {
        $near: {
          $geometry: {
            type: 'Point',
            coordinates: [longitude, latitude],
          },
          $maxDistance: maxDistanceKm * 1000,
        },
      },
      isActive: true,
    })
    .populate('stateId', 'name code')
    .populate('areaId', 'name');
  }

  async update(id: string, dto: UpdateMarketDto): Promise<Market> {
    const updateData: any = { ...dto };
    if (dto.coordinates) {
      updateData.location = {
        type: 'Point',
        coordinates: dto.coordinates,
      };
    }
    delete updateData.coordinates;

    const market = await this.marketModel
      .findByIdAndUpdate(id, updateData, { new: true })
      .populate('stateId', 'name code')
      .populate('areaId', 'name');
    if (!market) {
      throw new NotFoundException('Market not found');
    }
    return market;
  }

  async incrementShopCount(id: string): Promise<void> {
    await this.marketModel.findByIdAndUpdate(id, { $inc: { totalShops: 1 } });
  }

  async decrementShopCount(id: string): Promise<void> {
    await this.marketModel.findByIdAndUpdate(id, { $inc: { totalShops: -1 } });
  }

  async delete(id: string): Promise<void> {
    const result = await this.marketModel.deleteOne({ _id: id });
    if (result.deletedCount === 0) {
      throw new NotFoundException('Market not found');
    }
  }
}
import {
  IsString,
  IsOptional,
  IsNumber,
  IsArray,
  IsEnum,
  IsObject,
  IsBoolean,
  Min,
} from 'class-validator';
import { ProductType } from '../../common/enums/product-status.enum';

export class CreateProductDto {
  @IsString()
  name: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsString()
  @IsOptional()
  sku?: string;

  @IsString()
  @IsOptional()
  barcode?: string;

  @IsString()
  @IsOptional()
  brand?: string;

  @IsEnum(ProductType)
  @IsOptional()
  type?: ProductType;

  @IsNumber()
  @Min(0)
  price: number;

  @IsNumber()
  @IsOptional()
  originalPrice?: number;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  images?: string[];

  @IsString()
  category: string;

  @IsString()
  @IsOptional()
  subcategory?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  tags?: string[];

  @IsNumber()
  @IsOptional()
  quantity?: number = 0;

  @IsString()
  @IsOptional()
  unit?: string;

  @IsObject()
  @IsOptional()
  specifications?: Record<string, any>;

  @IsBoolean()
  @IsOptional()
  inStock?: boolean = true;
}
import { IsOptional, IsString, IsEnum, IsNumber, IsMongoId, IsBoolean } from 'class-validator';
import { Type } from 'class-transformer';
import { ProductStatus, ProductType } from '../../common/enums/product-status.enum';

export class FilterProductDto {
  @IsOptional()
  @IsMongoId()
  vendorId?: string;

  @IsOptional()
  @IsString()
  category?: string;

  @IsOptional()
  @IsString()
  subcategory?: string;

  @IsOptional()
  @IsString()
  brand?: string;

  @IsOptional()
  @IsEnum(ProductType)
  type?: ProductType;

  @IsOptional()
  @IsEnum(ProductStatus)
  status?: ProductStatus;

  @IsOptional()
  @IsString()
  search?: string;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  minPrice?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  maxPrice?: number;

  // Location filters
  @IsOptional()
  @IsMongoId()
  stateId?: string;

  @IsOptional()
  @IsMongoId()
  areaId?: string;

  @IsOptional()
  @IsMongoId()
  marketId?: string;

  @IsOptional()
  @Type(() => Boolean)
  @IsBoolean()
  inStock?: boolean;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  limit?: number = 20;

  @IsOptional()
  @IsString()
  sortBy?: string = 'createdAt';

  @IsOptional()
  @IsString()
  sortOrder?: 'asc' | 'desc' = 'desc';
}
import {
  IsString,
  IsOptional,
  IsNumber,
  IsArray,
  IsEnum,
  IsObject,
  IsBoolean,
  Min,
} from 'class-validator';
import { ProductStatus, ProductType } from '../../common/enums/product-status.enum';

export class UpdateProductDto {
  @IsString()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsEnum(ProductType)
  @IsOptional()
  type?: ProductType;

  @IsNumber()
  @Min(0)
  @IsOptional()
  price?: number;

  @IsNumber()
  @IsOptional()
  originalPrice?: number;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  images?: string[];

  @IsString()
  @IsOptional()
  category?: string;

  @IsString()
  @IsOptional()
  subcategory?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  tags?: string[];

  @IsNumber()
  @IsOptional()
  quantity?: number;

  @IsString()
  @IsOptional()
  unit?: string;

  @IsObject()
  @IsOptional()
  specifications?: Record<string, any>;

  @IsEnum(ProductStatus)
  @IsOptional()
  status?: ProductStatus;

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;
}
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types, Schema as MongooseSchema } from 'mongoose';
import { ProductStatus, ProductType } from '../../common/enums/product-status.enum';

@Schema({ timestamps: true })
export class Product extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Vendor', required: true })
  vendorId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'CatalogItem' })
  catalogItemId?: Types.ObjectId;

  @Prop({ required: true })
  name: string;

  @Prop()
  description?: string;

  @Prop()
  sku?: string;

  @Prop()
  barcode?: string;

  @Prop()
  brand?: string;

  @Prop({ type: String, enum: ProductType, default: ProductType.SALE })
  type: ProductType;

  @Prop({ required: true })
  price: number;

  @Prop()
  originalPrice?: number;

  @Prop({ default: 'NGN' })
  currency: string;

  @Prop([String])
  images?: string[];

  @Prop({ required: true })
  category: string;

  @Prop()
  subcategory?: string;

  @Prop([String])
  tags?: string[];

  @Prop({ default: 0 })
  quantity: number;

  @Prop()
  unit?: string;

  @Prop({ type: Object })
  specifications?: Record<string, any>;

  @Prop({ type: String, enum: ProductStatus, default: ProductStatus.APPROVED })
  status: ProductStatus;

  @Prop({ default: 0 })
  views: number;

  @Prop({ default: 0 })
  searchAppearances: number;

  @Prop({ default: true })
  isActive: boolean;

  @Prop({ default: true })
  inStock: boolean;

  @Prop()
  lastRestocked?: Date;

  // Denormalized location data for faster searches
  @Prop({ type: Types.ObjectId, ref: 'State' })
  stateId?: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Area' })
  areaId?: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Market' })
  marketId?: Types.ObjectId;

  // ✅ Geolocation — use Object type, define properly after schema creation
  @Prop({ type: Object })
  location?: {
    type: 'Point';
    coordinates: [number, number];
  };

  createdAt: Date;
  updatedAt: Date;
}

export const ProductSchema = SchemaFactory.createForClass(Product);

// ✅ Define location path AFTER schema creation
// This prevents auto-defaulting { type: "Point" } when no coordinates exist
ProductSchema.path('location', new MongooseSchema(
  {
    type: {
      type: String,
      enum: ['Point'],
      required: true,
    },
    coordinates: {
      type: [Number],
      required: true,
    },
  },
  { _id: false }
));

// ✅ Location is NOT required at document level
ProductSchema.path('location').required(false);

// ✅ sparse: true — skips documents where location is absent
ProductSchema.index({ location: '2dsphere' }, { sparse: true });
ProductSchema.index({ vendorId: 1 });
ProductSchema.index({ catalogItemId: 1 });
ProductSchema.index({ category: 1, subcategory: 1 });
ProductSchema.index({ status: 1, isActive: 1 });
ProductSchema.index({ stateId: 1, areaId: 1, marketId: 1 });
ProductSchema.index({ name: 'text', description: 'text', brand: 'text', tags: 'text' });
ProductSchema.index({ price: 1 });
ProductSchema.index({ sku: 1 });
ProductSchema.index({ barcode: 1 });
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  UseGuards,
  Request,
} from '@nestjs/common';
import { ProductsService } from './products.service';
import { CreateProductDto } from './dto/create-product.dto';
import { UpdateProductDto } from './dto/update-product.dto';
import { FilterProductDto } from './dto/filter-product.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { Role } from '../common/enums/role.enum';

@Controller('products')
export class ProductsController {
  constructor(private productsService: ProductsService) {}

  @Get()
  findAll(@Query() filterDto: FilterProductDto) {
    return this.productsService.findAll(filterDto);
  }

  @Get('my-products')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.VENDOR)
  getMyProducts(@Request() req) {
    return this.productsService.getMyProducts(req.user.id);
  }

  @Get('vendor/:vendorId')
  findByVendor(@Param('vendorId') vendorId: string) {
    return this.productsService.findByVendor(vendorId);
  }

  @Get('nearby')
  findNearby(
    @Query('longitude') longitude: number,
    @Query('latitude') latitude: number,
    @Query('distance') distance?: number,
    @Query('category') category?: string,
  ) {
    return this.productsService.findNearby(longitude, latitude, distance, category);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.productsService.findById(id);
  }

  @Post()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.VENDOR)
  create(@Body() dto: CreateProductDto, @Request() req) {
    return this.productsService.create(dto, req.user.id);
  }

  @Put(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.VENDOR)
  update(@Param('id') id: string, @Body() dto: UpdateProductDto, @Request() req) {
    return this.productsService.update(id, dto, req.user.id);
  }

  @Put(':id/admin')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  adminUpdate(@Param('id') id: string, @Body() dto: UpdateProductDto) {
    return this.productsService.adminUpdate(id, dto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.VENDOR)
  delete(@Param('id') id: string, @Request() req) {
    return this.productsService.delete(id, req.user.id);
  }
}
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ProductsService } from './products.service';
import { ProductsController } from './products.controller';
import { Product, ProductSchema } from './schemas/product.schema';
import { VendorsModule } from '../vendors/vendors.module';
import { CatalogModule } from '../catalog/catalog.module';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: Product.name, schema: ProductSchema }]),
    VendorsModule,
    CatalogModule,
  ],
  controllers: [ProductsController],
  providers: [ProductsService],
  exports: [ProductsService],
})
export class ProductsModule {}
import { Injectable, NotFoundException, ForbiddenException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Product } from './schemas/product.schema';
import { CreateProductDto } from './dto/create-product.dto';
import { UpdateProductDto } from './dto/update-product.dto';
import { FilterProductDto } from './dto/filter-product.dto';
import { VendorsService } from '../vendors/vendors.service';
import { CatalogService } from '../catalog/catalog.service';
import { ProductStatus } from '../common/enums/product-status.enum';

// ✅ Helper to validate location object
function isValidLocation(location: any): boolean {
  return (
    location &&
    location.type === 'Point' &&
    Array.isArray(location.coordinates) &&
    location.coordinates.length === 2 &&
    typeof location.coordinates[0] === 'number' &&
    typeof location.coordinates[1] === 'number'
  );
}

@Injectable()
export class ProductsService {
  constructor(
    @InjectModel(Product.name) private productModel: Model<Product>,
    private vendorsService: VendorsService,
    private catalogService: CatalogService,
  ) {}

  async create(dto: CreateProductDto, userId: string): Promise<Product> {
    // Get vendor by user
    const vendor = await this.vendorsService.findByUser(userId);

    // Try to match with catalog item
    let catalogItemId: Types.ObjectId | undefined;
    if (dto.sku) {
      const catalogItem = await this.catalogService.findBySku(dto.sku);
      if (catalogItem) catalogItemId = catalogItem._id as Types.ObjectId;
    } else if (dto.barcode) {
      const catalogItem = await this.catalogService.findByBarcode(dto.barcode);
      if (catalogItem) catalogItemId = catalogItem._id as Types.ObjectId;
    }

    // Build create data
    const createData: Record<string, any> = {
      ...dto,
      vendorId: vendor._id,
      stateId: vendor.stateId,
      areaId: vendor.areaId,
      marketId: vendor.marketId,
      status: ProductStatus.APPROVED,
    };

    // ✅ Only copy location if vendor has valid coordinates
    if (isValidLocation(vendor.location)) {
      createData.location = {
        type: 'Point',
        coordinates: vendor.location!.coordinates,
      };
    }
    // ✅ Do NOT set location at all if vendor doesn't have valid coordinates

    // Add catalog item ID if matched
    if (catalogItemId) {
      createData.catalogItemId = catalogItemId;
    }

    const product = await this.productModel.create(createData);

    // Increment vendor product count and update price range
    await this.vendorsService.incrementProductCount(vendor._id.toString());
    await this.updateVendorPriceRange(vendor._id.toString());

    // Update catalog price stats if linked
    if (catalogItemId) {
      await this.updateCatalogPriceStats(catalogItemId.toString());
    }

    return product;
  }

  async findAll(filterDto: FilterProductDto): Promise<{
    products: Product[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const {
      page = 1,
      limit = 20,
      vendorId,
      category,
      subcategory,
      type,
      status,
      search,
      minPrice,
      maxPrice,
      stateId,
      areaId,
      marketId,
      inStock,
      sortBy = 'createdAt',
      sortOrder = 'desc',
    } = filterDto;

    const query: Record<string, any> = { isActive: true };

    // ✅ Convert all ref IDs to ObjectId
    if (vendorId) query.vendorId = new Types.ObjectId(vendorId);
    if (stateId) query.stateId = new Types.ObjectId(stateId);
    if (areaId) query.areaId = new Types.ObjectId(areaId);
    if (marketId) query.marketId = new Types.ObjectId(marketId);
    if (category) query.category = category;
    if (subcategory) query.subcategory = subcategory;
    if (type) query.type = type;
    if (status) query.status = status;
    else query.status = ProductStatus.APPROVED;
    if (inStock !== undefined) query.inStock = inStock;

    if (search) {
      query.$or = [
        { name: { $regex: search, $options: 'i' } },
        { description: { $regex: search, $options: 'i' } },
        { brand: { $regex: search, $options: 'i' } },
        { tags: { $in: [new RegExp(search, 'i')] } },
      ];
    }

    if (minPrice !== undefined || maxPrice !== undefined) {
      query.price = {};
      if (minPrice !== undefined) query.price.$gte = minPrice;
      if (maxPrice !== undefined) query.price.$lte = maxPrice;
    }

    const skip = (page - 1) * limit;
    const sortOptions: Record<string, 1 | -1> = {};
    sortOptions[sortBy] = sortOrder === 'asc' ? 1 : -1;

    const [products, total] = await Promise.all([
      this.productModel
        .find(query)
        .populate({
          path: 'vendorId',
          select: 'businessName shopImages contactDetails bankDetails stateId areaId marketId shopNumber rating isVerified',
          populate: [
            { path: 'stateId', select: 'name' },
            { path: 'areaId', select: 'name' },
            { path: 'marketId', select: 'name type' },
          ],
        })
        .skip(skip)
        .limit(limit)
        .sort(sortOptions),
      this.productModel.countDocuments(query),
    ]);

    return {
      products,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async findById(id: string): Promise<Product> {
    const product = await this.productModel
      .findById(id)
      .populate({
        path: 'vendorId',
        select: 'businessName businessDescription shopImages contactDetails bankDetails stateId areaId marketId shopNumber shopFloor shopBlock shopAddress landmark rating isVerified operatingHours isOpen',
        populate: [
          { path: 'stateId', select: 'name code' },
          { path: 'areaId', select: 'name' },
          { path: 'marketId', select: 'name type address entrancePhoto layoutMap' },
        ],
      });

    if (!product) {
      throw new NotFoundException('Product not found');
    }

    // Increment view count
    await this.productModel.findByIdAndUpdate(id, { $inc: { views: 1 } });

    return product;
  }

  async findByVendor(vendorId: string): Promise<Product[]> {
    return this.productModel
      .find({ vendorId: new Types.ObjectId(vendorId), isActive: true })
      .sort({ createdAt: -1 });
  }

  async getMyProducts(userId: string): Promise<Product[]> {
    const vendor = await this.vendorsService.findByUser(userId);
    return this.productModel
      .find({ vendorId: vendor._id })
      .sort({ createdAt: -1 });
  }

  async findNearby(
    longitude: number,
    latitude: number,
    maxDistanceKm: number = 5,
    category?: string,
  ): Promise<Product[]> {
    const query: Record<string, any> = {
      location: {
        $near: {
          $geometry: {
            type: 'Point',
            coordinates: [longitude, latitude],
          },
          $maxDistance: maxDistanceKm * 1000,
        },
      },
      isActive: true,
      status: ProductStatus.APPROVED,
    };

    if (category) query.category = category;

    return this.productModel
      .find(query)
      .populate({
        path: 'vendorId',
        select: 'businessName shopImages contactDetails rating isVerified shopNumber',
      })
      .limit(50);
  }

  async update(id: string, dto: UpdateProductDto, userId: string): Promise<Product> {
    const product = await this.productModel.findById(id);
    if (!product) {
      throw new NotFoundException('Product not found');
    }

    // Verify ownership
    const vendor = await this.vendorsService.findByUser(userId);
    if (product.vendorId.toString() !== vendor._id.toString()) {
      throw new ForbiddenException('You can only update your own products');
    }

    const updatedProduct = await this.productModel.findByIdAndUpdate(
      id,
      dto,
      { new: true },
    );

    if (!updatedProduct) {
      throw new NotFoundException('Product not found');
    }

    // Update vendor price range if price changed
    if (dto.price !== undefined) {
      await this.updateVendorPriceRange(vendor._id.toString());
    }

    // Update catalog price stats if linked
    if (product.catalogItemId) {
      await this.updateCatalogPriceStats(product.catalogItemId.toString());
    }

    return updatedProduct;
  }

  async adminUpdate(id: string, dto: UpdateProductDto): Promise<Product> {
    const product = await this.productModel.findByIdAndUpdate(
      id,
      dto,
      { new: true },
    );

    if (!product) {
      throw new NotFoundException('Product not found');
    }

    return product;
  }

  async delete(id: string, userId: string): Promise<void> {
    const product = await this.productModel.findById(id);
    if (!product) {
      throw new NotFoundException('Product not found');
    }

    // Verify ownership
    const vendor = await this.vendorsService.findByUser(userId);
    if (product.vendorId.toString() !== vendor._id.toString()) {
      throw new ForbiddenException('You can only delete your own products');
    }

    await this.productModel.deleteOne({ _id: id });

    // Decrement vendor product count
    await this.vendorsService.decrementProductCount(vendor._id.toString());
    await this.updateVendorPriceRange(vendor._id.toString());

    // Update catalog price stats if linked
    if (product.catalogItemId) {
      await this.updateCatalogPriceStats(product.catalogItemId.toString());
    }
  }

  private async updateVendorPriceRange(vendorId: string): Promise<void> {
    const priceStats = await this.productModel.aggregate([
      {
        $match: {
          vendorId: new Types.ObjectId(vendorId),
          isActive: true,
          status: ProductStatus.APPROVED,
        },
      },
      {
        $group: {
          _id: null,
          minPrice: { $min: '$price' },
          maxPrice: { $max: '$price' },
        },
      },
    ]);

    if (priceStats.length > 0) {
      await this.vendorsService.updatePriceRange(
        vendorId,
        priceStats[0].minPrice,
        priceStats[0].maxPrice,
      );
    }
  }

  private async updateCatalogPriceStats(catalogItemId: string): Promise<void> {
    const prices = await this.productModel
      .find({
        catalogItemId: new Types.ObjectId(catalogItemId),
        isActive: true,
        status: ProductStatus.APPROVED,
      })
      .select('price');

    const priceValues = prices.map((p) => p.price);
    await this.catalogService.updatePriceStats(catalogItemId, priceValues);
  }
}
import { IsString, IsNumber, IsOptional, IsEnum, IsMongoId, Min, Max, IsArray } from 'class-validator';
import { ReviewType } from '../schemas/review.schema';

export class CreateReviewDto {
  @IsEnum(ReviewType)
  type: ReviewType;

  @IsMongoId()
  @IsOptional()
  productId?: string;

  @IsMongoId()
  @IsOptional()
  vendorId?: string;

  @IsNumber()
  @Min(1)
  @Max(5)
  rating: number;

  @IsString()
  @IsOptional()
  title?: string;

  @IsString()
  @IsOptional()
  comment?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  images?: string[];
}
import { IsString, IsNumber, IsOptional, Min, Max, IsArray, IsBoolean } from 'class-validator';

export class UpdateReviewDto {
  @IsNumber()
  @Min(1)
  @Max(5)
  @IsOptional()
  rating?: number;

  @IsString()
  @IsOptional()
  title?: string;

  @IsString()
  @IsOptional()
  comment?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  images?: string[];

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;
}
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

export enum ReviewType {
  PRODUCT = 'product',
  VENDOR = 'vendor',
}

@Schema({ timestamps: true })
export class Review extends Document {
  @Prop({ type: Types.ObjectId, ref: 'User', required: true })
  userId: Types.ObjectId;

  @Prop({ type: String, enum: ReviewType, required: true })
  type: ReviewType;

  @Prop({ type: Types.ObjectId, ref: 'Product' })
  productId?: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Vendor' })
  vendorId?: Types.ObjectId;

  @Prop({ required: true, min: 1, max: 5 })
  rating: number;

  @Prop()
  title?: string;

  @Prop()
  comment?: string;

  @Prop([String])
  images?: string[];

  @Prop({ default: 0 })
  helpfulCount: number;

  @Prop({ default: true })
  isVerified: boolean;

  @Prop({ default: true })
  isActive: boolean;
}

export const ReviewSchema = SchemaFactory.createForClass(Review);

ReviewSchema.index({ productId: 1, userId: 1 }, { unique: true, sparse: true });
ReviewSchema.index({ vendorId: 1, userId: 1 }, { unique: true, sparse: true });
ReviewSchema.index({ type: 1, productId: 1 });
ReviewSchema.index({ type: 1, vendorId: 1 });
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  UseGuards,
  Request,
} from '@nestjs/common';
import { ReviewsService } from './reviews.service';
import { CreateReviewDto } from './dto/create-review.dto';
import { UpdateReviewDto } from './dto/update-review.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';

@Controller('reviews')
export class ReviewsController {
  constructor(private reviewsService: ReviewsService) {}

  @Get('product/:productId')
  getProductReviews(
    @Param('productId') productId: string,
    @Query('page') page?: number,
    @Query('limit') limit?: number,
  ) {
    return this.reviewsService.findByProduct(productId, page, limit);
  }

  @Get('vendor/:vendorId')
  getVendorReviews(
    @Param('vendorId') vendorId: string,
    @Query('page') page?: number,
    @Query('limit') limit?: number,
  ) {
    return this.reviewsService.findByVendor(vendorId, page, limit);
  }

  @Get('my-reviews')
  @UseGuards(JwtAuthGuard)
  getMyReviews(@Request() req) {
    return this.reviewsService.findByUser(req.user.id);
  }

  @Post()
  @UseGuards(JwtAuthGuard)
  create(@Request() req, @Body() dto: CreateReviewDto) {
    return this.reviewsService.create(req.user.id, dto);
  }

  @Put(':id')
  @UseGuards(JwtAuthGuard)
  update(
    @Param('id') id: string,
    @Request() req,
    @Body() dto: UpdateReviewDto,
  ) {
    return this.reviewsService.update(id, req.user.id, dto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard)
  delete(@Param('id') id: string, @Request() req) {
    return this.reviewsService.delete(id, req.user.id);
  }

  @Post(':id/helpful')
  markHelpful(@Param('id') id: string) {
    return this.reviewsService.markHelpful(id);
  }
}
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ReviewsController } from './reviews.controller';
import { ReviewsService } from './reviews.service';
import { Review, ReviewSchema } from './schemas/review.schema';
import { Vendor, VendorSchema } from '../vendors/schemas/vendor.schema';
import { Product, ProductSchema } from '../products/schemas/product.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: Review.name, schema: ReviewSchema },
      { name: Vendor.name, schema: VendorSchema },
      { name: Product.name, schema: ProductSchema },
    ]),
  ],
  controllers: [ReviewsController],
  providers: [ReviewsService],
  exports: [ReviewsService],
})
export class ReviewsModule {}
import {
  Injectable,
  NotFoundException,
  ConflictException,
  ForbiddenException,
} from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Review, ReviewType } from './schemas/review.schema';
import { Vendor } from '../vendors/schemas/vendor.schema';
import { Product } from '../products/schemas/product.schema';
import { CreateReviewDto } from './dto/create-review.dto';
import { UpdateReviewDto } from './dto/update-review.dto';

@Injectable()
export class ReviewsService {
  constructor(
    @InjectModel(Review.name) private reviewModel: Model<Review>,
    @InjectModel(Vendor.name) private vendorModel: Model<Vendor>,
    @InjectModel(Product.name) private productModel: Model<Product>,
  ) {}

  async create(userId: string, dto: CreateReviewDto): Promise<Review> {
    // Check for existing review
    const existingQuery: any = { userId, type: dto.type };
    if (dto.type === ReviewType.PRODUCT) {
      existingQuery.productId = dto.productId;
    } else {
      existingQuery.vendorId = dto.vendorId;
    }

    const existing = await this.reviewModel.findOne(existingQuery);
    if (existing) {
      throw new ConflictException('You have already reviewed this item');
    }

    const review = await this.reviewModel.create({
      userId,
      ...dto,
    });

    // ✅ FIX 1: Extract itemId with a fallback, assert it's defined
    const itemId = dto.productId ?? dto.vendorId;
    if (!itemId) {
      throw new NotFoundException('Product or Vendor ID is required');
    }
    await this.updateItemRating(dto.type, itemId);

    return review;
  }

  async findByProduct(
    productId: string,
    page: number = 1,
    limit: number = 10,
  ): Promise<{
    reviews: Review[];
    total: number;
    averageRating: number;
    ratingDistribution: { [key: number]: number };
  }> {
    const skip = (page - 1) * limit;

    const [reviews, total, ratingAgg] = await Promise.all([
      this.reviewModel
        .find({ productId, isActive: true })
        .populate('userId', 'firstName lastName avatar')
        .skip(skip)
        .limit(limit)
        .sort({ createdAt: -1 }),
      this.reviewModel.countDocuments({ productId, isActive: true }),
      this.reviewModel.aggregate([
        { $match: { productId, isActive: true } },
        {
          $group: {
            _id: null,
            averageRating: { $avg: '$rating' },
            ratings: { $push: '$rating' },
          },
        },
      ]),
    ]);

    const ratingDistribution: { [key: number]: number } = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
    if (ratingAgg.length > 0 && ratingAgg[0].ratings) {
      ratingAgg[0].ratings.forEach((r: number) => {
        ratingDistribution[r]++;
      });
    }

    return {
      reviews,
      total,
      averageRating: ratingAgg[0]?.averageRating || 0,
      ratingDistribution,
    };
  }

  async findByVendor(
    vendorId: string,
    page: number = 1,
    limit: number = 10,
  ): Promise<{
    reviews: Review[];
    total: number;
    averageRating: number;
    ratingDistribution: { [key: number]: number };
  }> {
    const skip = (page - 1) * limit;

    const [reviews, total, ratingAgg] = await Promise.all([
      this.reviewModel
        .find({ vendorId, isActive: true })
        .populate('userId', 'firstName lastName avatar')
        .skip(skip)
        .limit(limit)
        .sort({ createdAt: -1 }),
      this.reviewModel.countDocuments({ vendorId, isActive: true }),
      this.reviewModel.aggregate([
        { $match: { vendorId, isActive: true } },
        {
          $group: {
            _id: null,
            averageRating: { $avg: '$rating' },
            ratings: { $push: '$rating' },
          },
        },
      ]),
    ]);

    const ratingDistribution: { [key: number]: number } = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
    if (ratingAgg.length > 0 && ratingAgg[0].ratings) {
      ratingAgg[0].ratings.forEach((r: number) => {
        ratingDistribution[r]++;
      });
    }

    return {
      reviews,
      total,
      averageRating: ratingAgg[0]?.averageRating || 0,
      ratingDistribution,
    };
  }

  async findByUser(userId: string): Promise<Review[]> {
    return this.reviewModel
      .find({ userId })
      .populate('productId', 'name images')
      .populate('vendorId', 'businessName shopImages')
      .sort({ createdAt: -1 });
  }

  async update(id: string, userId: string, dto: UpdateReviewDto): Promise<Review> {
    const review = await this.reviewModel.findById(id);
    if (!review) {
      throw new NotFoundException('Review not found');
    }

    if (review.userId.toString() !== userId) {
      throw new ForbiddenException('You can only update your own reviews');
    }

    // ✅ FIX 2: Handle null return from findByIdAndUpdate
    const updated = await this.reviewModel.findByIdAndUpdate(id, dto, { new: true });
    if (!updated) {
      throw new NotFoundException('Review not found after update');
    }

    // Update rating if rating changed
    if (dto.rating !== undefined) {
      // ✅ FIX 3: Guard against undefined itemId
      const itemId = review.productId?.toString() ?? review.vendorId?.toString();
      if (itemId) {
        await this.updateItemRating(review.type, itemId);
      }
    }

    return updated;
  }

  async delete(id: string, userId: string): Promise<void> {
    const review = await this.reviewModel.findById(id);
    if (!review) {
      throw new NotFoundException('Review not found');
    }

    if (review.userId.toString() !== userId) {
      throw new ForbiddenException('You can only delete your own reviews');
    }

    await this.reviewModel.deleteOne({ _id: id });

    // ✅ FIX 4: Guard against undefined itemId
    const itemId = review.productId?.toString() ?? review.vendorId?.toString();
    if (itemId) {
      await this.updateItemRating(review.type, itemId);
    }
  }

  async markHelpful(id: string): Promise<Review> {
    // ✅ FIX 5: Handle null return from findByIdAndUpdate
    const review = await this.reviewModel.findByIdAndUpdate(
      id,
      { $inc: { helpfulCount: 1 } },
      { new: true },
    );
    if (!review) {
      throw new NotFoundException('Review not found');
    }
    return review;
  }

  private async updateItemRating(type: ReviewType, itemId: string): Promise<void> {
    const query =
      type === ReviewType.PRODUCT
        ? { productId: itemId, isActive: true }
        : { vendorId: itemId, isActive: true };

    const result = await this.reviewModel.aggregate([
      { $match: query },
      {
        $group: {
          _id: null,
          averageRating: { $avg: '$rating' },
          count: { $sum: 1 },
        },
      },
    ]);

    const rating = result[0]?.averageRating || 0;
    const count = result[0]?.count || 0;

    if (type === ReviewType.VENDOR) {
      await this.vendorModel.findByIdAndUpdate(itemId, {
        rating: Math.round(rating * 10) / 10,
        reviewCount: count,
      });
    }
  }
}
export interface ProductSearchResult {
  id: string;
  name: string;
  description?: string;
  brand?: string;
  category: string;
  subcategory?: string;
  images: string[];
  
  // Price info from this specific vendor
  price: number;
  originalPrice?: number;
  currency: string;
  inStock: boolean;
  
  // Vendor info
  vendor: {
    id: string;
    businessName: string;
    logo?: string;
    rating: number;
    isVerified: boolean;
    contactDetails: {
      phone: string;
      whatsapp?: string;
    };
  };
  
  // Location info
  location: {
    state: { id: string; name: string };
    area: { id: string; name: string };
    market?: { id: string; name: string; type: string };
    shopNumber?: string;
    shopAddress?: string;
    coordinates?: [number, number];
    distance?: number; // in km, if geo search
  };
}

export interface ProductWithVendors {
  // Product master info
  id: string;
  catalogItemId?: string;
  name: string;
  description?: string;
  brand?: string;
  category: string;
  subcategory?: string;
  images: string[];
  
  // Price summary
  priceRange: {
    lowest: number;
    highest: number;
    average: number;
    currency: string;
  };
  
  // All vendors selling this product
  totalVendors: number;
  vendors: VendorListing[];
}

export interface VendorListing {
  vendorId: string;
  productId: string;
  businessName: string;
  logo?: string;
  entrancePhoto?: string;
  rating: number;
  isVerified: boolean;
  
  // This vendor's price
  price: number;
  originalPrice?: number;
  inStock: boolean;
  quantity: number;
  
  // Contact
  contactDetails: {
    phone: string;
    whatsapp?: string;
    email?: string;
  };
  
  // Banking (for external transactions)
  bankDetails?: {
    bankName: string;
    accountName: string;
    accountNumber: string;
  };
  
  // Location
  location: {
    state: { id: string; name: string };
    area: { id: string; name: string };
    market?: { id: string; name: string; type: string };
    shopNumber?: string;
    shopFloor?: string;
    shopBlock?: string;
    shopAddress?: string;
    landmark?: string;
    coordinates?: [number, number];
    distance?: number;
  };
  
  // Operating hours
  operatingHours?: {
    openingTime?: string;
    closingTime?: string;
    operatingDays?: string[];
    isOpen: boolean;
  };
}

export interface ShopSearchResult {
  id: string;
  businessName: string;
  businessDescription?: string;
  vendorType: string;
  
  // Images
  logo?: string;
  entrancePhoto?: string;
  layoutMap?: string;
  
  // Stats
  rating: number;
  reviewCount: number;
  totalProducts: number;
  isVerified: boolean;
  isFeatured: boolean;
  
  // Categories
  categories: string[];
  
  // Price Range
  priceRange: {
    min: number;
    max: number;
  };
  
  // Contact
  contactDetails: {
    phone: string;
    whatsapp?: string;
    email?: string;
    instagram?: string;
  };
  
  // Banking
  bankDetails?: {
    bankName: string;
    accountName: string;
    accountNumber: string;
  };
  
  // Location
  location: {
    state: { id: string; name: string };
    area: { id: string; name: string };
    market?: { id: string; name: string; type: string };
    shopNumber?: string;
    shopFloor?: string;
    shopBlock?: string;
    shopAddress?: string;
    landmark?: string;
    coordinates?: [number, number];
    distance?: number;
  };
  
  // Operating
  operatingHours?: {
    openingTime?: string;
    closingTime?: string;
    operatingDays?: string[];
    isOpen: boolean;
  };
  
  // Sample products
  featuredProducts?: {
    id: string;
    name: string;
    price: number;
    image?: string;
  }[];
}

export interface SearchResults {
  query: string | undefined; 
  searchType: string;
  
  products?: {
    items: ProductSearchResult[];
    total: number;
    page: number;
    totalPages: number;
  };
  
  shops?: {
    items: ShopSearchResult[];
    total: number;
    page: number;
    totalPages: number;
  };
  
  // Aggregated product with all vendors
  productComparison?: {
    items: ProductWithVendors[];
    total: number;
  };
  
  // Filters available based on results
  availableFilters: {
    states: { id: string; name: string; count: number }[];
    areas: { id: string; name: string; count: number }[];
    markets: { id: string; name: string; count: number }[];
    categories: { name: string; count: number }[];
    brands: { name: string; count: number }[];
    priceRange: { min: number; max: number };
  };
  
  meta: {
    timestamp: string;
    took: number; // ms
  };
}
import {
  IsOptional,
  IsString,
  IsEnum,
  IsNumber,
  IsMongoId,
  IsBoolean,
  IsArray,
} from 'class-validator';
import { Type } from 'class-transformer';

export enum SearchType {
  PRODUCTS = 'products',
  SHOPS = 'shops',
  ALL = 'all',
}

export enum SortBy {
  RELEVANCE = 'relevance',
  PRICE_LOW = 'price_low',
  PRICE_HIGH = 'price_high',
  RATING = 'rating',
  NEWEST = 'newest',
  DISTANCE = 'distance',
  POPULARITY = 'popularity',
}

export class SearchDto {
  @IsOptional()
  @IsString()
  query?: string;

  @IsOptional()
  @IsEnum(SearchType)
  searchType?: SearchType = SearchType.ALL;

  // Location Filters
  @IsOptional()
  @IsMongoId()
  stateId?: string;

  @IsOptional()
  @IsMongoId()
  areaId?: string;

  @IsOptional()
  @IsMongoId()
  marketId?: string;

  // Geolocation
  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  longitude?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  latitude?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  maxDistance?: number = 10;

  // Category Filters
  @IsOptional()
  @IsString()
  category?: string;

  @IsOptional()
  @IsString()
  subcategory?: string;

  @IsOptional()
  @IsString()
  brand?: string;

  // Price Filters
  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  minPrice?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  maxPrice?: number;

  // Other Filters
  @IsOptional()
  @Type(() => Boolean)
  @IsBoolean()
  inStock?: boolean;

  @IsOptional()
  @Type(() => Boolean)
  @IsBoolean()
  verifiedOnly?: boolean;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  // Sorting
  @IsOptional()
  @IsEnum(SortBy)
  sortBy?: SortBy = SortBy.RELEVANCE;

  // Pagination
  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  limit?: number = 20;
}

export class ProductSearchDto extends SearchDto {
  @IsOptional()
  @IsString()
  sku?: string;

  @IsOptional()
  @IsString()
  barcode?: string;
}

export class ShopSearchDto extends SearchDto {
  @IsOptional()
  @IsEnum([
    'market_shop',
    'mall_shop',
    'home_based',
    'street_shop',
    'online_only',
  ])
  vendorType?: string;

  @IsOptional()
  @Type(() => Boolean)
  @IsBoolean()
  isOpen?: boolean;
}
import {
  Controller,
  Get,
  Query,
  Param,
  InternalServerErrorException,
} from '@nestjs/common';
import { SearchService } from './search.service';
import {
  SearchDto,
  ProductSearchDto,
  ShopSearchDto,
} from './dto/search.dto';

@Controller('search')
export class SearchController {
  constructor(private searchService: SearchService) {}

  // Main search endpoint - searches both products and shops
  @Get()
  async search(@Query() dto: SearchDto) {
    try {
      return await this.searchService.search(dto);
    } catch (error) {
      console.error('Search controller error:', error.message, error.stack);
      throw new InternalServerErrorException(
        `Search failed: ${error.message}`,
      );
    }
  }

  // Search products only
  @Get('products')
  async searchProducts(@Query() dto: ProductSearchDto) {
    try {
      dto.searchType = 'products' as any;
      return await this.searchService.searchProducts(dto);
    } catch (error) {
      console.error(
        'Product search controller error:',
        error.message,
        error.stack,
      );
      throw new InternalServerErrorException(
        `Product search failed: ${error.message}`,
      );
    }
  }

  // Search shops only
  @Get('shops')
  async searchShops(@Query() dto: ShopSearchDto) {
    try {
      return await this.searchService.searchShops(dto);
    } catch (error) {
      console.error(
        'Shop search controller error:',
        error.message,
        error.stack,
      );
      throw new InternalServerErrorException(
        `Shop search failed: ${error.message}`,
      );
    }
  }

  // Get all vendors selling a specific product with price comparison
  @Get('product/:productName/vendors')
  async getProductVendors(
    @Param('productName') productName: string,
    @Query() filters: SearchDto,
  ) {
    try {
      return await this.searchService.getProductVendors(
        productName,
        filters,
      );
    } catch (error) {
      console.error(
        'Product vendors controller error:',
        error.message,
        error.stack,
      );
      throw new InternalServerErrorException(
        `Product vendors search failed: ${error.message}`,
      );
    }
  }

  // Get product comparison across vendors
  @Get('compare')
  async getProductComparison(@Query() dto: SearchDto) {
    try {
      return await this.searchService.getProductComparison(dto);
    } catch (error) {
      console.error(
        'Product comparison controller error:',
        error.message,
        error.stack,
      );
      throw new InternalServerErrorException(
        `Product comparison failed: ${error.message}`,
      );
    }
  }

  // Get a shop's products
  @Get('shop/:vendorId/products')
  async getShopProducts(
    @Param('vendorId') vendorId: string,
    @Query('category') category?: string,
    @Query('minPrice') minPrice?: number,
    @Query('maxPrice') maxPrice?: number,
    @Query('page') page?: number,
    @Query('limit') limit?: number,
  ) {
    try {
      return await this.searchService.getShopProducts(vendorId, {
        category,
        minPrice,
        maxPrice,
        page,
        limit,
      });
    } catch (error) {
      console.error(
        'Shop products controller error:',
        error.message,
        error.stack,
      );
      throw new InternalServerErrorException(
        `Shop products search failed: ${error.message}`,
      );
    }
  }

  // Get similar products
  @Get('product/:productId/similar')
  async getSimilarProducts(
    @Param('productId') productId: string,
    @Query('limit') limit?: number,
  ) {
    try {
      return await this.searchService.getSimilarProducts(productId, limit);
    } catch (error) {
      console.error(
        'Similar products controller error:',
        error.message,
        error.stack,
      );
      throw new InternalServerErrorException(
        `Similar products search failed: ${error.message}`,
      );
    }
  }

  // Get available filters for current search
  @Get('filters')
  async getFilters(@Query() dto: SearchDto) {
    try {
      return await this.searchService.getAvailableFilters(dto);
    } catch (error) {
      console.error(
        'Filters controller error:',
        error.message,
        error.stack,
      );
      throw new InternalServerErrorException(
        `Filters retrieval failed: ${error.message}`,
      );
    }
  }
}
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { SearchController } from './search.controller';
import { SearchService } from './search.service';
import { Product, ProductSchema } from '../products/schemas/product.schema';
import { Vendor, VendorSchema } from '../vendors/schemas/vendor.schema';
import { CatalogItem, CatalogItemSchema } from '../catalog/schemas/catalog-item.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: Product.name, schema: ProductSchema },
      { name: Vendor.name, schema: VendorSchema },
      { name: CatalogItem.name, schema: CatalogItemSchema },
    ]),
  ],
  controllers: [SearchController],
  providers: [SearchService],
  exports: [SearchService],
})
export class SearchModule {}
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, PipelineStage, Types } from 'mongoose';
import { Product } from '../products/schemas/product.schema';
import { Vendor } from '../vendors/schemas/vendor.schema';
import { CatalogItem } from '../catalog/schemas/catalog-item.schema';
import {
  SearchDto,
  ProductSearchDto,
  ShopSearchDto,
  SearchType,
  SortBy,
} from './dto/search.dto';
import {
  SearchResults,
  ProductSearchResult,
  ShopSearchResult,
  ProductWithVendors,
  VendorListing,
} from './dto/search-result.dto';
import { ProductStatus } from '../common/enums/product-status.enum';

@Injectable()
export class SearchService {
  constructor(
    @InjectModel(Product.name) private productModel: Model<Product>,
    @InjectModel(Vendor.name) private vendorModel: Model<Vendor>,
    @InjectModel(CatalogItem.name) private catalogModel: Model<CatalogItem>,
  ) {}

  async search(dto: SearchDto): Promise<SearchResults> {
    const startTime = Date.now();

    const searchType = dto.searchType || SearchType.ALL;

    const results: SearchResults = {
      query: dto.query,
      searchType: searchType.toString(),
      availableFilters: {
        states: [],
        areas: [],
        markets: [],
        categories: [],
        brands: [],
        priceRange: { min: 0, max: 0 },
      },
      meta: {
        timestamp: new Date().toISOString(),
        took: 0,
      },
    };

    try {
      switch (searchType) {
        case SearchType.PRODUCTS:
          results.products = await this.searchProducts(dto);
          results.productComparison = await this.getProductComparison(dto);
          break;
        case SearchType.SHOPS:
          results.shops = await this.searchShops(dto);
          break;
        case SearchType.ALL:
        default:
          const [products, shops, productComparison] = await Promise.all([
            this.searchProducts(dto),
            this.searchShops(dto),
            this.getProductComparison(dto),
          ]);
          results.products = products;
          results.shops = shops;
          results.productComparison = productComparison;
          break;
      }

      results.availableFilters = await this.getAvailableFilters(dto);
    } catch (error) {
      console.error('Search error:', error.message, error.stack);
      throw error;
    }

    results.meta.took = Date.now() - startTime;
    return results;
  }

  async searchProducts(dto: SearchDto): Promise<{
    items: ProductSearchResult[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const { page = 1, limit = 20 } = dto;
    const skip = (page - 1) * limit;

    const pipeline: PipelineStage[] = [];
    const isGeoSearch = !!(dto.longitude && dto.latitude);

    // $geoNear MUST be the first stage in the pipeline if doing geo search
    if (isGeoSearch) {
      pipeline.push({
        $geoNear: {
          near: {
            type: 'Point',
            coordinates: [dto.longitude!, dto.latitude!],
          },
          distanceField: 'distance',
          maxDistance: (dto.maxDistance || 10) * 1000,
          spherical: true,
          query: {
            isActive: true,
            status: ProductStatus.APPROVED,
          },
        },
      });
    }

    // Build match stage
    const matchStage: Record<string, any> = {};

    // Only add isActive and status if NOT already in $geoNear query
    if (!isGeoSearch) {
      matchStage.isActive = true;
      matchStage.status = ProductStatus.APPROVED;
    }

    // Text search - use regex fallback when combining with $geoNear
    const usedTextSearch = !!(dto.query && !isGeoSearch);
    if (dto.query) {
      if (isGeoSearch) {
        // Fallback to regex when combining with $geoNear
        matchStage.$or = [
          { name: { $regex: dto.query, $options: 'i' } },
          { description: { $regex: dto.query, $options: 'i' } },
          { brand: { $regex: dto.query, $options: 'i' } },
          { tags: { $in: [new RegExp(dto.query, 'i')] } },
        ];
      } else {
        // Use $text for non-geo searches (better relevance)
        matchStage.$text = { $search: dto.query };
      }
    }

    // Location filters
    if (dto.stateId) matchStage.stateId = new Types.ObjectId(dto.stateId);
    if (dto.areaId) matchStage.areaId = new Types.ObjectId(dto.areaId);
    if (dto.marketId) matchStage.marketId = new Types.ObjectId(dto.marketId);

    // Category filters
    if (dto.category) matchStage.category = dto.category;
    if (dto.subcategory) matchStage.subcategory = dto.subcategory;
    if (dto.brand) matchStage.brand = { $regex: dto.brand, $options: 'i' };

    // Price filters
    if (dto.minPrice !== undefined || dto.maxPrice !== undefined) {
      matchStage.price = {};
      if (dto.minPrice !== undefined) matchStage.price.$gte = dto.minPrice;
      if (dto.maxPrice !== undefined) matchStage.price.$lte = dto.maxPrice;
    }

    // Stock filter
    if (dto.inStock !== undefined) {
      matchStage.inStock = dto.inStock;
    }

    // Only add $match if there are conditions
    if (Object.keys(matchStage).length > 0) {
      pipeline.push({ $match: matchStage });
    }

    // Lookup vendor
    pipeline.push({
      $lookup: {
        from: 'vendors',
        localField: 'vendorId',
        foreignField: '_id',
        as: 'vendor',
      },
    });
    pipeline.push({ $unwind: '$vendor' });

    // Filter by verified vendors if requested
    if (dto.verifiedOnly) {
      pipeline.push({ $match: { 'vendor.isVerified': true } });
    }

    // Lookup state
    pipeline.push({
      $lookup: {
        from: 'states',
        localField: 'stateId',
        foreignField: '_id',
        as: 'state',
      },
    });
    pipeline.push({
      $unwind: { path: '$state', preserveNullAndEmptyArrays: true },
    });

    // Lookup area
    pipeline.push({
      $lookup: {
        from: 'areas',
        localField: 'areaId',
        foreignField: '_id',
        as: 'area',
      },
    });
    pipeline.push({
      $unwind: { path: '$area', preserveNullAndEmptyArrays: true },
    });

    // Lookup market
    pipeline.push({
      $lookup: {
        from: 'markets',
        localField: 'marketId',
        foreignField: '_id',
        as: 'market',
      },
    });
    pipeline.push({
      $unwind: { path: '$market', preserveNullAndEmptyArrays: true },
    });

    // Add text score only if $text was used
    if (usedTextSearch) {
      pipeline.push({
        $addFields: {
          textScore: { $meta: 'textScore' },
        },
      });
    }

    // Sort
    const sortStage: any = {};
    switch (dto.sortBy) {
      case SortBy.PRICE_LOW:
        sortStage.price = 1;
        break;
      case SortBy.PRICE_HIGH:
        sortStage.price = -1;
        break;
      case SortBy.DISTANCE:
        if (isGeoSearch) sortStage.distance = 1;
        else sortStage.createdAt = -1;
        break;
      case SortBy.RATING:
        sortStage['vendor.rating'] = -1;
        break;
      case SortBy.NEWEST:
        sortStage.createdAt = -1;
        break;
      case SortBy.POPULARITY:
        sortStage.views = -1;
        break;
      case SortBy.RELEVANCE:
      default:
        if (usedTextSearch) {
          sortStage.textScore = -1;
        } else if (isGeoSearch) {
          sortStage.distance = 1;
        }
        sortStage.createdAt = -1;
        break;
    }
    pipeline.push({ $sort: sortStage });

    // Count total before pagination
    const countPipeline = [...pipeline, { $count: 'total' }];
    const countResult = await this.productModel.aggregate(countPipeline);
    const total = countResult[0]?.total || 0;

    // Pagination
    pipeline.push({ $skip: skip });
    pipeline.push({ $limit: limit });

    // Project final shape
    pipeline.push({
      $project: {
        id: '$_id',
        name: 1,
        description: 1,
        brand: 1,
        category: 1,
        subcategory: 1,
        images: 1,
        price: 1,
        originalPrice: 1,
        currency: 1,
        inStock: 1,
        distance: isGeoSearch ? 1 : '$$REMOVE',
        vendor: {
          id: '$vendor._id',
          businessName: '$vendor.businessName',
          logo: '$vendor.shopImages.logo',
          rating: '$vendor.rating',
          isVerified: '$vendor.isVerified',
          contactDetails: {
            phone: '$vendor.contactDetails.phone',
            whatsapp: '$vendor.contactDetails.whatsapp',
          },
        },
        location: {
          state: { id: '$state._id', name: '$state.name' },
          area: { id: '$area._id', name: '$area.name' },
          market: {
            id: '$market._id',
            name: '$market.name',
            type: '$market.type',
          },
          shopNumber: '$vendor.shopNumber',
          shopAddress: '$vendor.shopAddress',
          coordinates: '$location.coordinates',
        },
      },
    });

    const products = await this.productModel.aggregate(pipeline);

    // Update search appearances
    if (products.length > 0) {
      const productIds = products.map((p) => p.id);
      await this.productModel.updateMany(
        { _id: { $in: productIds } },
        { $inc: { searchAppearances: 1 } },
      );
    }

    return {
      items: products as ProductSearchResult[],
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async getProductComparison(dto: SearchDto): Promise<{
    items: ProductWithVendors[];
    total: number;
  }> {
    const pipeline: PipelineStage[] = [];

    const matchStage: Record<string, any> = {
      isActive: true,
      status: ProductStatus.APPROVED,
    };

    // Use regex only - $text cannot be inside $or
    if (dto.query) {
      matchStage.$or = [
        { name: { $regex: dto.query, $options: 'i' } },
        { description: { $regex: dto.query, $options: 'i' } },
        { brand: { $regex: dto.query, $options: 'i' } },
        { tags: { $in: [new RegExp(dto.query, 'i')] } },
      ];
    }

    if (dto.stateId) matchStage.stateId = new Types.ObjectId(dto.stateId);
    if (dto.areaId) matchStage.areaId = new Types.ObjectId(dto.areaId);
    if (dto.marketId) matchStage.marketId = new Types.ObjectId(dto.marketId);
    if (dto.category) matchStage.category = dto.category;

    pipeline.push({ $match: matchStage });

    // Lookup vendor details
    pipeline.push({
      $lookup: {
        from: 'vendors',
        localField: 'vendorId',
        foreignField: '_id',
        as: 'vendor',
      },
    });
    pipeline.push({ $unwind: '$vendor' });

    // Lookup location details
    pipeline.push({
      $lookup: {
        from: 'states',
        localField: 'stateId',
        foreignField: '_id',
        as: 'state',
      },
    });
    pipeline.push({
      $unwind: { path: '$state', preserveNullAndEmptyArrays: true },
    });

    pipeline.push({
      $lookup: {
        from: 'areas',
        localField: 'areaId',
        foreignField: '_id',
        as: 'area',
      },
    });
    pipeline.push({
      $unwind: { path: '$area', preserveNullAndEmptyArrays: true },
    });

    pipeline.push({
      $lookup: {
        from: 'markets',
        localField: 'marketId',
        foreignField: '_id',
        as: 'market',
      },
    });
    pipeline.push({
      $unwind: { path: '$market', preserveNullAndEmptyArrays: true },
    });

    // Group by product name (or sku/barcode if available)
    pipeline.push({
      $group: {
        _id: {
          $cond: [
            { $and: [{ $ne: ['$sku', null] }, { $ne: ['$sku', ''] }] },
            '$sku',
            { $toLower: '$name' },
          ],
        },
        name: { $first: '$name' },
        description: { $first: '$description' },
        brand: { $first: '$brand' },
        category: { $first: '$category' },
        subcategory: { $first: '$subcategory' },
        images: { $first: '$images' },
        catalogItemId: { $first: '$catalogItemId' },
        lowestPrice: { $min: '$price' },
        highestPrice: { $max: '$price' },
        averagePrice: { $avg: '$price' },
        totalVendors: { $sum: 1 },
        vendors: {
          $push: {
            vendorId: '$vendor._id',
            productId: '$_id',
            businessName: '$vendor.businessName',
            logo: '$vendor.shopImages.logo',
            entrancePhoto: '$vendor.shopImages.entrancePhoto',
            rating: '$vendor.rating',
            isVerified: '$vendor.isVerified',
            price: '$price',
            originalPrice: '$originalPrice',
            inStock: '$inStock',
            quantity: '$quantity',
            contactDetails: '$vendor.contactDetails',
            bankDetails: '$vendor.bankDetails',
            location: {
              state: { id: '$state._id', name: '$state.name' },
              area: { id: '$area._id', name: '$area.name' },
              market: {
                id: '$market._id',
                name: '$market.name',
                type: '$market.type',
              },
              shopNumber: '$vendor.shopNumber',
              shopFloor: '$vendor.shopFloor',
              shopBlock: '$vendor.shopBlock',
              shopAddress: '$vendor.shopAddress',
              landmark: '$vendor.landmark',
              coordinates: '$vendor.location.coordinates',
            },
            operatingHours: {
              openingTime: '$vendor.operatingHours.openingTime',
              closingTime: '$vendor.operatingHours.closingTime',
              operatingDays: '$vendor.operatingHours.operatingDays',
              isOpen: '$vendor.isOpen',
            },
          },
        },
      },
    });

    // Sort vendors within each product by price
    pipeline.push({
      $addFields: {
        vendors: {
          $sortArray: {
            input: '$vendors',
            sortBy: { price: 1 },
          },
        },
      },
    });

    // Sort products by number of vendors (popularity)
    pipeline.push({ $sort: { totalVendors: -1 } });

    // Limit
    pipeline.push({ $limit: 20 });

    // Project final shape
    pipeline.push({
      $project: {
        id: '$_id',
        catalogItemId: 1,
        name: 1,
        description: 1,
        brand: 1,
        category: 1,
        subcategory: 1,
        images: 1,
        priceRange: {
          lowest: '$lowestPrice',
          highest: '$highestPrice',
          average: { $round: ['$averagePrice', 2] },
          currency: 'NGN',
        },
        totalVendors: 1,
        vendors: 1,
      },
    });

    try {
      const results = await this.productModel.aggregate(pipeline);
      return {
        items: results as ProductWithVendors[],
        total: results.length,
      };
    } catch (error) {
      console.error('Product comparison error:', error.message);
      return {
        items: [],
        total: 0,
      };
    }
  }

  async searchShops(dto: ShopSearchDto): Promise<{
    items: ShopSearchResult[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const { page = 1, limit = 20 } = dto;
    const skip = (page - 1) * limit;

    const pipeline: PipelineStage[] = [];
    const isGeoSearch = !!(dto.longitude && dto.latitude);

    // $geoNear MUST be the first stage if doing geo search
    if (isGeoSearch) {
      pipeline.push({
        $geoNear: {
          near: {
            type: 'Point',
            coordinates: [dto.longitude!, dto.latitude!],
          },
          distanceField: 'distance',
          maxDistance: (dto.maxDistance || 10) * 1000,
          spherical: true,
          query: { isActive: true },
        },
      });
    }

    const matchStage: Record<string, any> = {};

    if (!isGeoSearch) {
      matchStage.isActive = true;
    }

    // Text search using regex (safe for all cases)
    if (dto.query) {
      matchStage.$or = [
        { businessName: { $regex: dto.query, $options: 'i' } },
        { businessDescription: { $regex: dto.query, $options: 'i' } },
        { categories: { $in: [new RegExp(dto.query, 'i')] } },
        { tags: { $in: [new RegExp(dto.query, 'i')] } },
      ];
    }

    // Location filters
    if (dto.stateId) matchStage.stateId = new Types.ObjectId(dto.stateId);
    if (dto.areaId) matchStage.areaId = new Types.ObjectId(dto.areaId);
    if (dto.marketId) matchStage.marketId = new Types.ObjectId(dto.marketId);

    // Vendor type
    if (dto.vendorType) matchStage.vendorType = dto.vendorType;

    // Verified only
    if (dto.verifiedOnly) matchStage.isVerified = true;

    // Is open
    if (dto.isOpen !== undefined) matchStage.isOpen = dto.isOpen;

    // Category filter
    if (dto.category) {
      matchStage.categories = { $in: [dto.category] };
    }

    // Only add $match if there are conditions
    if (Object.keys(matchStage).length > 0) {
      pipeline.push({ $match: matchStage });
    }

    // Lookup state
    pipeline.push({
      $lookup: {
        from: 'states',
        localField: 'stateId',
        foreignField: '_id',
        as: 'state',
      },
    });
    pipeline.push({
      $unwind: { path: '$state', preserveNullAndEmptyArrays: true },
    });

    // Lookup area
    pipeline.push({
      $lookup: {
        from: 'areas',
        localField: 'areaId',
        foreignField: '_id',
        as: 'area',
      },
    });
    pipeline.push({
      $unwind: { path: '$area', preserveNullAndEmptyArrays: true },
    });

    // Lookup market
    pipeline.push({
      $lookup: {
        from: 'markets',
        localField: 'marketId',
        foreignField: '_id',
        as: 'market',
      },
    });
    pipeline.push({
      $unwind: { path: '$market', preserveNullAndEmptyArrays: true },
    });

    // Lookup featured products
    pipeline.push({
      $lookup: {
        from: 'products',
        let: { vendorId: '$_id' },
        pipeline: [
          {
            $match: {
              $expr: { $eq: ['$vendorId', '$$vendorId'] },
              isActive: true,
              status: ProductStatus.APPROVED,
            },
          },
          { $sort: { views: -1 } },
          { $limit: 4 },
          {
            $project: {
              id: '$_id',
              name: 1,
              price: 1,
              image: { $arrayElemAt: ['$images', 0] },
            },
          },
        ],
        as: 'featuredProducts',
      },
    });

    // Sort
    const sortStage: any = {};
    switch (dto.sortBy) {
      case SortBy.RATING:
        sortStage.rating = -1;
        break;
      case SortBy.POPULARITY:
        sortStage.totalViews = -1;
        break;
      case SortBy.NEWEST:
        sortStage.createdAt = -1;
        break;
      case SortBy.DISTANCE:
        if (isGeoSearch) sortStage.distance = 1;
        else sortStage.createdAt = -1;
        break;
      default:
        if (isGeoSearch) {
          sortStage.distance = 1;
        }
        sortStage.isFeatured = -1;
        sortStage.isVerified = -1;
        sortStage.rating = -1;
        break;
    }
    pipeline.push({ $sort: sortStage });

    // Count total
    const countPipeline = [...pipeline, { $count: 'total' }];
    const countResult = await this.vendorModel.aggregate(countPipeline);
    const total = countResult[0]?.total || 0;

    // Pagination
    pipeline.push({ $skip: skip });
    pipeline.push({ $limit: limit });

    // Project final shape
    pipeline.push({
      $project: {
        id: '$_id',
        businessName: 1,
        businessDescription: 1,
        vendorType: 1,
        logo: '$shopImages.logo',
        entrancePhoto: '$shopImages.entrancePhoto',
        layoutMap: '$shopImages.layoutMap',
        rating: 1,
        reviewCount: 1,
        totalProducts: 1,
        isVerified: 1,
        isFeatured: 1,
        categories: 1,
        distance: isGeoSearch ? 1 : '$$REMOVE',
        priceRange: {
          min: '$minProductPrice',
          max: '$maxProductPrice',
        },
        contactDetails: {
          phone: '$contactDetails.phone',
          whatsapp: '$contactDetails.whatsapp',
          email: '$contactDetails.email',
          instagram: '$contactDetails.instagram',
        },
        bankDetails: 1,
        location: {
          state: { id: '$state._id', name: '$state.name' },
          area: { id: '$area._id', name: '$area.name' },
          market: {
            id: '$market._id',
            name: '$market.name',
            type: '$market.type',
          },
          shopNumber: 1,
          shopFloor: 1,
          shopBlock: 1,
          shopAddress: 1,
          landmark: 1,
          coordinates: '$location.coordinates',
        },
        operatingHours: {
          openingTime: '$operatingHours.openingTime',
          closingTime: '$operatingHours.closingTime',
          operatingDays: '$operatingHours.operatingDays',
          isOpen: 1,
        },
        featuredProducts: 1,
      },
    });

    const shops = await this.vendorModel.aggregate(pipeline);

    // Update search appearances
    if (shops.length > 0) {
      const vendorIds = shops.map((s) => s.id);
      await this.vendorModel.updateMany(
        { _id: { $in: vendorIds } },
        { $inc: { searchAppearances: 1 } },
      );
    }

    return {
      items: shops as ShopSearchResult[],
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async getAvailableFilters(dto: SearchDto): Promise<{
    states: { id: string; name: string; count: number }[];
    areas: { id: string; name: string; count: number }[];
    markets: { id: string; name: string; count: number }[];
    categories: { name: string; count: number }[];
    brands: { name: string; count: number }[];
    priceRange: { min: number; max: number };
  }> {
    const matchStage: Record<string, any> = {
      isActive: true,
      status: ProductStatus.APPROVED,
    };

    // Use regex instead of $text for filter aggregation
    if (dto.query) {
      matchStage.$or = [
        { name: { $regex: dto.query, $options: 'i' } },
        { description: { $regex: dto.query, $options: 'i' } },
        { brand: { $regex: dto.query, $options: 'i' } },
        { tags: { $in: [new RegExp(dto.query, 'i')] } },
      ];
    }

    try {
      // States
      const statesAgg = await this.productModel.aggregate([
        { $match: matchStage },
        {
          $lookup: {
            from: 'states',
            localField: 'stateId',
            foreignField: '_id',
            as: 'state',
          },
        },
        { $unwind: '$state' },
        {
          $group: {
            _id: '$state._id',
            name: { $first: '$state.name' },
            count: { $sum: 1 },
          },
        },
        { $sort: { count: -1 } },
        { $limit: 20 },
        {
          $project: {
            id: '$_id',
            name: 1,
            count: 1,
            _id: 0,
          },
        },
      ]);

      // Areas (filtered by state if provided)
      const areasMatch = { ...matchStage };
      if (dto.stateId) areasMatch.stateId = new Types.ObjectId(dto.stateId);

      const areasAgg = await this.productModel.aggregate([
        { $match: areasMatch },
        {
          $lookup: {
            from: 'areas',
            localField: 'areaId',
            foreignField: '_id',
            as: 'area',
          },
        },
        { $unwind: '$area' },
        {
          $group: {
            _id: '$area._id',
            name: { $first: '$area.name' },
            count: { $sum: 1 },
          },
        },
        { $sort: { count: -1 } },
        { $limit: 20 },
        {
          $project: {
            id: '$_id',
            name: 1,
            count: 1,
            _id: 0,
          },
        },
      ]);

      // Markets (filtered by area if provided)
      const marketsMatch = { ...matchStage };
      if (dto.stateId)
        marketsMatch.stateId = new Types.ObjectId(dto.stateId);
      if (dto.areaId) marketsMatch.areaId = new Types.ObjectId(dto.areaId);

      const marketsAgg = await this.productModel.aggregate([
        {
          $match: {
            ...marketsMatch,
            marketId: { $exists: true, $ne: null },
          },
        },
        {
          $lookup: {
            from: 'markets',
            localField: 'marketId',
            foreignField: '_id',
            as: 'market',
          },
        },
        { $unwind: '$market' },
        {
          $group: {
            _id: '$market._id',
            name: { $first: '$market.name' },
            count: { $sum: 1 },
          },
        },
        { $sort: { count: -1 } },
        { $limit: 20 },
        {
          $project: {
            id: '$_id',
            name: 1,
            count: 1,
            _id: 0,
          },
        },
      ]);

      // Categories
      const categoriesAgg = await this.productModel.aggregate([
        { $match: matchStage },
        {
          $group: {
            _id: '$category',
            count: { $sum: 1 },
          },
        },
        { $sort: { count: -1 } },
        { $limit: 20 },
        {
          $project: {
            name: '$_id',
            count: 1,
            _id: 0,
          },
        },
      ]);

      // Brands
      const brandsAgg = await this.productModel.aggregate([
        {
          $match: {
            ...matchStage,
            brand: { $exists: true, $nin: [null, ''] }
          },
        },
        {
          $group: {
            _id: '$brand',
            count: { $sum: 1 },
          },
        },
        { $sort: { count: -1 } },
        { $limit: 20 },
        {
          $project: {
            name: '$_id',
            count: 1,
            _id: 0,
          },
        },
      ]);

      // Price range
      const priceAgg = await this.productModel.aggregate([
        { $match: matchStage },
        {
          $group: {
            _id: null,
            min: { $min: '$price' },
            max: { $max: '$price' },
          },
        },
      ]);

      return {
        states: statesAgg,
        areas: areasAgg,
        markets: marketsAgg,
        categories: categoriesAgg,
        brands: brandsAgg,
        priceRange: priceAgg[0]
          ? { min: priceAgg[0].min, max: priceAgg[0].max }
          : { min: 0, max: 0 },
      };
    } catch (error) {
      console.error('Filter aggregation error:', error.message);
      return {
        states: [],
        areas: [],
        markets: [],
        categories: [],
        brands: [],
        priceRange: { min: 0, max: 0 },
      };
    }
  }

  async getProductVendors(
    productName: string,
    filters: SearchDto,
  ): Promise<ProductWithVendors> {
    const pipeline: PipelineStage[] = [];

    const matchStage: Record<string, any> = {
      isActive: true,
      status: ProductStatus.APPROVED,
      $or: [
        { name: { $regex: productName, $options: 'i' } },
        { sku: productName },
        { barcode: productName },
      ],
    };

    if (filters.stateId)
      matchStage.stateId = new Types.ObjectId(filters.stateId);
    if (filters.areaId)
      matchStage.areaId = new Types.ObjectId(filters.areaId);
    if (filters.marketId)
      matchStage.marketId = new Types.ObjectId(filters.marketId);
    if (filters.minPrice !== undefined) {
      matchStage.price = {
        ...(matchStage.price || {}),
        $gte: filters.minPrice,
      };
    }
    if (filters.maxPrice !== undefined) {
      matchStage.price = {
        ...(matchStage.price || {}),
        $lte: filters.maxPrice,
      };
    }

    pipeline.push({ $match: matchStage });

    // Full vendor lookup with all details
    pipeline.push({
      $lookup: {
        from: 'vendors',
        localField: 'vendorId',
        foreignField: '_id',
        as: 'vendor',
      },
    });
    pipeline.push({ $unwind: '$vendor' });

    // Location lookups
    pipeline.push({
      $lookup: {
        from: 'states',
        localField: 'stateId',
        foreignField: '_id',
        as: 'state',
      },
    });
    pipeline.push({
      $unwind: { path: '$state', preserveNullAndEmptyArrays: true },
    });

    pipeline.push({
      $lookup: {
        from: 'areas',
        localField: 'areaId',
        foreignField: '_id',
        as: 'area',
      },
    });
    pipeline.push({
      $unwind: { path: '$area', preserveNullAndEmptyArrays: true },
    });

    pipeline.push({
      $lookup: {
        from: 'markets',
        localField: 'marketId',
        foreignField: '_id',
        as: 'market',
      },
    });
    pipeline.push({
      $unwind: { path: '$market', preserveNullAndEmptyArrays: true },
    });

    // Group to get all vendors
    pipeline.push({
      $group: {
        _id: { $toLower: '$name' },
        name: { $first: '$name' },
        description: { $first: '$description' },
        brand: { $first: '$brand' },
        category: { $first: '$category' },
        subcategory: { $first: '$subcategory' },
        images: { $first: '$images' },
        catalogItemId: { $first: '$catalogItemId' },
        lowestPrice: { $min: '$price' },
        highestPrice: { $max: '$price' },
        averagePrice: { $avg: '$price' },
        totalVendors: { $sum: 1 },
        vendors: {
          $push: {
            vendorId: '$vendor._id',
            productId: '$_id',
            businessName: '$vendor.businessName',
            logo: '$vendor.shopImages.logo',
            entrancePhoto: '$vendor.shopImages.entrancePhoto',
            rating: '$vendor.rating',
            isVerified: '$vendor.isVerified',
            price: '$price',
            originalPrice: '$originalPrice',
            inStock: '$inStock',
            quantity: '$quantity',
            contactDetails: '$vendor.contactDetails',
            bankDetails: '$vendor.bankDetails',
            location: {
              state: { id: '$state._id', name: '$state.name' },
              area: { id: '$area._id', name: '$area.name' },
              market: {
                id: '$market._id',
                name: '$market.name',
                type: '$market.type',
              },
              shopNumber: '$vendor.shopNumber',
              shopFloor: '$vendor.shopFloor',
              shopBlock: '$vendor.shopBlock',
              shopAddress: '$vendor.shopAddress',
              landmark: '$vendor.landmark',
              coordinates: '$vendor.location.coordinates',
            },
            operatingHours: {
              openingTime: '$vendor.operatingHours.openingTime',
              closingTime: '$vendor.operatingHours.closingTime',
              operatingDays: '$vendor.operatingHours.operatingDays',
              isOpen: '$vendor.isOpen',
            },
          },
        },
      },
    });

    // Sort vendors by price
    pipeline.push({
      $addFields: {
        vendors: {
          $sortArray: {
            input: '$vendors',
            sortBy: { price: 1 },
          },
        },
      },
    });

    pipeline.push({
      $project: {
        id: '$_id',
        catalogItemId: 1,
        name: 1,
        description: 1,
        brand: 1,
        category: 1,
        subcategory: 1,
        images: 1,
        priceRange: {
          lowest: '$lowestPrice',
          highest: '$highestPrice',
          average: { $round: ['$averagePrice', 2] },
          currency: 'NGN',
        },
        totalVendors: 1,
        vendors: 1,
      },
    });

    const result = await this.productModel.aggregate(pipeline);
    return result[0] as ProductWithVendors;
  }

  async getShopProducts(
    vendorId: string,
    filters: {
      category?: string;
      minPrice?: number;
      maxPrice?: number;
      page?: number;
      limit?: number;
    },
  ): Promise<{
    shop: ShopSearchResult;
    products: ProductSearchResult[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const { page = 1, limit = 20 } = filters;
    const skip = (page - 1) * limit;

    // Get shop details
    const shopPipeline: PipelineStage[] = [
      { $match: { _id: new Types.ObjectId(vendorId) } },
      {
        $lookup: {
          from: 'states',
          localField: 'stateId',
          foreignField: '_id',
          as: 'state',
        },
      },
      {
        $unwind: { path: '$state', preserveNullAndEmptyArrays: true },
      },
      {
        $lookup: {
          from: 'areas',
          localField: 'areaId',
          foreignField: '_id',
          as: 'area',
        },
      },
      {
        $unwind: { path: '$area', preserveNullAndEmptyArrays: true },
      },
      {
        $lookup: {
          from: 'markets',
          localField: 'marketId',
          foreignField: '_id',
          as: 'market',
        },
      },
      {
        $unwind: { path: '$market', preserveNullAndEmptyArrays: true },
      },
    ];

    const shopResult = await this.vendorModel.aggregate(shopPipeline);
    const shop = shopResult[0];

    if (!shop) {
      return {
        shop: null as any,
        products: [],
        total: 0,
        page,
        totalPages: 0,
      };
    }

    // Get products
    const productMatch: Record<string, any> = {
      vendorId: new Types.ObjectId(vendorId),
      isActive: true,
      status: ProductStatus.APPROVED,
    };

    if (filters.category) productMatch.category = filters.category;
    if (filters.minPrice !== undefined || filters.maxPrice !== undefined) {
      productMatch.price = {};
      if (filters.minPrice !== undefined)
        productMatch.price.$gte = filters.minPrice;
      if (filters.maxPrice !== undefined)
        productMatch.price.$lte = filters.maxPrice;
    }

    const [products, total] = await Promise.all([
      this.productModel
        .find(productMatch)
        .skip(skip)
        .limit(limit)
        .sort({ createdAt: -1 }),
      this.productModel.countDocuments(productMatch),
    ]);

    return {
      shop: shop as ShopSearchResult,
      products: products.map((p) => ({
        id: p._id.toString(),
        name: p.name,
        description: p.description,
        brand: p.brand,
        category: p.category,
        subcategory: p.subcategory,
        images: p.images || [],
        price: p.price,
        originalPrice: p.originalPrice,
        currency: p.currency,
        inStock: p.inStock,
        vendor: {
          id: shop._id.toString(),
          businessName: shop.businessName,
          logo: shop.shopImages?.logo,
          rating: shop.rating,
          isVerified: shop.isVerified,
          contactDetails: {
            phone: shop.contactDetails?.phone,
            whatsapp: shop.contactDetails?.whatsapp,
          },
        },
        location: {
          state: {
            id: shop.state?._id?.toString(),
            name: shop.state?.name,
          },
          area: { id: shop.area?._id?.toString(), name: shop.area?.name },
          market: {
            id: shop.market?._id?.toString(),
            name: shop.market?.name,
            type: shop.market?.type,
          },
          shopNumber: shop.shopNumber,
          shopAddress: shop.shopAddress,
        },
      })) as ProductSearchResult[],
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async getSimilarProducts(
    productId: string,
    limit: number = 10,
  ): Promise<ProductSearchResult[]> {
    try {
      const product = await this.productModel.findById(productId);
      if (!product) return [];

      const pipeline: PipelineStage[] = [
        {
          $match: {
            _id: { $ne: product._id },
            category: product.category,
            isActive: true,
            status: ProductStatus.APPROVED,
          },
        },
        {
          $lookup: {
            from: 'vendors',
            localField: 'vendorId',
            foreignField: '_id',
            as: 'vendor',
          },
        },
        { $unwind: '$vendor' },
        {
          $lookup: {
            from: 'states',
            localField: 'stateId',
            foreignField: '_id',
            as: 'state',
          },
        },
        {
          $unwind: { path: '$state', preserveNullAndEmptyArrays: true },
        },
        {
          $lookup: {
            from: 'areas',
            localField: 'areaId',
            foreignField: '_id',
            as: 'area',
          },
        },
        {
          $unwind: { path: '$area', preserveNullAndEmptyArrays: true },
        },
        { $sample: { size: limit } },
        {
          $project: {
            id: '$_id',
            name: 1,
            description: 1,
            brand: 1,
            category: 1,
            subcategory: 1,
            images: 1,
            price: 1,
            originalPrice: 1,
            currency: 1,
            inStock: 1,
            vendor: {
              id: '$vendor._id',
              businessName: '$vendor.businessName',
              logo: '$vendor.shopImages.logo',
              rating: '$vendor.rating',
              isVerified: '$vendor.isVerified',
              contactDetails: {
                phone: '$vendor.contactDetails.phone',
                whatsapp: '$vendor.contactDetails.whatsapp',
              },
            },
            location: {
              state: { id: '$state._id', name: '$state.name' },
              area: { id: '$area._id', name: '$area.name' },
            },
          },
        },
      ];

      return this.productModel.aggregate(pipeline);
    } catch (error) {
      console.error('Similar products error:', error.message);
      return [];
    }
  }
}
import { IsString, IsOptional, IsArray, IsNumber, IsBoolean } from 'class-validator';

export class CreateStateDto {
  @IsString()
  name: string;

  @IsString()
  code: string;

  @IsString()
  @IsOptional()
  capital?: string;

  @IsArray()
  @IsNumber({}, { each: true })
  @IsOptional()
  coordinates?: [number, number];

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;
}
import { IsString, IsOptional, IsArray, IsNumber, IsBoolean } from 'class-validator';

export class UpdateStateDto {
  @IsString()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  code?: string;

  @IsString()
  @IsOptional()
  capital?: string;

  @IsArray()
  @IsNumber({}, { each: true })
  @IsOptional()
  coordinates?: [number, number];

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;
}
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ timestamps: true })
export class State extends Document {
  @Prop({ required: true, unique: true })
  name: string;

  @Prop({ required: true, unique: true })
  code: string;

  @Prop()
  capital?: string;

  @Prop({ default: 'Nigeria' })
  country: string;

  @Prop({ type: { type: String, enum: ['Point'], default: 'Point' }, coordinates: [Number] })
  location?: {
    type: 'Point';
    coordinates: [number, number];
  };

  @Prop({ default: true })
  isActive: boolean;
}

export const StateSchema = SchemaFactory.createForClass(State);

StateSchema.index({ location: '2dsphere' });
StateSchema.index({ name: 1 });
StateSchema.index({ code: 1 });
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  UseGuards,
} from '@nestjs/common';
import { StatesService } from './states.service';
import { CreateStateDto } from './dto/create-state.dto';
import { UpdateStateDto } from './dto/update-state.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { Role } from '../common/enums/role.enum';

@Controller('states')
export class StatesController {
  constructor(private statesService: StatesService) {}

  @Get()
  findAll() {
    return this.statesService.findAll();
  }

  @Get('seed')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  seedStates() {
    return this.statesService.seedNigerianStates();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.statesService.findById(id);
  }

  @Get('code/:code')
  findByCode(@Param('code') code: string) {
    return this.statesService.findByCode(code);
  }

  @Post()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  create(@Body() dto: CreateStateDto) {
    return this.statesService.create(dto);
  }

  @Put(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  update(@Param('id') id: string, @Body() dto: UpdateStateDto) {
    return this.statesService.update(id, dto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.SUPER_ADMIN)
  delete(@Param('id') id: string) {
    return this.statesService.delete(id);
  }
}
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { StatesService } from './states.service';
import { StatesController } from './states.controller';
import { State, StateSchema } from './schemas/state.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: State.name, schema: StateSchema }]),
  ],
  controllers: [StatesController],
  providers: [StatesService],
  exports: [StatesService],
})
export class StatesModule {}
import { Injectable, NotFoundException, ConflictException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { State } from './schemas/state.schema';
import { CreateStateDto } from './dto/create-state.dto';
import { UpdateStateDto } from './dto/update-state.dto';

@Injectable()
export class StatesService {
  constructor(@InjectModel(State.name) private stateModel: Model<State>) {}

  async create(dto: CreateStateDto): Promise<State> {
    const exists = await this.stateModel.findOne({
      $or: [{ name: dto.name }, { code: dto.code }],
    });
    if (exists) {
      throw new ConflictException('State already exists');
    }

    const stateData: any = { ...dto };
    if (dto.coordinates) {
      stateData.location = {
        type: 'Point',
        coordinates: dto.coordinates,
      };
    }
    delete stateData.coordinates;

    return this.stateModel.create(stateData);
  }

  async findAll(): Promise<State[]> {
    return this.stateModel.find({ isActive: true }).sort({ name: 1 });
  }

  async findById(id: string): Promise<State> {
    const state = await this.stateModel.findById(id);
    if (!state) {
      throw new NotFoundException('State not found');
    }
    return state;
  }

  async findByCode(code: string): Promise<State> {
    const state = await this.stateModel.findOne({ code: code.toUpperCase() });
    if (!state) {
      throw new NotFoundException('State not found');
    }
    return state;
  }

  async update(id: string, dto: UpdateStateDto): Promise<State> {
    const updateData: any = { ...dto };
    if (dto.coordinates) {
      updateData.location = {
        type: 'Point',
        coordinates: dto.coordinates,
      };
    }
    delete updateData.coordinates;

    const state = await this.stateModel.findByIdAndUpdate(id, updateData, {
      new: true,
    });
    if (!state) {
      throw new NotFoundException('State not found');
    }
    return state;
  }

  async delete(id: string): Promise<void> {
    const result = await this.stateModel.deleteOne({ _id: id });
    if (result.deletedCount === 0) {
      throw new NotFoundException('State not found');
    }
  }

  async seedNigerianStates(): Promise<State[]> {
    const nigerianStates = [
      { name: 'Abia', code: 'AB', capital: 'Umuahia' },
      { name: 'Adamawa', code: 'AD', capital: 'Yola' },
      { name: 'Akwa Ibom', code: 'AK', capital: 'Uyo' },
      { name: 'Anambra', code: 'AN', capital: 'Awka' },
      { name: 'Bauchi', code: 'BA', capital: 'Bauchi' },
      { name: 'Bayelsa', code: 'BY', capital: 'Yenagoa' },
      { name: 'Benue', code: 'BE', capital: 'Makurdi' },
      { name: 'Borno', code: 'BO', capital: 'Maiduguri' },
      { name: 'Cross River', code: 'CR', capital: 'Calabar' },
      { name: 'Delta', code: 'DE', capital: 'Asaba' },
      { name: 'Ebonyi', code: 'EB', capital: 'Abakaliki' },
      { name: 'Edo', code: 'ED', capital: 'Benin City' },
      { name: 'Ekiti', code: 'EK', capital: 'Ado-Ekiti' },
      { name: 'Enugu', code: 'EN', capital: 'Enugu' },
      { name: 'FCT', code: 'FC', capital: 'Abuja' },
      { name: 'Gombe', code: 'GO', capital: 'Gombe' },
      { name: 'Imo', code: 'IM', capital: 'Owerri' },
      { name: 'Jigawa', code: 'JI', capital: 'Dutse' },
      { name: 'Kaduna', code: 'KD', capital: 'Kaduna' },
      { name: 'Kano', code: 'KN', capital: 'Kano' },
      { name: 'Katsina', code: 'KT', capital: 'Katsina' },
      { name: 'Kebbi', code: 'KE', capital: 'Birnin Kebbi' },
      { name: 'Kogi', code: 'KO', capital: 'Lokoja' },
      { name: 'Kwara', code: 'KW', capital: 'Ilorin' },
      { name: 'Lagos', code: 'LA', capital: 'Ikeja' },
      { name: 'Nasarawa', code: 'NA', capital: 'Lafia' },
      { name: 'Niger', code: 'NI', capital: 'Minna' },
      { name: 'Ogun', code: 'OG', capital: 'Abeokuta' },
      { name: 'Ondo', code: 'ON', capital: 'Akure' },
      { name: 'Osun', code: 'OS', capital: 'Osogbo' },
      { name: 'Oyo', code: 'OY', capital: 'Ibadan' },
      { name: 'Plateau', code: 'PL', capital: 'Jos' },
      { name: 'Rivers', code: 'RI', capital: 'Port Harcourt' },
      { name: 'Sokoto', code: 'SO', capital: 'Sokoto' },
      { name: 'Taraba', code: 'TA', capital: 'Jalingo' },
      { name: 'Yobe', code: 'YO', capital: 'Damaturu' },
      { name: 'Zamfara', code: 'ZA', capital: 'Gusau' },
    ];

    const createdStates: State[] = [];
    for (const stateData of nigerianStates) {
      const exists = await this.stateModel.findOne({ code: stateData.code });
      if (!exists) {
        const state = await this.stateModel.create(stateData);
        createdStates.push(state);
      }
    }
    return createdStates;
  }
}
import {
  Controller,
  Post,
  UseGuards,
  UseInterceptors,
  UploadedFile,
  UploadedFiles,
  BadRequestException,
  Param,
  Delete,
} from '@nestjs/common';
import { FileInterceptor, FilesInterceptor } from '@nestjs/platform-express';
import { UploadService } from './upload.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';

@Controller('upload')
@UseGuards(JwtAuthGuard)
export class UploadController {
  constructor(private uploadService: UploadService) {}

  @Post('image')
  @UseInterceptors(FileInterceptor('file'))
  async uploadImage(@UploadedFile() file: Express.Multer.File) {
    if (!file) {
      throw new BadRequestException('No file provided');
    }
    return this.uploadService.uploadImage(file);
  }

  @Post('images')
  @UseInterceptors(FilesInterceptor('files', 10))
  async uploadImages(@UploadedFiles() files: Express.Multer.File[]) {
    if (!files || files.length === 0) {
      throw new BadRequestException('No files provided');
    }
    return this.uploadService.uploadMultipleImages(files);
  }

  @Post('shop-entrance')
  @UseInterceptors(FileInterceptor('file'))
  async uploadShopEntrance(@UploadedFile() file: Express.Multer.File) {
    if (!file) {
      throw new BadRequestException('No file provided');
    }
    return this.uploadService.uploadShopEntrance(file);
  }

  @Post('shop-logo')
  @UseInterceptors(FileInterceptor('file'))
  async uploadShopLogo(@UploadedFile() file: Express.Multer.File) {
    if (!file) {
      throw new BadRequestException('No file provided');
    }
    return this.uploadService.uploadShopLogo(file);
  }

  @Post('market-layout')
  @UseInterceptors(FileInterceptor('file'))
  async uploadMarketLayout(@UploadedFile() file: Express.Multer.File) {
    if (!file) {
      throw new BadRequestException('No file provided');
    }
    return this.uploadService.uploadMarketLayout(file);
  }

  @Post('product')
  @UseInterceptors(FileInterceptor('file'))
  async uploadProductImage(@UploadedFile() file: Express.Multer.File) {
    if (!file) {
      throw new BadRequestException('No file provided');
    }
    return this.uploadService.uploadProductImage(file);
  }

  @Delete(':publicId')
  async deleteImage(@Param('publicId') publicId: string) {
    return this.uploadService.deleteImage(publicId);
  }
}
import { Module } from '@nestjs/common';
import { MulterModule } from '@nestjs/platform-express';
import { memoryStorage } from 'multer';
import { UploadController } from './upload.controller';
import { UploadService } from './upload.service';

@Module({
  imports: [
    MulterModule.register({
      storage: memoryStorage(),
      limits: {
        fileSize: 10 * 1024 * 1024, // 10MB limit
      },
      fileFilter: (req, file, callback) => {
        if (!file.mimetype.match(/\/(jpg|jpeg|png|gif|webp)$/)) {
          return callback(new Error('Only image files are allowed!'), false);
        }
        callback(null, true);
      },
    }),
  ],
  controllers: [UploadController],
  providers: [UploadService],
  exports: [UploadService],
})
export class UploadModule {}
import { Injectable, BadRequestException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { v2 as cloudinary, UploadApiResponse, UploadApiErrorResponse } from 'cloudinary';
import * as streamifier from 'streamifier';

export interface CloudinaryResponse {
  url: string;
  publicId: string;
  width?: number;
  height?: number;
  format?: string;
}

@Injectable()
export class UploadService {
  constructor(private configService: ConfigService) {
    cloudinary.config({
      cloud_name: this.configService.get<string>('CLOUDINARY_CLOUD_NAME'),
      api_key: this.configService.get<string>('CLOUDINARY_API_KEY'),
      api_secret: this.configService.get<string>('CLOUDINARY_API_SECRET'),
    });
  }

  async uploadImage(
    file: Express.Multer.File,
    folder: string = 'sureshops',
  ): Promise<CloudinaryResponse> {
    return new Promise((resolve, reject) => {
      const uploadStream = cloudinary.uploader.upload_stream(
        {
          folder: folder,
          resource_type: 'image',
          transformation: [
            { width: 1200, height: 1200, crop: 'limit' },
            { quality: 'auto' },
            { fetch_format: 'auto' },
          ],
        },
        (error: UploadApiErrorResponse, result: UploadApiResponse) => {
          if (error) {
            reject(new BadRequestException('Failed to upload image'));
          } else {
            resolve({
              url: result.secure_url,
              publicId: result.public_id,
              width: result.width,
              height: result.height,
              format: result.format,
            });
          }
        },
      );

      streamifier.createReadStream(file.buffer).pipe(uploadStream);
    });
  }

  async uploadMultipleImages(
    files: Express.Multer.File[],
    folder: string = 'sureshops',
  ): Promise<CloudinaryResponse[]> {
    const uploadPromises = files.map((file) => this.uploadImage(file, folder));
    return Promise.all(uploadPromises);
  }

  async deleteImage(publicId: string): Promise<boolean> {
    try {
      const result = await cloudinary.uploader.destroy(publicId);
      return result.result === 'ok';
    } catch (error) {
      throw new BadRequestException('Failed to delete image');
    }
  }

  async uploadShopEntrance(file: Express.Multer.File): Promise<CloudinaryResponse> {
    return this.uploadImage(file, 'sureshops/shop-entrances');
  }

  async uploadShopLogo(file: Express.Multer.File): Promise<CloudinaryResponse> {
    return new Promise((resolve, reject) => {
      const uploadStream = cloudinary.uploader.upload_stream(
        {
          folder: 'sureshops/logos',
          resource_type: 'image',
          transformation: [
            { width: 500, height: 500, crop: 'fill' },
            { quality: 'auto' },
            { fetch_format: 'auto' },
          ],
        },
        (error: UploadApiErrorResponse, result: UploadApiResponse) => {
          if (error) {
            reject(new BadRequestException('Failed to upload logo'));
          } else {
            resolve({
              url: result.secure_url,
              publicId: result.public_id,
              width: result.width,
              height: result.height,
              format: result.format,
            });
          }
        },
      );

      streamifier.createReadStream(file.buffer).pipe(uploadStream);
    });
  }

  async uploadMarketLayout(file: Express.Multer.File): Promise<CloudinaryResponse> {
    return this.uploadImage(file, 'sureshops/market-layouts');
  }

  async uploadProductImage(file: Express.Multer.File): Promise<CloudinaryResponse> {
    return this.uploadImage(file, 'sureshops/products');
  }
}
import {
  IsEmail,
  IsString,
  MinLength,
  IsOptional,
  IsEnum,
} from 'class-validator';
import { Role } from '../../common/enums/role.enum';

export class CreateUserDto {
  @IsString()
  @MinLength(2)
  firstName: string;

  @IsString()
  @MinLength(2)
  lastName: string;

  @IsEmail()
  email: string;

  @IsString()
  @MinLength(6)
  password: string;

  @IsString()
  phone: string;

  @IsEnum(Role)
  @IsOptional()
  role?: Role;

  @IsString()
  @IsOptional()
  avatar?: string;
}
import { IsString, IsOptional, IsEnum, IsBoolean } from 'class-validator';
import { Role } from '../../common/enums/role.enum';

export class UpdateUserDto {
  @IsString()
  @IsOptional()
  firstName?: string;

  @IsString()
  @IsOptional()
  lastName?: string;

  @IsString()
  @IsOptional()
  phone?: string;

  @IsEnum(Role)
  @IsOptional()
  role?: Role;

  @IsString()
  @IsOptional()
  avatar?: string;

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;
}
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { Role } from '../../common/enums/role.enum';

@Schema({ timestamps: true })
export class User extends Document {
  @Prop({ required: true })
  firstName: string;

  @Prop({ required: true })
  lastName: string;

  @Prop({ required: true, unique: true, lowercase: true })
  email: string;

  @Prop({ required: true })
  password: string;

  @Prop({ required: true })
  phone: string;

  @Prop({ type: String, enum: Role, default: Role.USER })
  role: Role;

  @Prop()
  avatar?: string;

  @Prop({ default: true })
  isActive: boolean;

  @Prop({ default: false })
  isEmailVerified: boolean;

  @Prop()
  lastLoginAt?: Date;

  @Prop({ type: Types.ObjectId, ref: 'Vendor' })
  vendorProfile?: Types.ObjectId;

  createdAt: Date;
updatedAt: Date;
}

export const UserSchema = SchemaFactory.createForClass(User);

UserSchema.index({ email: 1 });
UserSchema.index({ phone: 1 });
UserSchema.index({ role: 1 });
import {
  Controller,
  Get,
  Put,
  Delete,
  Body,
  Param,
  UseGuards,
  Request,
} from '@nestjs/common';
import { UsersService } from './users.service';
import { UpdateUserDto } from './dto/update-user.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { Role } from '../common/enums/role.enum';

@Controller('users')
@UseGuards(JwtAuthGuard)
export class UsersController {
  constructor(private usersService: UsersService) {}

  @Get()
  @UseGuards(RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  findAll() {
    return this.usersService.findAll();
  }

  @Get('profile')
  getProfile(@Request() req) {
    return this.usersService.findById(req.user.id);
  }

  @Get(':id')
  @UseGuards(RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  findOne(@Param('id') id: string) {
    return this.usersService.findById(id);
  }

  @Put('profile')
  updateProfile(@Request() req, @Body() dto: UpdateUserDto) {
    return this.usersService.update(req.user.id, dto);
  }

  @Put(':id')
  @UseGuards(RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  update(@Param('id') id: string, @Body() dto: UpdateUserDto) {
    return this.usersService.update(id, dto);
  }

  @Delete(':id')
  @UseGuards(RolesGuard)
  @Roles(Role.SUPER_ADMIN)
  delete(@Param('id') id: string) {
    return this.usersService.delete(id);
  }
}
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';
import { User, UserSchema } from './schemas/user.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: User.name, schema: UserSchema }]),
  ],
  controllers: [UsersController],
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { User } from './schemas/user.schema';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';

@Injectable()
export class UsersService {
  constructor(@InjectModel(User.name) private userModel: Model<User>) {}

  async create(dto: CreateUserDto): Promise<User> {
    return this.userModel.create(dto);
  }

  async findAll(): Promise<User[]> {
    return this.userModel.find().select('-password').sort({ createdAt: -1 });
  }

  async findById(id: string): Promise<User | null> {
    return this.userModel.findById(id).select('-password');
  }

  async findByEmail(email: string): Promise<User | null> {
    return this.userModel.findOne({ email: email.toLowerCase() });
  }

  async update(id: string, dto: UpdateUserDto): Promise<User> {
    const user = await this.userModel
      .findByIdAndUpdate(id, dto, { new: true })
      .select('-password');
    if (!user) {
      throw new NotFoundException('User not found');
    }
    return user;
  }

  async updateVendorProfile(userId: string, vendorId: string): Promise<User> {
    const user = await this.userModel
      .findByIdAndUpdate(
        userId,
        { vendorProfile: vendorId },
        { new: true },
      )
      .select('-password');
    if (!user) {
      throw new NotFoundException('User not found');
    }
    return user;
  }

  async delete(id: string): Promise<void> {
    const result = await this.userModel.deleteOne({ _id: id });
    if (result.deletedCount === 0) {
      throw new NotFoundException('User not found');
    }
  }
}
import {
  IsString,
  IsOptional,
  IsArray,
  IsNumber,
  IsMongoId,
  IsEnum,
  IsObject,
  IsBoolean,
  ValidateNested,
  IsEmail,
} from 'class-validator';
import { Type } from 'class-transformer';
import { VendorType } from '../../common/enums/vendor-type.enum';

class BankDetailsDto {
  @IsString()
  @IsOptional()
  bankName?: string;

  @IsString()
  @IsOptional()
  accountName?: string;

  @IsString()
  @IsOptional()
  accountNumber?: string;

  @IsString()
  @IsOptional()
  bankCode?: string;
}

class ContactDetailsDto {
  @IsString()
  phone: string;

  @IsString()
  @IsOptional()
  alternatePhone?: string;

  @IsEmail()
  @IsOptional()
  email?: string;

  @IsString()
  @IsOptional()
  whatsapp?: string;

  @IsString()
  @IsOptional()
  instagram?: string;

  @IsString()
  @IsOptional()
  facebook?: string;

  @IsString()
  @IsOptional()
  twitter?: string;

  @IsString()
  @IsOptional()
  website?: string;
}

class ShopImagesDto {
  @IsString()
  @IsOptional()
  entrancePhoto?: string;

  @IsString()
  @IsOptional()
  logo?: string;

  @IsString()
  @IsOptional()
  layoutMap?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  additionalImages?: string[];
}

class OperatingHoursDto {
  @IsString()
  @IsOptional()
  openingTime?: string;

  @IsString()
  @IsOptional()
  closingTime?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  operatingDays?: string[];

  @IsBoolean()
  @IsOptional()
  is24Hours?: boolean;
}

export class CreateVendorDto {
  @IsString()
  businessName: string;

  @IsString()
  @IsOptional()
  businessDescription?: string;

  @IsEnum(VendorType)
  vendorType: VendorType;

  @IsMongoId()
  stateId: string;

  @IsMongoId()
  areaId: string;

  @IsMongoId()
  @IsOptional()
  marketId?: string;

  @IsString()
  @IsOptional()
  shopNumber?: string;

  @IsString()
  @IsOptional()
  shopFloor?: string;

  @IsString()
  @IsOptional()
  shopBlock?: string;

  @IsString()
  @IsOptional()
  shopAddress?: string;

  @IsString()
  @IsOptional()
  landmark?: string;

  @IsArray()
  @IsNumber({}, { each: true })
  @IsOptional()
  coordinates?: [number, number];

  @IsObject()
  @ValidateNested()
  @Type(() => ShopImagesDto)
  @IsOptional()
  shopImages?: ShopImagesDto;

  @IsObject()
  @ValidateNested()
  @Type(() => ContactDetailsDto)
  contactDetails: ContactDetailsDto;

  @IsObject()
  @ValidateNested()
  @Type(() => BankDetailsDto)
  @IsOptional()
  bankDetails?: BankDetailsDto;

  @IsObject()
  @ValidateNested()
  @Type(() => OperatingHoursDto)
  @IsOptional()
  operatingHours?: OperatingHoursDto;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  categories?: string[];

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  tags?: string[];
}
import { IsOptional, IsString, IsEnum, IsNumber, IsMongoId, IsBoolean } from 'class-validator';
import { Type } from 'class-transformer';
import { VendorType } from '../../common/enums/vendor-type.enum';

export class FilterVendorDto {
  @IsOptional()
  @IsMongoId()
  stateId?: string;

  @IsOptional()
  @IsMongoId()
  areaId?: string;

  @IsOptional()
  @IsMongoId()
  marketId?: string;

  @IsOptional()
  @IsEnum(VendorType)
  vendorType?: VendorType;

  @IsOptional()
  @IsString()
  category?: string;

  @IsOptional()
  @IsString()
  search?: string;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  longitude?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  latitude?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  maxDistance?: number;

  @IsOptional()
  @Type(() => Boolean)
  @IsBoolean()
  isVerified?: boolean;

  @IsOptional()
  @Type(() => Boolean)
  @IsBoolean()
  isFeatured?: boolean;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  limit?: number = 20;
}
import {
  IsString,
  IsOptional,
  IsArray,
  IsNumber,
  IsMongoId,
  IsEnum,
  IsObject,
  IsBoolean,
  ValidateNested,
  IsEmail,
} from 'class-validator';
import { Type } from 'class-transformer';
import { VendorType } from '../../common/enums/vendor-type.enum';

class BankDetailsDto {
  @IsString()
  @IsOptional()
  bankName?: string;

  @IsString()
  @IsOptional()
  accountName?: string;

  @IsString()
  @IsOptional()
  accountNumber?: string;

  @IsString()
  @IsOptional()
  bankCode?: string;
}

class ContactDetailsDto {
  @IsString()
  @IsOptional()
  phone?: string;

  @IsString()
  @IsOptional()
  alternatePhone?: string;

  @IsEmail()
  @IsOptional()
  email?: string;

  @IsString()
  @IsOptional()
  whatsapp?: string;

  @IsString()
  @IsOptional()
  instagram?: string;

  @IsString()
  @IsOptional()
  facebook?: string;

  @IsString()
  @IsOptional()
  twitter?: string;

  @IsString()
  @IsOptional()
  website?: string;
}

class ShopImagesDto {
  @IsString()
  @IsOptional()
  entrancePhoto?: string;

  @IsString()
  @IsOptional()
  logo?: string;

  @IsString()
  @IsOptional()
  layoutMap?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  additionalImages?: string[];
}

class OperatingHoursDto {
  @IsString()
  @IsOptional()
  openingTime?: string;

  @IsString()
  @IsOptional()
  closingTime?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  operatingDays?: string[];

  @IsBoolean()
  @IsOptional()
  is24Hours?: boolean;
}

export class UpdateVendorDto {
  @IsString()
  @IsOptional()
  businessName?: string;

  @IsString()
  @IsOptional()
  businessDescription?: string;

  @IsEnum(VendorType)
  @IsOptional()
  vendorType?: VendorType;

  @IsMongoId()
  @IsOptional()
  stateId?: string;

  @IsMongoId()
  @IsOptional()
  areaId?: string;

  @IsMongoId()
  @IsOptional()
  marketId?: string;

  @IsString()
  @IsOptional()
  shopNumber?: string;

  @IsString()
  @IsOptional()
  shopFloor?: string;

  @IsString()
  @IsOptional()
  shopBlock?: string;

  @IsString()
  @IsOptional()
  shopAddress?: string;

  @IsString()
  @IsOptional()
  landmark?: string;

  @IsArray()
  @IsNumber({}, { each: true })
  @IsOptional()
  coordinates?: [number, number];

  @IsObject()
  @ValidateNested()
  @Type(() => ShopImagesDto)
  @IsOptional()
  shopImages?: ShopImagesDto;

  @IsObject()
  @ValidateNested()
  @Type(() => ContactDetailsDto)
  @IsOptional()
  contactDetails?: ContactDetailsDto;

  @IsObject()
  @ValidateNested()
  @Type(() => BankDetailsDto)
  @IsOptional()
  bankDetails?: BankDetailsDto;

  @IsObject()
  @ValidateNested()
  @Type(() => OperatingHoursDto)
  @IsOptional()
  operatingHours?: OperatingHoursDto;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  categories?: string[];

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  tags?: string[];

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;

  @IsBoolean()
  @IsOptional()
  isVerified?: boolean;

  @IsBoolean()
  @IsOptional()
  isFeatured?: boolean;
}
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types, Schema as MongooseSchema } from 'mongoose';
import { VendorType } from '../../common/enums/vendor-type.enum';

@Schema({ _id: false })
class BankDetails {
  @Prop()
  bankName?: string;

  @Prop()
  accountName?: string;

  @Prop()
  accountNumber?: string;

  @Prop()
  bankCode?: string;
}

@Schema({ _id: false })
class ContactDetails {
  @Prop({ required: true })
  phone: string;

  @Prop()
  alternatePhone?: string;

  @Prop()
  email?: string;

  @Prop()
  whatsapp?: string;

  @Prop()
  instagram?: string;

  @Prop()
  facebook?: string;

  @Prop()
  twitter?: string;

  @Prop()
  website?: string;
}

@Schema({ _id: false })
class ShopImages {
  @Prop()
  entrancePhoto?: string;

  @Prop()
  logo?: string;

  @Prop()
  layoutMap?: string;

  @Prop([String])
  additionalImages?: string[];
}

@Schema({ _id: false })
class OperatingHours {
  @Prop()
  openingTime?: string;

  @Prop()
  closingTime?: string;

  @Prop([String])
  operatingDays?: string[];

  @Prop({ default: false })
  is24Hours?: boolean;
}

@Schema({ timestamps: true })
export class Vendor extends Document {
  @Prop({ type: Types.ObjectId, ref: 'User', required: true })
  userId: Types.ObjectId;

  @Prop({ required: true })
  businessName: string;

  @Prop()
  businessDescription?: string;

  @Prop({ type: String, enum: VendorType, required: true })
  vendorType: VendorType;

  // Location Hierarchy
  @Prop({ type: Types.ObjectId, ref: 'State', required: true })
  stateId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Area', required: true })
  areaId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Market' })
  marketId?: Types.ObjectId;

  // Shop Details
  @Prop()
  shopNumber?: string;

  @Prop()
  shopFloor?: string;

  @Prop()
  shopBlock?: string;

  @Prop()
  shopAddress?: string;

  @Prop()
  landmark?: string;

  // ✅ Geolocation — use Object type, define properly after schema creation
  @Prop({ type: Object })
  location?: {
    type: 'Point';
    coordinates: [number, number];
  };

  // Images
  @Prop({ type: ShopImages })
  shopImages?: ShopImages;

  // Contact & Banking
  @Prop({ type: ContactDetails, required: true })
  contactDetails: ContactDetails;

  @Prop({ type: BankDetails })
  bankDetails?: BankDetails;

  // Operating Hours
  @Prop({ type: OperatingHours })
  operatingHours?: OperatingHours;

  // Categories of products sold
  @Prop([String])
  categories?: string[];

  @Prop([String])
  tags?: string[];

  // Statistics
  @Prop({ default: 0 })
  totalProducts: number;

  @Prop({ default: 0 })
  totalViews: number;

  @Prop({ default: 0 })
  searchAppearances: number;

  @Prop({ default: 0 })
  rating: number;

  @Prop({ default: 0 })
  reviewCount: number;

  // Price Range (computed from products)
  @Prop({ default: 0 })
  minProductPrice: number;

  @Prop({ default: 0 })
  maxProductPrice: number;

  // Status
  @Prop({ default: true })
  isActive: boolean;

  @Prop({ default: false })
  isVerified: boolean;

  @Prop({ default: false })
  isFeatured: boolean;

  @Prop({ default: true })
  isOpen: boolean;

  createdAt: Date;
  updatedAt: Date;
}

export const VendorSchema = SchemaFactory.createForClass(Vendor);

// ✅ Define location path AFTER schema creation — same pattern as Market schema
// This prevents auto-defaulting { type: "Point" } when no coordinates exist
VendorSchema.path('location', new MongooseSchema(
  {
    type: {
      type: String,
      enum: ['Point'],
      required: true,
    },
    coordinates: {
      type: [Number],
      required: true,
    },
  },
  { _id: false }
));

// ✅ Location is NOT required at document level
VendorSchema.path('location').required(false);

// ✅ sparse: true — skips documents where location is absent
VendorSchema.index({ location: '2dsphere' }, { sparse: true });
VendorSchema.index({ stateId: 1, areaId: 1, marketId: 1 });
VendorSchema.index({ userId: 1 });
VendorSchema.index({ vendorType: 1 });
VendorSchema.index({ categories: 1 });
VendorSchema.index({ isActive: 1, isVerified: 1 });
VendorSchema.index({ businessName: 'text', businessDescription: 'text', tags: 'text' });
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  UseGuards,
  Request,
} from '@nestjs/common';
import { VendorsService } from './vendors.service';
import { CreateVendorDto } from './dto/create-vendor.dto';
import { UpdateVendorDto } from './dto/update-vendor.dto';
import { FilterVendorDto } from './dto/filter-vendor.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { Role } from '../common/enums/role.enum';

@Controller('vendors')
export class VendorsController {
  constructor(private vendorsService: VendorsService) {}

  @Get()
  findAll(@Query() filterDto: FilterVendorDto) {
    return this.vendorsService.findAll(filterDto);
  }

  @Get('my-profile')
  @UseGuards(JwtAuthGuard)
  getMyProfile(@Request() req) {
    return this.vendorsService.findByUser(req.user.id);
  }

  @Get('market/:marketId')
  findByMarket(@Param('marketId') marketId: string) {
    return this.vendorsService.findByMarket(marketId);
  }

  @Get('nearby')
  findNearby(
    @Query('longitude') longitude: number,
    @Query('latitude') latitude: number,
    @Query('distance') distance?: number,
  ) {
    return this.vendorsService.findNearby(longitude, latitude, distance);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.vendorsService.findById(id);
  }

  @Post()
  @UseGuards(JwtAuthGuard)
  create(@Body() dto: CreateVendorDto, @Request() req) {
    return this.vendorsService.create(dto, req.user.id);
  }

  @Put(':id')
  @UseGuards(JwtAuthGuard)
  update(@Param('id') id: string, @Body() dto: UpdateVendorDto, @Request() req) {
    return this.vendorsService.update(id, dto, req.user.id);
  }

  @Put(':id/admin')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  adminUpdate(@Param('id') id: string, @Body() dto: UpdateVendorDto) {
    return this.vendorsService.adminUpdate(id, dto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard)
  delete(@Param('id') id: string, @Request() req) {
    return this.vendorsService.delete(id, req.user.id);
  }
}
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { VendorsService } from './vendors.service';
import { VendorsController } from './vendors.controller';
import { Vendor, VendorSchema } from './schemas/vendor.schema';
import { MarketsModule } from '../markets/markets.module';
import { UsersModule } from '../users/users.module';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: Vendor.name, schema: VendorSchema }]),
    MarketsModule,
    UsersModule,
  ],
  controllers: [VendorsController],
  providers: [VendorsService],
  exports: [VendorsService],
})
export class VendorsModule {}
import { Injectable, NotFoundException, ForbiddenException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Vendor } from './schemas/vendor.schema';
import { CreateVendorDto } from './dto/create-vendor.dto';
import { UpdateVendorDto } from './dto/update-vendor.dto';
import { FilterVendorDto } from './dto/filter-vendor.dto';
import { MarketsService } from '../markets/markets.service';
import { UsersService } from '../users/users.service';
import { Role } from '../common/enums/role.enum';

@Injectable()
export class VendorsService {
  constructor(
    @InjectModel(Vendor.name) private vendorModel: Model<Vendor>,
    private marketsService: MarketsService,
    private usersService: UsersService,
  ) {}

  async create(dto: CreateVendorDto, userId: string): Promise<Vendor> {
    const vendorData: any = { ...dto, userId };

    // ✅ Only set location if valid coordinates are provided
    if (
      dto.coordinates &&
      Array.isArray(dto.coordinates) &&
      dto.coordinates.length === 2 &&
      typeof dto.coordinates[0] === 'number' &&
      typeof dto.coordinates[1] === 'number'
    ) {
      vendorData.location = {
        type: 'Point',
        coordinates: dto.coordinates,
      };
    }
    // ✅ Always remove coordinates from the data (it's not a schema field)
    delete vendorData.coordinates;

    // ✅ Ensure no partial location object exists
    if (
      vendorData.location &&
      (!vendorData.location.coordinates ||
        !Array.isArray(vendorData.location.coordinates) ||
        vendorData.location.coordinates.length !== 2)
    ) {
      delete vendorData.location;
    }

    const vendor = await this.vendorModel.create(vendorData);

    // Update user role to vendor
    await this.usersService.update(userId, { role: Role.VENDOR });
    await this.usersService.updateVendorProfile(userId, vendor._id.toString());

    // Increment market shop count if applicable
    if (dto.marketId) {
      await this.marketsService.incrementShopCount(dto.marketId);
    }

    return vendor;
  }

  async findAll(filterDto: FilterVendorDto): Promise<{
    vendors: Vendor[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const {
      page = 1,
      limit = 20,
      stateId,
      areaId,
      marketId,
      vendorType,
      category,
      search,
      longitude,
      latitude,
      maxDistance,
      isVerified,
      isFeatured,
    } = filterDto;

    const query: Record<string, any> = { isActive: true };

    if (stateId) query.stateId = new Types.ObjectId(stateId);
    if (areaId) query.areaId = new Types.ObjectId(areaId);
    if (marketId) query.marketId = new Types.ObjectId(marketId);
    if (vendorType) query.vendorType = vendorType;
    if (category) query.categories = { $in: [category] };
    if (isVerified !== undefined) query.isVerified = isVerified;
    if (isFeatured !== undefined) query.isFeatured = isFeatured;

    if (search) {
      query.$or = [
        { businessName: { $regex: search, $options: 'i' } },
        { businessDescription: { $regex: search, $options: 'i' } },
        { tags: { $in: [new RegExp(search, 'i')] } },
      ];
    }

    if (longitude && latitude) {
      query.location = {
        $near: {
          $geometry: {
            type: 'Point',
            coordinates: [longitude, latitude],
          },
          $maxDistance: (maxDistance || 10) * 1000,
        },
      };
    }

    const skip = (page - 1) * limit;
    const [vendors, total] = await Promise.all([
      this.vendorModel
        .find(query)
        .populate('stateId', 'name code')
        .populate('areaId', 'name')
        .populate('marketId', 'name type')
        .populate('userId', 'firstName lastName email')
        .skip(skip)
        .limit(limit)
        .sort({ isFeatured: -1, rating: -1, createdAt: -1 }),
      this.vendorModel.countDocuments(query),
    ]);

    return {
      vendors,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async findById(id: string): Promise<Vendor> {
    const vendor = await this.vendorModel
      .findById(id)
      .populate('stateId', 'name code')
      .populate('areaId', 'name localGovernment')
      .populate('marketId', 'name type address entrancePhoto layoutMap')
      .populate('userId', 'firstName lastName email phone');

    if (!vendor) {
      throw new NotFoundException('Vendor not found');
    }

    await this.vendorModel.findByIdAndUpdate(id, { $inc: { totalViews: 1 } });

    return vendor;
  }

  async findByUser(userId: string): Promise<Vendor> {
    const vendor = await this.vendorModel
      .findOne({ userId })
      .populate('stateId', 'name code')
      .populate('areaId', 'name')
      .populate('marketId', 'name type');

    if (!vendor) {
      throw new NotFoundException('Vendor profile not found');
    }
    return vendor;
  }

  async findByMarket(marketId: string): Promise<Vendor[]> {
    return this.vendorModel
      .find({ marketId: new Types.ObjectId(marketId), isActive: true })
      .populate('userId', 'firstName lastName')
      .sort({ shopNumber: 1 });
  }

  async findNearby(
    longitude: number,
    latitude: number,
    maxDistanceKm: number = 5,
  ): Promise<Vendor[]> {
    return this.vendorModel.find({
      location: {
        $near: {
          $geometry: {
            type: 'Point',
            coordinates: [longitude, latitude],
          },
          $maxDistance: maxDistanceKm * 1000,
        },
      },
      isActive: true,
    })
    .populate('stateId', 'name code')
    .populate('areaId', 'name')
    .populate('marketId', 'name type');
  }

  async update(id: string, dto: UpdateVendorDto, userId: string): Promise<Vendor> {
    const vendor = await this.vendorModel.findById(id);
    if (!vendor) {
      throw new NotFoundException('Vendor not found');
    }

    if (vendor.userId.toString() !== userId) {
      throw new ForbiddenException('You can only update your own vendor profile');
    }

    const updateData: any = { ...dto };

    // ✅ Only set location if valid coordinates provided
    if (
      dto.coordinates &&
      Array.isArray(dto.coordinates) &&
      dto.coordinates.length === 2 &&
      typeof dto.coordinates[0] === 'number' &&
      typeof dto.coordinates[1] === 'number'
    ) {
      updateData.location = {
        type: 'Point',
        coordinates: dto.coordinates,
      };
    }
    delete updateData.coordinates;

    // ✅ Ensure no partial location object
    if (
      updateData.location &&
      (!updateData.location.coordinates ||
        !Array.isArray(updateData.location.coordinates) ||
        updateData.location.coordinates.length !== 2)
    ) {
      delete updateData.location;
    }

    const updatedVendor = await this.vendorModel
      .findByIdAndUpdate(id, updateData, { new: true })
      .populate('stateId', 'name code')
      .populate('areaId', 'name')
      .populate('marketId', 'name type');

    if (!updatedVendor) {
      throw new NotFoundException('Vendor not found after update');
    }

    return updatedVendor;
  }

  async adminUpdate(id: string, dto: UpdateVendorDto): Promise<Vendor> {
    const updateData: any = { ...dto };

    // ✅ Only set location if valid coordinates provided
    if (
      dto.coordinates &&
      Array.isArray(dto.coordinates) &&
      dto.coordinates.length === 2 &&
      typeof dto.coordinates[0] === 'number' &&
      typeof dto.coordinates[1] === 'number'
    ) {
      updateData.location = {
        type: 'Point',
        coordinates: dto.coordinates,
      };
    }
    delete updateData.coordinates;

    // ✅ Ensure no partial location object
    if (
      updateData.location &&
      (!updateData.location.coordinates ||
        !Array.isArray(updateData.location.coordinates) ||
        updateData.location.coordinates.length !== 2)
    ) {
      delete updateData.location;
    }

    const vendor = await this.vendorModel
      .findByIdAndUpdate(id, updateData, { new: true })
      .populate('stateId', 'name code')
      .populate('areaId', 'name')
      .populate('marketId', 'name type');

    if (!vendor) {
      throw new NotFoundException('Vendor not found');
    }
    return vendor;
  }

  async incrementProductCount(id: string): Promise<void> {
    await this.vendorModel.findByIdAndUpdate(id, { $inc: { totalProducts: 1 } });
  }

  async decrementProductCount(id: string): Promise<void> {
    await this.vendorModel.findByIdAndUpdate(id, { $inc: { totalProducts: -1 } });
  }

  async delete(id: string, userId: string): Promise<void> {
    const vendor = await this.vendorModel.findById(id);
    if (!vendor) {
      throw new NotFoundException('Vendor not found');
    }

    if (vendor.userId.toString() !== userId) {
      throw new ForbiddenException('You can only delete your own vendor profile');
    }

    if (vendor.marketId) {
      await this.marketsService.decrementShopCount(vendor.marketId.toString());
    }

    await this.vendorModel.deleteOne({ _id: id });
  }

  async updatePriceRange(vendorId: string, minPrice: number, maxPrice: number): Promise<void> {
    await this.vendorModel.findByIdAndUpdate(vendorId, {
      minProductPrice: minPrice || 0,
      maxProductPrice: maxPrice || 0,
    });
  }
}
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { MongooseModule } from '@nestjs/mongoose';
import { AuthModule } from './auth/auth.module';
import { UsersModule } from './users/users.module';
import { StatesModule } from './states/states.module';
import { AreasModule } from './areas/areas.module';
import { MarketsModule } from './markets/markets.module';
import { VendorsModule } from './vendors/vendors.module';
import { ProductsModule } from './products/products.module';
import { CatalogModule } from './catalog/catalog.module';
import { SearchModule } from './search/search.module';
import { UploadModule } from './upload/upload.module';
import { AdminModule } from './admin/admin.module';
import { FavoritesModule } from './favorites/favorites.module';
import { ReviewsModule } from './reviews/reviews.module';
import { DatabaseModule } from './database/database.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: '.env',
    }),
    MongooseModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => ({
        uri: configService.get<string>('MONGODB_URI'),
      }),
      inject: [ConfigService],
    }),
    AuthModule,
    UsersModule,
    StatesModule,
    AreasModule,
    MarketsModule,
    VendorsModule,
    ProductsModule,
    CatalogModule,
    SearchModule,
    UploadModule,
    AdminModule,
    FavoritesModule,
    ReviewsModule,
    DatabaseModule,
  ],
})
export class AppModule {}

this is from app.service.ts

import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { AppModule } from './app.module';
import { HttpExceptionFilter } from './common/filters/http-exception.filter';
import { TransformInterceptor } from './common/interceptors/transform.interceptor';

let cachedApp: any;

async function createApp() {
  const app = await NestFactory.create(AppModule);

  // CORS
  app.enableCors({
    origin: true,
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS',
    allowedHeaders: 'Content-Type, Accept, Authorization',
    credentials: true,
  });

  // Global prefix
  app.setGlobalPrefix('api/v1');

  // Validation
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
      transformOptions: {
        enableImplicitConversion: true,
      },
    }),
  );

  // Global filters
  app.useGlobalFilters(new HttpExceptionFilter());

  // Global interceptors
  app.useGlobalInterceptors(new TransformInterceptor());

  await app.init();
  return app;
}

// Vercel Serverless Handler
export default async function handler(req: any, res: any) {
  if (!cachedApp) {
    cachedApp = await createApp();
  }

  const instance = cachedApp.getHttpAdapter().getInstance();
  return instance(req, res);
}

// Local Development
if (process.env.NODE_ENV !== 'production') {
  createApp().then(async (app) => {
    await app.listen(4000);
    console.log('🚀 SureShops API running on http://localhost:4000/api/v1');
    console.log('📚 Health check: http://localhost:4000/api/v1/auth/health');
  });
}

and this is from main.ts

import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { AppModule } from './app.module';
import { HttpExceptionFilter } from './common/filters/http-exception.filter';
import { TransformInterceptor } from './common/interceptors/transform.interceptor';

let cachedApp: any;

async function createApp() {
  const app = await NestFactory.create(AppModule);

  // CORS
  app.enableCors({
    origin: true,
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS',
    allowedHeaders: 'Content-Type, Accept, Authorization',
    credentials: true,
  });

  // Global prefix
  app.setGlobalPrefix('api/v1');

  // Validation
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
      transformOptions: {
        enableImplicitConversion: true,
      },
    }),
  );

  // Global filters
  app.useGlobalFilters(new HttpExceptionFilter());

  // Global interceptors
  app.useGlobalInterceptors(new TransformInterceptor());

  await app.init();
  return app;
}

// Vercel Serverless Handler
export default async function handler(req: any, res: any) {
  if (!cachedApp) {
    cachedApp = await createApp();
  }

  const instance = cachedApp.getHttpAdapter().getInstance();
  return instance(req, res);
}

// Local Development
if (process.env.NODE_ENV !== 'production') {
  createApp().then(async (app) => {
    await app.listen(4000);
    console.log('🚀 SureShops API running on http://localhost:4000/api/v1');
    console.log('📚 Health check: http://localhost:4000/api/v1/auth/health');
  });
}