import { IsString, IsOptional, IsArray, IsNumber, IsMongoId } from 'class-validator';

export class CreateAreaDto {
  @IsString()
  name: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsMongoId()
  stateId: string;

  @IsString()
  @IsOptional()
  localGovernment?: string;

  @IsArray()
  @IsNumber({}, { each: true })
  @IsOptional()
  coordinates?: [number, number];

  @IsString()
  @IsOptional()
  postalCode?: string;
}
import { IsString, IsOptional, IsArray, IsNumber, IsBoolean } from 'class-validator';

export class UpdateAreaDto {
  @IsString()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsString()
  @IsOptional()
  localGovernment?: string;

  @IsArray()
  @IsNumber({}, { each: true })
  @IsOptional()
  coordinates?: [number, number];

  @IsString()
  @IsOptional()
  postalCode?: string;

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;
}
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  UseGuards,
} from '@nestjs/common';
import { AreasService } from './areas.service';
import { CreateAreaDto } from './dto/create-area.dto';
import { UpdateAreaDto } from './dto/update-area.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { Role } from '../common/enums/role.enum';

@Controller('areas')
export class AreasController {
  constructor(private areasService: AreasService) {}

  @Get()
  findAll() {
    return this.areasService.findAll();
  }

  @Get('state/:stateId')
  findByState(@Param('stateId') stateId: string) {
    return this.areasService.findByState(stateId);
  }

  @Get('nearby')
  findNearby(
    @Query('longitude') longitude: number,
    @Query('latitude') latitude: number,
    @Query('distance') distance?: number,
  ) {
    return this.areasService.findNearby(longitude, latitude, distance);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.areasService.findById(id);
  }

  @Post()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  create(@Body() dto: CreateAreaDto) {
    return this.areasService.create(dto);
  }

  @Put(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  update(@Param('id') id: string, @Body() dto: UpdateAreaDto) {
    return this.areasService.update(id, dto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.SUPER_ADMIN)
  delete(@Param('id') id: string) {
    return this.areasService.delete(id);
  }
}
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { AreasService } from './areas.service';
import { AreasController } from './areas.controller';
import { Area, AreaSchema } from './schemas/area.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: Area.name, schema: AreaSchema }]),
  ],
  controllers: [AreasController],
  providers: [AreasService],
  exports: [AreasService],
})
export class AreasModule {}
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Area } from './schemas/area.schema';
import { CreateAreaDto } from './dto/create-area.dto';
import { UpdateAreaDto } from './dto/update-area.dto';

@Injectable()
export class AreasService {
  constructor(@InjectModel(Area.name) private areaModel: Model<Area>) {}

  async create(dto: CreateAreaDto): Promise<Area> {
    const areaData: any = { ...dto };
    if (dto.coordinates) {
      areaData.location = {
        type: 'Point',
        coordinates: dto.coordinates,
      };
    }
    delete areaData.coordinates;
    return this.areaModel.create(areaData);
  }

  async findAll(): Promise<Area[]> {
    return this.areaModel
      .find({ isActive: true })
      .populate('stateId', 'name code')
      .sort({ name: 1 });
  }

  async findByState(stateId: string): Promise<Area[]> {
    return this.areaModel
      .find({ stateId, isActive: true })
      .populate('stateId', 'name code')
      .sort({ name: 1 });
  }

  async findById(id: string): Promise<Area> {
    const area = await this.areaModel
      .findById(id)
      .populate('stateId', 'name code');
    if (!area) {
      throw new NotFoundException('Area not found');
    }
    return area;
  }

  async findNearby(
    longitude: number,
    latitude: number,
    maxDistanceKm: number = 10,
  ): Promise<Area[]> {
    return this.areaModel.find({
      location: {
        $near: {
          $geometry: {
            type: 'Point',
            coordinates: [longitude, latitude],
          },
          $maxDistance: maxDistanceKm * 1000,
        },
      },
      isActive: true,
    }).populate('stateId', 'name code');
  }

  async update(id: string, dto: UpdateAreaDto): Promise<Area> {
    const updateData: any = { ...dto };
    if (dto.coordinates) {
      updateData.location = {
        type: 'Point',
        coordinates: dto.coordinates,
      };
    }
    delete updateData.coordinates;

    const area = await this.areaModel
      .findByIdAndUpdate(id, updateData, { new: true })
      .populate('stateId', 'name code');
    if (!area) {
      throw new NotFoundException('Area not found');
    }
    return area;
  }

  async delete(id: string): Promise<void> {
    const result = await this.areaModel.deleteOne({ _id: id });
    if (result.deletedCount === 0) {
      throw new NotFoundException('Area not found');
    }
  }
}
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema({ timestamps: true })
export class Area extends Document {
  @Prop({ required: true })
  name: string;

  @Prop()
  description?: string;

  @Prop({ type: Types.ObjectId, ref: 'State', required: true })
  stateId: Types.ObjectId;

  @Prop()
  localGovernment?: string;

  @Prop({ type: { type: String, enum: ['Point'], default: 'Point' }, coordinates: [Number] })
  location?: {
    type: 'Point';
    coordinates: [number, number];
  };

  @Prop()
  postalCode?: string;

  @Prop({ default: true })
  isActive: boolean;
}

export const AreaSchema = SchemaFactory.createForClass(Area);

AreaSchema.index({ location: '2dsphere' });
AreaSchema.index({ stateId: 1 });
AreaSchema.index({ name: 1, stateId: 1 });
import { SetMetadata } from '@nestjs/common';
import { Role } from '../../common/enums/role.enum';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: Role[]) => SetMetadata(ROLES_KEY, roles);
import { IsEmail, IsString } from 'class-validator';

export class LoginDto {
  @IsEmail()
  email: string;

  @IsString()
  password: string;
}
import { IsEmail, IsString, MinLength, IsOptional, IsEnum } from 'class-validator';
import { Role } from '../../common/enums/role.enum';

export class RegisterDto {
  @IsString()
  @MinLength(2)
  firstName: string;

  @IsString()
  @MinLength(2)
  lastName: string;

  @IsEmail()
  email: string;

  @IsString()
  @MinLength(6)
  password: string;

  @IsString()
  phone: string;

  @IsEnum(Role)
  @IsOptional()
  role?: Role = Role.USER;
}
import { Injectable, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {
  canActivate(context: ExecutionContext) {
    return super.canActivate(context);
  }

  handleRequest(err: any, user: any, info: any) {
    if (err || !user) {
      throw err || new UnauthorizedException('Authentication required');
    }
    return user;
  }
}
import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Role } from '../../common/enums/role.enum';
import { ROLES_KEY } from '../decorators/roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<Role[]>(ROLES_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    if (!requiredRoles) {
      return true;
    }

    const { user } = context.switchToHttp().getRequest();
    return requiredRoles.some((role) => user.role === role);
  }
}
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
import { UsersService } from '../../users/users.service';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(
    configService: ConfigService,
    private usersService: UsersService,
  ) {
    const jwtSecret = configService.get<string>('JWT_SECRET');
    if (!jwtSecret) {
      throw new Error('JWT_SECRET is not defined');
    }
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: jwtSecret,
    });
  }

  async validate(payload: any) {
    const user = await this.usersService.findById(payload.sub);
    if (!user) {
      throw new UnauthorizedException('User not found');
    }
    return {
      id: user._id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      role: user.role,
    };
  }
}
import {
  Controller,
  Post,
  Body,
  Get,
  UseGuards,
  Request,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';
import { JwtAuthGuard } from './guards/jwt-auth.guard';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Post('register')
  register(@Body() dto: RegisterDto) {
    return this.authService.register(dto);
  }

  @Post('login')
  login(@Body() dto: LoginDto) {
    return this.authService.login(dto);
  }

  @UseGuards(JwtAuthGuard)
  @Get('me')
  getMe(@Request() req) {
    return req.user;
  }

  @Get('health')
  health() {
    return { status: 'ok', timestamp: new Date().toISOString() };
  }
}
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { JwtStrategy } from './strategies/jwt.strategy';
import { UsersModule } from '../users/users.module';

@Module({
  imports: [
    UsersModule,
    PassportModule.register({ defaultStrategy: 'jwt' }),
    ConfigModule,
    JwtModule.registerAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => ({
        secret: configService.get<string>('JWT_SECRET'),
        signOptions: {
          expiresIn: configService.get<string>('JWT_EXPIRES_IN') as any || '7d',
        },
      }),
      inject: [ConfigService],
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy],
  exports: [JwtStrategy, PassportModule, AuthService],
})
export class AuthModule {}
import {
  Injectable,
  UnauthorizedException,
  ConflictException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import * as bcrypt from 'bcryptjs';
import { UsersService } from '../users/users.service';
import { RegisterDto } from './dto/register.dto';
import { LoginDto } from './dto/login.dto';

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService,
    private configService: ConfigService,
  ) {}

  async register(dto: RegisterDto) {
    const exists = await this.usersService.findByEmail(dto.email);
    if (exists) {
      throw new ConflictException('Email already exists');
    }

    const hashedPassword = await bcrypt.hash(dto.password, 12);
    const user = await this.usersService.create({
      ...dto,
      password: hashedPassword,
    });

    const token = this.generateToken(user);

    return {
      access_token: token,
      user: {
        id: user._id,
        firstName: user.firstName,
        lastName: user.lastName,
        email: user.email,
        role: user.role,
      },
    };
  }

  async login(dto: LoginDto) {
    const user = await this.usersService.findByEmail(dto.email);
    if (!user) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const isValid = await bcrypt.compare(dto.password, user.password);
    if (!isValid) {
      throw new UnauthorizedException('Invalid credentials');
    }

    const token = this.generateToken(user);

    return {
      access_token: token,
      user: {
        id: user._id,
        firstName: user.firstName,
        lastName: user.lastName,
        email: user.email,
        role: user.role,
      },
    };
  }

  private generateToken(user: any): string {
    return this.jwtService.sign(
      {
        sub: user._id.toString(),
        email: user.email,
        role: user.role,
      },
      { secret: this.configService.get<string>('JWT_SECRET') },
    );
  }
}
import { IsString, IsOptional, IsArray, IsObject } from 'class-validator';

export class CreateCatalogItemDto {
  @IsString()
  name: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsString()
  @IsOptional()
  sku?: string;

  @IsString()
  @IsOptional()
  barcode?: string;

  @IsString()
  @IsOptional()
  brand?: string;

  @IsString()
  category: string;

  @IsString()
  @IsOptional()
  subcategory?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  tags?: string[];

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  images?: string[];

  @IsObject()
  @IsOptional()
  specifications?: Record<string, any>;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  alternateNames?: string[];
}
import { IsOptional, IsString, IsNumber } from 'class-validator';
import { Type } from 'class-transformer';

export class FilterCatalogDto {
  @IsOptional()
  @IsString()
  search?: string;

  @IsOptional()
  @IsString()
  category?: string;

  @IsOptional()
  @IsString()
  subcategory?: string;

  @IsOptional()
  @IsString()
  brand?: string;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  limit?: number = 20;
}
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ timestamps: true })
export class CatalogItem extends Document {
  @Prop({ required: true })
  name: string;

  @Prop()
  description?: string;

  @Prop({ unique: true, sparse: true })
  sku?: string;

  @Prop({ unique: true, sparse: true })
  barcode?: string;

  @Prop()
  brand?: string;

  @Prop({ required: true })
  category: string;

  @Prop()
  subcategory?: string;

  @Prop([String])
  tags?: string[];

  @Prop([String])
  images?: string[];

  @Prop({ type: Object })
  specifications?: Record<string, any>;

  @Prop([String])
  alternateNames?: string[];

  @Prop({ default: 0 })
  totalListings: number;

  @Prop({ default: 0 })
  lowestPrice: number;

  @Prop({ default: 0 })
  highestPrice: number;

  @Prop({ default: 0 })
  averagePrice: number;

  @Prop({ default: true })
  isActive: boolean;
}

export const CatalogItemSchema = SchemaFactory.createForClass(CatalogItem);

CatalogItemSchema.index({ name: 'text', description: 'text', brand: 'text', tags: 'text' });
CatalogItemSchema.index({ category: 1, subcategory: 1 });
CatalogItemSchema.index({ sku: 1 });
CatalogItemSchema.index({ barcode: 1 });
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Query,
  UseGuards,
} from '@nestjs/common';
import { CatalogService } from './catalog.service';
import { CreateCatalogItemDto } from './dto/create-catalog-item.dto';
import { FilterCatalogDto } from './dto/filter-catalog.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { Role } from '../common/enums/role.enum';

@Controller('catalog')
export class CatalogController {
  constructor(private catalogService: CatalogService) {}

  @Get()
  findAll(@Query() filterDto: FilterCatalogDto) {
    return this.catalogService.findAll(filterDto);
  }

  @Get('categories')
  getCategories() {
    return this.catalogService.getCategories();
  }

  @Get('brands')
  getBrands(@Query('category') category?: string) {
    return this.catalogService.getBrands(category);
  }

  @Get('search')
  searchByName(@Query('name') name: string) {
    return this.catalogService.searchByName(name);
  }

  @Get('sku/:sku')
  findBySku(@Param('sku') sku: string) {
    return this.catalogService.findBySku(sku);
  }

  @Get('barcode/:barcode')
  findByBarcode(@Param('barcode') barcode: string) {
    return this.catalogService.findByBarcode(barcode);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.catalogService.findById(id);
  }

  @Post()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  create(@Body() dto: CreateCatalogItemDto) {
    return this.catalogService.create(dto);
  }
}
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CatalogController } from './catalog.controller';
import { CatalogService } from './catalog.service';
import { CatalogItem, CatalogItemSchema } from './schemas/catalog-item.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: CatalogItem.name, schema: CatalogItemSchema },
    ]),
  ],
  controllers: [CatalogController],
  providers: [CatalogService],
  exports: [CatalogService],
})
export class CatalogModule {}
import { Injectable, NotFoundException, ConflictException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CatalogItem } from './schemas/catalog-item.schema';
import { CreateCatalogItemDto } from './dto/create-catalog-item.dto';
import { FilterCatalogDto } from './dto/filter-catalog.dto';

@Injectable()
export class CatalogService {
  constructor(
    @InjectModel(CatalogItem.name) private catalogModel: Model<CatalogItem>,
  ) {}

  async create(dto: CreateCatalogItemDto): Promise<CatalogItem> {
    // Check for duplicates
    const exists = await this.catalogModel.findOne({
      $or: [
        { sku: dto.sku },
        { barcode: dto.barcode },
        { name: { $regex: `^${dto.name}$`, $options: 'i' } },
      ],
    });

    if (exists) {
      throw new ConflictException('Catalog item already exists');
    }

    return this.catalogModel.create(dto);
  }

  async findAll(filterDto: FilterCatalogDto): Promise<{
    items: CatalogItem[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const { page = 1, limit = 20, search, category, subcategory, brand } = filterDto;
    const skip = (page - 1) * limit;

    const query: Record<string, any> = { isActive: true };

    if (search) {
      query.$or = [
        { name: { $regex: search, $options: 'i' } },
        { description: { $regex: search, $options: 'i' } },
        { brand: { $regex: search, $options: 'i' } },
        { tags: { $in: [new RegExp(search, 'i')] } },
        { alternateNames: { $in: [new RegExp(search, 'i')] } },
      ];
    }

    if (category) query.category = category;
    if (subcategory) query.subcategory = subcategory;
    if (brand) query.brand = { $regex: brand, $options: 'i' };

    const [items, total] = await Promise.all([
      this.catalogModel
        .find(query)
        .skip(skip)
        .limit(limit)
        .sort({ totalListings: -1, name: 1 }),
      this.catalogModel.countDocuments(query),
    ]);

    return {
      items,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async findById(id: string): Promise<CatalogItem> {
    const item = await this.catalogModel.findById(id);
    if (!item) {
      throw new NotFoundException('Catalog item not found');
    }
    return item;
  }

  async findBySku(sku: string): Promise<CatalogItem | null> {
    return this.catalogModel.findOne({ sku });
  }

  async findByBarcode(barcode: string): Promise<CatalogItem | null> {
    return this.catalogModel.findOne({ barcode });
  }

  async searchByName(name: string): Promise<CatalogItem[]> {
    return this.catalogModel.find({
      $or: [
        { name: { $regex: name, $options: 'i' } },
        { alternateNames: { $in: [new RegExp(name, 'i')] } },
      ],
      isActive: true,
    }).limit(10);
  }

  async updatePriceStats(catalogItemId: string, prices: number[]): Promise<void> {
    if (prices.length === 0) return;

    const lowestPrice = Math.min(...prices);
    const highestPrice = Math.max(...prices);
    const averagePrice = prices.reduce((a, b) => a + b, 0) / prices.length;

    await this.catalogModel.findByIdAndUpdate(catalogItemId, {
      lowestPrice,
      highestPrice,
      averagePrice: Math.round(averagePrice * 100) / 100,
      totalListings: prices.length,
    });
  }

  async getCategories(): Promise<{ category: string; count: number }[]> {
    return this.catalogModel.aggregate([
      { $match: { isActive: true } },
      {
        $group: {
          _id: '$category',
          count: { $sum: 1 },
        },
      },
      { $sort: { count: -1 } },
      {
        $project: {
          category: '$_id',
          count: 1,
          _id: 0,
        },
      },
    ]);
  }

  async getBrands(category?: string): Promise<{ brand: string; count: number }[]> {
    const match: Record<string, any> = { isActive: true, brand: { $exists: true, $ne: null } };
    if (category) match.category = category;

    return this.catalogModel.aggregate([
      { $match: match },
      {
        $group: {
          _id: '$brand',
          count: { $sum: 1 },
        },
      },
      { $sort: { count: -1 } },
      { $limit: 50 },
      {
        $project: {
          brand: '$_id',
          count: 1,
          _id: 0,
        },
      },
    ]);
  }
}
export enum MarketType {
  TRADITIONAL_MARKET = 'traditional_market',
  SHOPPING_MALL = 'shopping_mall',
  PLAZA = 'plaza',
  SHOPPING_COMPLEX = 'shopping_complex',
  STREET_MARKET = 'street_market',
}
export enum ProductStatus {
  DRAFT = 'draft',
  PENDING = 'pending',
  APPROVED = 'approved',
  REJECTED = 'rejected',
  OUT_OF_STOCK = 'out_of_stock',
  DISCONTINUED = 'discontinued',
}

export enum ProductType {
  SALE = 'sale',
  LEASE = 'lease',
  RENT = 'rent',
  SERVICE = 'service',
}
export enum Role {
  USER = 'user',
  VENDOR = 'vendor',
  ADMIN = 'admin',
  SUPER_ADMIN = 'super_admin',
}
export enum VendorType {
  MARKET_SHOP = 'market_shop',
  MALL_SHOP = 'mall_shop',
  HOME_BASED = 'home_based',
  STREET_SHOP = 'street_shop',
  ONLINE_ONLY = 'online_only',
}
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
} from '@nestjs/common';
import { Request, Response } from 'express';

@Catch()
export class HttpExceptionFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    let status = HttpStatus.INTERNAL_SERVER_ERROR;
    let message = 'Internal server error';
    let errors: any = null;

    if (exception instanceof HttpException) {
      status = exception.getStatus();
      const exceptionResponse = exception.getResponse();

      if (typeof exceptionResponse === 'string') {
        message = exceptionResponse;
      } else if (typeof exceptionResponse === 'object') {
        const responseObj = exceptionResponse as any;
        message = responseObj.message || message;
        errors = responseObj.errors || null;
      }
    } else if (exception instanceof Error) {
      message = exception.message;
    }

    response.status(status).json({
      success: false,
      statusCode: status,
      message: Array.isArray(message) ? message[0] : message,
      errors: errors,
      timestamp: new Date().toISOString(),
      path: request.url,
    });
  }
}
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

export interface Response<T> {
  success: boolean;
  data: T;
  message?: string;
  timestamp: string;
}

@Injectable()
export class TransformInterceptor<T>
  implements NestInterceptor<T, Response<T>>
{
  intercept(
    context: ExecutionContext,
    next: CallHandler,
  ): Observable<Response<T>> {
    return next.handle().pipe(
      map((data) => ({
        success: true,
        data: data,
        message: 'Operation successful',
        timestamp: new Date().toISOString(),
      })),
    );
  }
}
export interface GeoLocation {
  type: 'Point';
  coordinates: [number, number]; // [longitude, latitude]
}

export interface Address {
  street?: string;
  landmark?: string;
  city: string;
  state: string;
  country: string;
  postalCode?: string;
}

export interface BankDetails {
  bankName: string;
  accountName: string;
  accountNumber: string;
  bankCode?: string;
}

export interface ContactDetails {
  phone: string;
  alternatePhone?: string;
  email?: string;
  whatsapp?: string;
  instagram?: string;
  facebook?: string;
  twitter?: string;
  website?: string;
}

export interface ShopImages {
  entrancePhoto?: string;
  logo?: string;
  layoutMap?: string;
  additionalImages?: string[];
}
import {
  IsString,
  IsOptional,
  IsArray,
  IsNumber,
  IsMongoId,
  IsEnum,
  IsEmail,
} from 'class-validator';
import { MarketType } from '../../common/enums/market-type.enum';

export class CreateMarketDto {
  @IsString()
  name: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsEnum(MarketType)
  type: MarketType;

  @IsMongoId()
  stateId: string;

  @IsMongoId()
  areaId: string;

  @IsString()
  @IsOptional()
  address?: string;

  @IsString()
  @IsOptional()
  landmark?: string;

  @IsArray()
  @IsNumber({}, { each: true })
  @IsOptional()
  coordinates?: [number, number];

  @IsString()
  @IsOptional()
  entrancePhoto?: string;

  @IsString()
  @IsOptional()
  layoutMap?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  additionalPhotos?: string[];

  @IsString()
  @IsOptional()
  openingTime?: string;

  @IsString()
  @IsOptional()
  closingTime?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  operatingDays?: string[];

  @IsString()
  @IsOptional()
  contactPhone?: string;

  @IsEmail()
  @IsOptional()
  contactEmail?: string;
}
import { IsOptional, IsString, IsEnum, IsNumber, IsMongoId } from 'class-validator';
import { Type } from 'class-transformer';
import { MarketType } from '../../common/enums/market-type.enum';

export class FilterMarketDto {
  @IsOptional()
  @IsMongoId()
  stateId?: string;

  @IsOptional()
  @IsMongoId()
  areaId?: string;

  @IsOptional()
  @IsEnum(MarketType)
  type?: MarketType;

  @IsOptional()
  @IsString()
  search?: string;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  longitude?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  latitude?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  maxDistance?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  limit?: number = 20;
}
import {
  IsString,
  IsOptional,
  IsArray,
  IsNumber,
  IsEnum,
  IsEmail,
  IsBoolean,
} from 'class-validator';
import { MarketType } from '../../common/enums/market-type.enum';

export class UpdateMarketDto {
  @IsString()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsEnum(MarketType)
  @IsOptional()
  type?: MarketType;

  @IsString()
  @IsOptional()
  address?: string;

  @IsString()
  @IsOptional()
  landmark?: string;

  @IsArray()
  @IsNumber({}, { each: true })
  @IsOptional()
  coordinates?: [number, number];

  @IsString()
  @IsOptional()
  entrancePhoto?: string;

  @IsString()
  @IsOptional()
  layoutMap?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  additionalPhotos?: string[];

  @IsString()
  @IsOptional()
  openingTime?: string;

  @IsString()
  @IsOptional()
  closingTime?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  operatingDays?: string[];

  @IsString()
  @IsOptional()
  contactPhone?: string;

  @IsEmail()
  @IsOptional()
  contactEmail?: string;

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;

  @IsBoolean()
  @IsOptional()
  isVerified?: boolean;
}
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { MarketType } from '../../common/enums/market-type.enum';

@Schema({ timestamps: true })
export class Market extends Document {
  @Prop({ required: true })
  name: string;

  @Prop()
  description?: string;

  @Prop({ type: String, enum: MarketType, required: true })
  type: MarketType;

  @Prop({ type: Types.ObjectId, ref: 'State', required: true })
  stateId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Area', required: true })
  areaId: Types.ObjectId;

  @Prop()
  address?: string;

  @Prop()
  landmark?: string;

  @Prop({ type: { type: String, enum: ['Point'], default: 'Point' }, coordinates: [Number] })
  location?: {
    type: 'Point';
    coordinates: [number, number];
  };

  @Prop()
  entrancePhoto?: string;

  @Prop()
  layoutMap?: string;

  @Prop([String])
  additionalPhotos?: string[];

  @Prop()
  openingTime?: string;

  @Prop()
  closingTime?: string;

  @Prop([String])
  operatingDays?: string[];

  @Prop()
  contactPhone?: string;

  @Prop()
  contactEmail?: string;

  @Prop({ default: 0 })
  totalShops: number;

  @Prop({ default: true })
  isActive: boolean;

  @Prop({ default: false })
  isVerified: boolean;
}

export const MarketSchema = SchemaFactory.createForClass(Market);

MarketSchema.index({ location: '2dsphere' });
MarketSchema.index({ stateId: 1, areaId: 1 });
MarketSchema.index({ type: 1 });
MarketSchema.index({ name: 'text', address: 'text' });
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  UseGuards,
} from '@nestjs/common';
import { MarketsService } from './markets.service';
import { CreateMarketDto } from './dto/create-market.dto';
import { UpdateMarketDto } from './dto/update-market.dto';
import { FilterMarketDto } from './dto/filter-market.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { Role } from '../common/enums/role.enum';

@Controller('markets')
export class MarketsController {
  constructor(private marketsService: MarketsService) {}

  @Get()
  findAll(@Query() filterDto: FilterMarketDto) {
    return this.marketsService.findAll(filterDto);
  }

  @Get('area/:areaId')
  findByArea(@Param('areaId') areaId: string) {
    return this.marketsService.findByArea(areaId);
  }

  @Get('nearby')
  findNearby(
    @Query('longitude') longitude: number,
    @Query('latitude') latitude: number,
    @Query('distance') distance?: number,
  ) {
    return this.marketsService.findNearby(longitude, latitude, distance);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.marketsService.findById(id);
  }

  @Post()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  create(@Body() dto: CreateMarketDto) {
    return this.marketsService.create(dto);
  }

  @Put(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  update(@Param('id') id: string, @Body() dto: UpdateMarketDto) {
    return this.marketsService.update(id, dto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.SUPER_ADMIN)
  delete(@Param('id') id: string) {
    return this.marketsService.delete(id);
  }
}
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { MarketsService } from './markets.service';
import { MarketsController } from './markets.controller';
import { Market, MarketSchema } from './schemas/market.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: Market.name, schema: MarketSchema }]),
  ],
  controllers: [MarketsController],
  providers: [MarketsService],
  exports: [MarketsService],
})
export class MarketsModule {}

import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Market } from './schemas/market.schema';
import { CreateMarketDto } from './dto/create-market.dto';
import { UpdateMarketDto } from './dto/update-market.dto';
import { FilterMarketDto } from './dto/filter-market.dto';

@Injectable()
export class MarketsService {
  constructor(@InjectModel(Market.name) private marketModel: Model<Market>) {}

  async create(dto: CreateMarketDto): Promise<Market> {
    const marketData: any = { ...dto };
    if (dto.coordinates) {
      marketData.location = {
        type: 'Point',
        coordinates: dto.coordinates,
      };
    }
    delete marketData.coordinates;
    return this.marketModel.create(marketData);
  }

  async findAll(filterDto: FilterMarketDto): Promise<{
    markets: Market[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const { page = 1, limit = 20, stateId, areaId, type, search, longitude, latitude, maxDistance } = filterDto;

    // Create a query object with proper typing
    const query: Record<string, any> = { isActive: true };

    if (stateId) query.stateId = stateId;
    if (areaId) query.areaId = areaId;
    if (type) query.type = type;

    if (search) {
      query.$or = [
        { name: { $regex: search, $options: 'i' } },
        { address: { $regex: search, $options: 'i' } },
      ];
    }

    // Geospatial query
    if (longitude && latitude) {
      query.location = {
        $near: {
          $geometry: {
            type: 'Point',
            coordinates: [longitude, latitude],
          },
          $maxDistance: (maxDistance || 10) * 1000,
        },
      };
    }

    const skip = (page - 1) * limit;
    const [markets, total] = await Promise.all([
      this.marketModel
        .find(query)
        .populate('stateId', 'name code')
        .populate('areaId', 'name')
        .skip(skip)
        .limit(limit)
        .sort({ createdAt: -1 }),
      this.marketModel.countDocuments(query),
    ]);

    return {
      markets,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async findById(id: string): Promise<Market> {
    const market = await this.marketModel
      .findById(id)
      .populate('stateId', 'name code')
      .populate('areaId', 'name localGovernment');
    if (!market) {
      throw new NotFoundException('Market not found');
    }
    return market;
  }

  async findByArea(areaId: string): Promise<Market[]> {
    return this.marketModel
      .find({ areaId, isActive: true })
      .populate('stateId', 'name code')
      .populate('areaId', 'name')
      .sort({ name: 1 });
  }

  async findNearby(
    longitude: number,
    latitude: number,
    maxDistanceKm: number = 5,
  ): Promise<Market[]> {
    return this.marketModel.find({
      location: {
        $near: {
          $geometry: {
            type: 'Point',
            coordinates: [longitude, latitude],
          },
          $maxDistance: maxDistanceKm * 1000,
        },
      },
      isActive: true,
    })
    .populate('stateId', 'name code')
    .populate('areaId', 'name');
  }

  async update(id: string, dto: UpdateMarketDto): Promise<Market> {
    const updateData: any = { ...dto };
    if (dto.coordinates) {
      updateData.location = {
        type: 'Point',
        coordinates: dto.coordinates,
      };
    }
    delete updateData.coordinates;

    const market = await this.marketModel
      .findByIdAndUpdate(id, updateData, { new: true })
      .populate('stateId', 'name code')
      .populate('areaId', 'name');
    if (!market) {
      throw new NotFoundException('Market not found');
    }
    return market;
  }

  async incrementShopCount(id: string): Promise<void> {
    await this.marketModel.findByIdAndUpdate(id, { $inc: { totalShops: 1 } });
  }

  async decrementShopCount(id: string): Promise<void> {
    await this.marketModel.findByIdAndUpdate(id, { $inc: { totalShops: -1 } });
  }

  async delete(id: string): Promise<void> {
    const result = await this.marketModel.deleteOne({ _id: id });
    if (result.deletedCount === 0) {
      throw new NotFoundException('Market not found');
    }
  }
}
import {
  IsString,
  IsOptional,
  IsNumber,
  IsArray,
  IsEnum,
  IsObject,
  IsBoolean,
  Min,
} from 'class-validator';
import { ProductType } from '../../common/enums/product-status.enum';

export class CreateProductDto {
  @IsString()
  name: string;

  @IsString()
  @IsOptional()
  description?: string;

  @IsString()
  @IsOptional()
  sku?: string;

  @IsString()
  @IsOptional()
  barcode?: string;

  @IsString()
  @IsOptional()
  brand?: string;

  @IsEnum(ProductType)
  @IsOptional()
  type?: ProductType;

  @IsNumber()
  @Min(0)
  price: number;

  @IsNumber()
  @IsOptional()
  originalPrice?: number;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  images?: string[];

  @IsString()
  category: string;

  @IsString()
  @IsOptional()
  subcategory?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  tags?: string[];

  @IsNumber()
  @IsOptional()
  quantity?: number = 0;

  @IsString()
  @IsOptional()
  unit?: string;

  @IsObject()
  @IsOptional()
  specifications?: Record<string, any>;

  @IsBoolean()
  @IsOptional()
  inStock?: boolean = true;
}
import { IsOptional, IsString, IsEnum, IsNumber, IsMongoId, IsBoolean } from 'class-validator';
import { Type } from 'class-transformer';
import { ProductStatus, ProductType } from '../../common/enums/product-status.enum';

export class FilterProductDto {
  @IsOptional()
  @IsMongoId()
  vendorId?: string;

  @IsOptional()
  @IsString()
  category?: string;

  @IsOptional()
  @IsString()
  subcategory?: string;

  @IsOptional()
  @IsString()
  brand?: string;

  @IsOptional()
  @IsEnum(ProductType)
  type?: ProductType;

  @IsOptional()
  @IsEnum(ProductStatus)
  status?: ProductStatus;

  @IsOptional()
  @IsString()
  search?: string;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  minPrice?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  maxPrice?: number;

  // Location filters
  @IsOptional()
  @IsMongoId()
  stateId?: string;

  @IsOptional()
  @IsMongoId()
  areaId?: string;

  @IsOptional()
  @IsMongoId()
  marketId?: string;

  @IsOptional()
  @Type(() => Boolean)
  @IsBoolean()
  inStock?: boolean;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  limit?: number = 20;

  @IsOptional()
  @IsString()
  sortBy?: string = 'createdAt';

  @IsOptional()
  @IsString()
  sortOrder?: 'asc' | 'desc' = 'desc';
}
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { ProductStatus, ProductType } from '../../common/enums/product-status.enum';

@Schema({ timestamps: true })
export class Product extends Document {
  @Prop({ type: Types.ObjectId, ref: 'Vendor', required: true })
  vendorId: Types.ObjectId;

  // Link to master catalog (optional - for price comparison)
  @Prop({ type: Types.ObjectId, ref: 'CatalogItem' })
  catalogItemId?: Types.ObjectId;

  @Prop({ required: true })
  name: string;

  @Prop()
  description?: string;

  @Prop()
  sku?: string;

  @Prop()
  barcode?: string;

  @Prop()
  brand?: string;

  @Prop({ type: String, enum: ProductType, default: ProductType.SALE })
  type: ProductType;

  @Prop({ required: true })
  price: number;

  @Prop()
  originalPrice?: number;

  @Prop({ default: 'NGN' })
  currency: string;

  @Prop([String])
  images?: string[];

  @Prop({ required: true })
  category: string;

  @Prop()
  subcategory?: string;

  @Prop([String])
  tags?: string[];

  @Prop({ default: 0 })
  quantity: number;

  @Prop()
  unit?: string;

  @Prop({ type: Object })
  specifications?: Record<string, any>;

  @Prop({ type: String, enum: ProductStatus, default: ProductStatus.PENDING })
  status: ProductStatus;

  @Prop({ default: 0 })
  views: number;

  @Prop({ default: 0 })
  searchAppearances: number;

  @Prop({ default: true })
  isActive: boolean;

  @Prop({ default: true })
  inStock: boolean;

  @Prop()
  lastRestocked?: Date;

  // Denormalized location data for faster searches
  @Prop({ type: Types.ObjectId, ref: 'State' })
  stateId?: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Area' })
  areaId?: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Market' })
  marketId?: Types.ObjectId;

  // Geolocation from vendor
  @Prop({ type: { type: String, enum: ['Point'], default: 'Point' }, coordinates: [Number] })
  location?: {
    type: 'Point';
    coordinates: [number, number];
  };
}

export const ProductSchema = SchemaFactory.createForClass(Product);

ProductSchema.index({ location: '2dsphere' });
ProductSchema.index({ vendorId: 1 });
ProductSchema.index({ catalogItemId: 1 });
ProductSchema.index({ category: 1, subcategory: 1 });
ProductSchema.index({ status: 1, isActive: 1 });
ProductSchema.index({ stateId: 1, areaId: 1, marketId: 1 });
ProductSchema.index({ name: 'text', description: 'text', brand: 'text', tags: 'text' });
ProductSchema.index({ price: 1 });
ProductSchema.index({ sku: 1 });
ProductSchema.index({ barcode: 1 });
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  UseGuards,
  Request,
} from '@nestjs/common';
import { ProductsService } from './products.service';
import { CreateProductDto } from './dto/create-product.dto';
import { UpdateProductDto } from './dto/update-product.dto';
import { FilterProductDto } from './dto/filter-product.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { Role } from '../common/enums/role.enum';

@Controller('products')
export class ProductsController {
  constructor(private productsService: ProductsService) {}

  @Get()
  findAll(@Query() filterDto: FilterProductDto) {
    return this.productsService.findAll(filterDto);
  }

  @Get('my-products')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.VENDOR)
  getMyProducts(@Request() req) {
    return this.productsService.getMyProducts(req.user.id);
  }

  @Get('vendor/:vendorId')
  findByVendor(@Param('vendorId') vendorId: string) {
    return this.productsService.findByVendor(vendorId);
  }

  @Get('nearby')
  findNearby(
    @Query('longitude') longitude: number,
    @Query('latitude') latitude: number,
    @Query('distance') distance?: number,
    @Query('category') category?: string,
  ) {
    return this.productsService.findNearby(longitude, latitude, distance, category);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.productsService.findById(id);
  }

  @Post()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.VENDOR)
  create(@Body() dto: CreateProductDto, @Request() req) {
    return this.productsService.create(dto, req.user.id);
  }

  @Put(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.VENDOR)
  update(@Param('id') id: string, @Body() dto: UpdateProductDto, @Request() req) {
    return this.productsService.update(id, dto, req.user.id);
  }

  @Put(':id/admin')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  adminUpdate(@Param('id') id: string, @Body() dto: UpdateProductDto) {
    return this.productsService.adminUpdate(id, dto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.VENDOR)
  delete(@Param('id') id: string, @Request() req) {
    return this.productsService.delete(id, req.user.id);
  }
}
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { ProductsService } from './products.service';
import { ProductsController } from './products.controller';
import { Product, ProductSchema } from './schemas/product.schema';
import { VendorsModule } from '../vendors/vendors.module';
import { CatalogModule } from '../catalog/catalog.module';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: Product.name, schema: ProductSchema }]),
    VendorsModule,
    CatalogModule,
  ],
  controllers: [ProductsController],
  providers: [ProductsService],
  exports: [ProductsService],
})
export class ProductsModule {}
import { Injectable, NotFoundException, ForbiddenException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Product } from './schemas/product.schema';
import { CreateProductDto } from './dto/create-product.dto';
import { UpdateProductDto } from './dto/update-product.dto';
import { FilterProductDto } from './dto/filter-product.dto';
import { VendorsService } from '../vendors/vendors.service';
import { CatalogService } from '../catalog/catalog.service';
import { ProductStatus } from '../common/enums/product-status.enum';

@Injectable()
export class ProductsService {
  constructor(
    @InjectModel(Product.name) private productModel: Model<Product>,
    private vendorsService: VendorsService,
    private catalogService: CatalogService,
  ) {}

  async create(dto: CreateProductDto, userId: string): Promise<Product> {
    // Get vendor by user
    const vendor = await this.vendorsService.findByUser(userId);

    // Try to match with catalog item
    let catalogItemId: Types.ObjectId | undefined;
    if (dto.sku) {
      const catalogItem = await this.catalogService.findBySku(dto.sku);
      if (catalogItem) catalogItemId = catalogItem._id as Types.ObjectId;
    } else if (dto.barcode) {
      const catalogItem = await this.catalogService.findByBarcode(dto.barcode);
      if (catalogItem) catalogItemId = catalogItem._id as Types.ObjectId;
    }

    // Create product with denormalized location data
    const createData: Record<string, any> = {
      ...dto,
      vendorId: vendor._id,
      stateId: vendor.stateId,
      areaId: vendor.areaId,
      marketId: vendor.marketId,
      location: vendor.location,
      status: ProductStatus.PENDING,
    };

    // Only add catalogItemId if it exists
    if (catalogItemId) {
      createData.catalogItemId = catalogItemId;
    }

    const product = await this.productModel.create(createData);

    // Increment vendor product count and update price range
    await this.vendorsService.incrementProductCount(vendor._id.toString());
    await this.updateVendorPriceRange(vendor._id.toString());

    // Update catalog price stats if linked
    if (catalogItemId) {
      await this.updateCatalogPriceStats(catalogItemId.toString());
    }

    return product;
  }

  async findAll(filterDto: FilterProductDto): Promise<{
    products: Product[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const {
      page = 1,
      limit = 20,
      vendorId,
      category,
      subcategory,
      type,
      status,
      search,
      minPrice,
      maxPrice,
      stateId,
      areaId,
      marketId,
      inStock,
      sortBy = 'createdAt',
      sortOrder = 'desc',
    } = filterDto;

    // Use Record<string, any> instead of FilterQuery
    const query: Record<string, any> = { isActive: true };

    if (vendorId) query.vendorId = vendorId;
    if (category) query.category = category;
    if (subcategory) query.subcategory = subcategory;
    if (type) query.type = type;
    if (status) query.status = status;
    else query.status = ProductStatus.APPROVED;
    if (stateId) query.stateId = stateId;
    if (areaId) query.areaId = areaId;
    if (marketId) query.marketId = marketId;
    if (inStock !== undefined) query.inStock = inStock;

    if (search) {
      query.$or = [
        { name: { $regex: search, $options: 'i' } },
        { description: { $regex: search, $options: 'i' } },
        { brand: { $regex: search, $options: 'i' } },
        { tags: { $in: [new RegExp(search, 'i')] } },
      ];
    }

    if (minPrice !== undefined || maxPrice !== undefined) {
      query.price = {};
      if (minPrice !== undefined) query.price.$gte = minPrice;
      if (maxPrice !== undefined) query.price.$lte = maxPrice;
    }

    const skip = (page - 1) * limit;
    const sortOptions: Record<string, 1 | -1> = {};
    sortOptions[sortBy] = sortOrder === 'asc' ? 1 : -1;

    const [products, total] = await Promise.all([
      this.productModel
        .find(query)
        .populate({
          path: 'vendorId',
          select: 'businessName shopImages contactDetails bankDetails stateId areaId marketId shopNumber rating isVerified',
          populate: [
            { path: 'stateId', select: 'name' },
            { path: 'areaId', select: 'name' },
            { path: 'marketId', select: 'name type' },
          ],
        })
        .skip(skip)
        .limit(limit)
        .sort(sortOptions),
      this.productModel.countDocuments(query),
    ]);

    return {
      products,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async findById(id: string): Promise<Product> {
    const product = await this.productModel
      .findById(id)
      .populate({
        path: 'vendorId',
        select: 'businessName businessDescription shopImages contactDetails bankDetails stateId areaId marketId shopNumber shopFloor shopBlock shopAddress landmark rating isVerified operatingHours isOpen',
        populate: [
          { path: 'stateId', select: 'name code' },
          { path: 'areaId', select: 'name' },
          { path: 'marketId', select: 'name type address entrancePhoto layoutMap' },
        ],
      });

    if (!product) {
      throw new NotFoundException('Product not found');
    }

    // Increment view count
    await this.productModel.findByIdAndUpdate(id, { $inc: { views: 1 } });

    return product;
  }

  async findByVendor(vendorId: string): Promise<Product[]> {
    return this.productModel
      .find({ vendorId, isActive: true })
      .sort({ createdAt: -1 });
  }

  async getMyProducts(userId: string): Promise<Product[]> {
    const vendor = await this.vendorsService.findByUser(userId);
    return this.productModel
      .find({ vendorId: vendor._id })
      .sort({ createdAt: -1 });
  }

  async findNearby(
    longitude: number,
    latitude: number,
    maxDistanceKm: number = 5,
    category?: string,
  ): Promise<Product[]> {
    const query: Record<string, any> = {
      location: {
        $near: {
          $geometry: {
            type: 'Point',
            coordinates: [longitude, latitude],
          },
          $maxDistance: maxDistanceKm * 1000,
        },
      },
      isActive: true,
      status: ProductStatus.APPROVED,
    };

    if (category) query.category = category;

    return this.productModel
      .find(query)
      .populate({
        path: 'vendorId',
        select: 'businessName shopImages contactDetails rating isVerified shopNumber',
      })
      .limit(50);
  }

  async update(id: string, dto: UpdateProductDto, userId: string): Promise<Product> {
    const product = await this.productModel.findById(id);
    if (!product) {
      throw new NotFoundException('Product not found');
    }

    // Verify ownership
    const vendor = await this.vendorsService.findByUser(userId);
    if (product.vendorId.toString() !== vendor._id.toString()) {
      throw new ForbiddenException('You can only update your own products');
    }

    const updatedProduct = await this.productModel.findByIdAndUpdate(
      id,
      dto,
      { new: true },
    );

    if (!updatedProduct) {
      throw new NotFoundException('Product not found');
    }

    // Update vendor price range if price changed
    if (dto.price !== undefined) {
      await this.updateVendorPriceRange(vendor._id.toString());
    }

    // Update catalog price stats if linked
    if (product.catalogItemId) {
      await this.updateCatalogPriceStats(product.catalogItemId.toString());
    }

    return updatedProduct;
  }

  async adminUpdate(id: string, dto: UpdateProductDto): Promise<Product> {
    const product = await this.productModel.findByIdAndUpdate(
      id,
      dto,
      { new: true },
    );

    if (!product) {
      throw new NotFoundException('Product not found');
    }

    return product;
  }

  async delete(id: string, userId: string): Promise<void> {
    const product = await this.productModel.findById(id);
    if (!product) {
      throw new NotFoundException('Product not found');
    }

    // Verify ownership
    const vendor = await this.vendorsService.findByUser(userId);
    if (product.vendorId.toString() !== vendor._id.toString()) {
      throw new ForbiddenException('You can only delete your own products');
    }

    await this.productModel.deleteOne({ _id: id });

    // Decrement vendor product count
    await this.vendorsService.decrementProductCount(vendor._id.toString());
    await this.updateVendorPriceRange(vendor._id.toString());

    // Update catalog price stats if linked
    if (product.catalogItemId) {
      await this.updateCatalogPriceStats(product.catalogItemId.toString());
    }
  }

  private async updateVendorPriceRange(vendorId: string): Promise<void> {
    const priceStats = await this.productModel.aggregate([
      {
        $match: {
          vendorId: new Types.ObjectId(vendorId),
          isActive: true,
          status: ProductStatus.APPROVED,
        },
      },
      {
        $group: {
          _id: null,
          minPrice: { $min: '$price' },
          maxPrice: { $max: '$price' },
        },
      },
    ]);

    if (priceStats.length > 0) {
      await this.vendorsService.updatePriceRange(
        vendorId,
        priceStats[0].minPrice,
        priceStats[0].maxPrice,
      );
    }
  }

  private async updateCatalogPriceStats(catalogItemId: string): Promise<void> {
    const prices = await this.productModel
      .find({
        catalogItemId: new Types.ObjectId(catalogItemId),
        isActive: true,
        status: ProductStatus.APPROVED,
      })
      .select('price');

    const priceValues = prices.map((p) => p.price);
    await this.catalogService.updatePriceStats(catalogItemId, priceValues);
  }
}
export interface ProductSearchResult {
  id: string;
  name: string;
  description?: string;
  brand?: string;
  category: string;
  subcategory?: string;
  images: string[];
  
  // Price info from this specific vendor
  price: number;
  originalPrice?: number;
  currency: string;
  inStock: boolean;
  
  // Vendor info
  vendor: {
    id: string;
    businessName: string;
    logo?: string;
    rating: number;
    isVerified: boolean;
    contactDetails: {
      phone: string;
      whatsapp?: string;
    };
  };
  
  // Location info
  location: {
    state: { id: string; name: string };
    area: { id: string; name: string };
    market?: { id: string; name: string; type: string };
    shopNumber?: string;
    shopAddress?: string;
    coordinates?: [number, number];
    distance?: number; // in km, if geo search
  };
}

export interface ProductWithVendors {
  // Product master info
  id: string;
  catalogItemId?: string;
  name: string;
  description?: string;
  brand?: string;
  category: string;
  subcategory?: string;
  images: string[];
  
  // Price summary
  priceRange: {
    lowest: number;
    highest: number;
    average: number;
    currency: string;
  };
  
  // All vendors selling this product
  totalVendors: number;
  vendors: VendorListing[];
}

export interface VendorListing {
  vendorId: string;
  productId: string;
  businessName: string;
  logo?: string;
  entrancePhoto?: string;
  rating: number;
  isVerified: boolean;
  
  // This vendor's price
  price: number;
  originalPrice?: number;
  inStock: boolean;
  quantity: number;
  
  // Contact
  contactDetails: {
    phone: string;
    whatsapp?: string;
    email?: string;
  };
  
  // Banking (for external transactions)
  bankDetails?: {
    bankName: string;
    accountName: string;
    accountNumber: string;
  };
  
  // Location
  location: {
    state: { id: string; name: string };
    area: { id: string; name: string };
    market?: { id: string; name: string; type: string };
    shopNumber?: string;
    shopFloor?: string;
    shopBlock?: string;
    shopAddress?: string;
    landmark?: string;
    coordinates?: [number, number];
    distance?: number;
  };
  
  // Operating hours
  operatingHours?: {
    openingTime?: string;
    closingTime?: string;
    operatingDays?: string[];
    isOpen: boolean;
  };
}

export interface ShopSearchResult {
  id: string;
  businessName: string;
  businessDescription?: string;
  vendorType: string;
  
  // Images
  logo?: string;
  entrancePhoto?: string;
  layoutMap?: string;
  
  // Stats
  rating: number;
  reviewCount: number;
  totalProducts: number;
  isVerified: boolean;
  isFeatured: boolean;
  
  // Categories
  categories: string[];
  
  // Price Range
  priceRange: {
    min: number;
    max: number;
  };
  
  // Contact
  contactDetails: {
    phone: string;
    whatsapp?: string;
    email?: string;
    instagram?: string;
  };
  
  // Banking
  bankDetails?: {
    bankName: string;
    accountName: string;
    accountNumber: string;
  };
  
  // Location
  location: {
    state: { id: string; name: string };
    area: { id: string; name: string };
    market?: { id: string; name: string; type: string };
    shopNumber?: string;
    shopFloor?: string;
    shopBlock?: string;
    shopAddress?: string;
    landmark?: string;
    coordinates?: [number, number];
    distance?: number;
  };
  
  // Operating
  operatingHours?: {
    openingTime?: string;
    closingTime?: string;
    operatingDays?: string[];
    isOpen: boolean;
  };
  
  // Sample products
  featuredProducts?: {
    id: string;
    name: string;
    price: number;
    image?: string;
  }[];
}

export interface SearchResults {
  query: string;
  searchType: string;
  
  products?: {
    items: ProductSearchResult[];
    total: number;
    page: number;
    totalPages: number;
  };
  
  shops?: {
    items: ShopSearchResult[];
    total: number;
    page: number;
    totalPages: number;
  };
  
  // Aggregated product with all vendors
  productComparison?: {
    items: ProductWithVendors[];
    total: number;
  };
  
  // Filters available based on results
  availableFilters: {
    states: { id: string; name: string; count: number }[];
    areas: { id: string; name: string; count: number }[];
    markets: { id: string; name: string; count: number }[];
    categories: { name: string; count: number }[];
    brands: { name: string; count: number }[];
    priceRange: { min: number; max: number };
  };
  
  meta: {
    timestamp: string;
    took: number; // ms
  };
}
import { IsOptional, IsString, IsEnum, IsNumber, IsMongoId, IsBoolean, IsArray } from 'class-validator';
import { Type } from 'class-transformer';

export enum SearchType {
  PRODUCTS = 'products',
  SHOPS = 'shops',
  ALL = 'all',
}

export enum SortBy {
  RELEVANCE = 'relevance',
  PRICE_LOW = 'price_low',
  PRICE_HIGH = 'price_high',
  RATING = 'rating',
  NEWEST = 'newest',
  DISTANCE = 'distance',
  POPULARITY = 'popularity',
}

export class SearchDto {
  @IsString()
  query: string;

  @IsOptional()
  @IsEnum(SearchType)
  searchType?: SearchType = SearchType.ALL;

  // Location Filters
  @IsOptional()
  @IsMongoId()
  stateId?: string;

  @IsOptional()
  @IsMongoId()
  areaId?: string;

  @IsOptional()
  @IsMongoId()
  marketId?: string;

  // Geolocation
  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  longitude?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  latitude?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  maxDistance?: number = 10; // in km

  // Category Filters
  @IsOptional()
  @IsString()
  category?: string;

  @IsOptional()
  @IsString()
  subcategory?: string;

  @IsOptional()
  @IsString()
  brand?: string;

  // Price Filters
  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  minPrice?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  maxPrice?: number;

  // Other Filters
  @IsOptional()
  @Type(() => Boolean)
  @IsBoolean()
  inStock?: boolean;

  @IsOptional()
  @Type(() => Boolean)
  @IsBoolean()
  verifiedOnly?: boolean;

  @IsOptional()
  @IsArray()
  @IsString({ each: true })
  tags?: string[];

  // Sorting
  @IsOptional()
  @IsEnum(SortBy)
  sortBy?: SortBy = SortBy.RELEVANCE;

  // Pagination
  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  limit?: number = 20;
}

export class ProductSearchDto extends SearchDto {
  @IsOptional()
  @IsString()
  sku?: string;

  @IsOptional()
  @IsString()
  barcode?: string;
}

export class ShopSearchDto extends SearchDto {
  @IsOptional()
  @IsEnum(['market_shop', 'mall_shop', 'home_based', 'street_shop', 'online_only'])
  vendorType?: string;

  @IsOptional()
  @Type(() => Boolean)
  @IsBoolean()
  isOpen?: boolean;
}
import {
  Controller,
  Get,
  Query,
  Param,
} from '@nestjs/common';
import { SearchService } from './search.service';
import { SearchDto, ProductSearchDto, ShopSearchDto } from './dto/search.dto';

@Controller('search')
export class SearchController {
  constructor(private searchService: SearchService) {}

  // Main search endpoint - searches both products and shops
  @Get()
  search(@Query() dto: SearchDto) {
    return this.searchService.search(dto);
  }

  // Search products only
  @Get('products')
  searchProducts(@Query() dto: ProductSearchDto) {
    dto.searchType = 'products' as any;
    return this.searchService.searchProducts(dto);
  }

  // Search shops only
  @Get('shops')
  searchShops(@Query() dto: ShopSearchDto) {
    return this.searchService.searchShops(dto);
  }

  // Get all vendors selling a specific product with price comparison
  @Get('product/:productName/vendors')
  getProductVendors(
    @Param('productName') productName: string,
    @Query() filters: SearchDto,
  ) {
    return this.searchService.getProductVendors(productName, filters);
  }

  // Get product comparison across vendors
  @Get('compare')
  getProductComparison(@Query() dto: SearchDto) {
    return this.searchService.getProductComparison(dto);
  }

  // Get a shop's products
  @Get('shop/:vendorId/products')
  getShopProducts(
    @Param('vendorId') vendorId: string,
    @Query('category') category?: string,
    @Query('minPrice') minPrice?: number,
    @Query('maxPrice') maxPrice?: number,
    @Query('page') page?: number,
    @Query('limit') limit?: number,
  ) {
    return this.searchService.getShopProducts(vendorId, {
      category,
      minPrice,
      maxPrice,
      page,
      limit,
    });
  }

  // Get similar products
  @Get('product/:productId/similar')
  getSimilarProducts(
    @Param('productId') productId: string,
    @Query('limit') limit?: number,
  ) {
    return this.searchService.getSimilarProducts(productId, limit);
  }

  // Get available filters for current search
  @Get('filters')
  getFilters(@Query() dto: SearchDto) {
    return this.searchService.getAvailableFilters(dto);
  }
}
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { SearchController } from './search.controller';
import { SearchService } from './search.service';
import { Product, ProductSchema } from '../products/schemas/product.schema';
import { Vendor, VendorSchema } from '../vendors/schemas/vendor.schema';
import { CatalogItem, CatalogItemSchema } from '../catalog/schemas/catalog-item.schema';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: Product.name, schema: ProductSchema },
      { name: Vendor.name, schema: VendorSchema },
      { name: CatalogItem.name, schema: CatalogItemSchema },
    ]),
  ],
  controllers: [SearchController],
  providers: [SearchService],
  exports: [SearchService],
})
export class SearchModule {}
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, PipelineStage } from 'mongoose';
import { Product } from '../products/schemas/product.schema';
import { Vendor } from '../vendors/schemas/vendor.schema';
import { CatalogItem } from '../catalog/schemas/catalog-item.schema';
import {
  SearchDto,
  ProductSearchDto,
  ShopSearchDto,
  SearchType,
  SortBy,
} from './dto/search.dto';
import {
  SearchResults,
  ProductSearchResult,
  ShopSearchResult,
  ProductWithVendors,
  VendorListing,
} from './dto/search-result.dto';
import { ProductStatus } from '../common/enums/product-status.enum';

@Injectable()
export class SearchService {
  constructor(
    @InjectModel(Product.name) private productModel: Model<Product>,
    @InjectModel(Vendor.name) private vendorModel: Model<Vendor>,
    @InjectModel(CatalogItem.name) private catalogModel: Model<CatalogItem>,
  ) {}

  async search(dto: SearchDto): Promise<SearchResults> {
    const startTime = Date.now();
    
    // Set default searchType if not provided
    const searchType = dto.searchType || SearchType.ALL;
    
    const results: SearchResults = {
      query: dto.query,
      searchType: searchType.toString(), // Convert to string
      availableFilters: {
        states: [],
        areas: [],
        markets: [],
        categories: [],
        brands: [],
        priceRange: { min: 0, max: 0 },
      },
      meta: {
        timestamp: new Date().toISOString(),
        took: 0,
      },
    };

    switch (searchType) {
      case SearchType.PRODUCTS:
        results.products = await this.searchProducts(dto);
        results.productComparison = await this.getProductComparison(dto);
        break;
      case SearchType.SHOPS:
        results.shops = await this.searchShops(dto);
        break;
      case SearchType.ALL:
      default:
        const [products, shops] = await Promise.all([
          this.searchProducts(dto),
          this.searchShops(dto),
        ]);
        results.products = products;
        results.shops = shops;
        results.productComparison = await this.getProductComparison(dto);
        break;
    }

    // Get available filters
    results.availableFilters = await this.getAvailableFilters(dto);
    
    results.meta.took = Date.now() - startTime;
    return results;
  }

  async searchProducts(dto: SearchDto): Promise<{
    items: ProductSearchResult[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const { page = 1, limit = 20 } = dto;
    const skip = (page - 1) * limit;

    const pipeline: PipelineStage[] = [];

    // Match stage
    const matchStage: Record<string, any> = {
      isActive: true,
      status: ProductStatus.APPROVED,
    };

    // Text search
    if (dto.query) {
      matchStage.$text = { $search: dto.query };
    }

    // Location filters
    if (dto.stateId) matchStage.stateId = dto.stateId;
    if (dto.areaId) matchStage.areaId = dto.areaId;
    if (dto.marketId) matchStage.marketId = dto.marketId;

    // Category filters
    if (dto.category) matchStage.category = dto.category;
    if (dto.subcategory) matchStage.subcategory = dto.subcategory;
    if (dto.brand) matchStage.brand = { $regex: dto.brand, $options: 'i' };

    // Price filters
    if (dto.minPrice !== undefined || dto.maxPrice !== undefined) {
      matchStage.price = {};
      if (dto.minPrice !== undefined) matchStage.price.$gte = dto.minPrice;
      if (dto.maxPrice !== undefined) matchStage.price.$lte = dto.maxPrice;
    }

    // Stock filter
    if (dto.inStock !== undefined) {
      matchStage.inStock = dto.inStock;
    }

    // Geo query
    if (dto.longitude && dto.latitude) {
      matchStage.location = {
        $near: {
          $geometry: {
            type: 'Point',
            coordinates: [dto.longitude, dto.latitude],
          },
          $maxDistance: (dto.maxDistance || 10) * 1000,
        },
      };
    }

    pipeline.push({ $match: matchStage });

    // Lookup vendor
    pipeline.push({
      $lookup: {
        from: 'vendors',
        localField: 'vendorId',
        foreignField: '_id',
        as: 'vendor',
      },
    });
    pipeline.push({ $unwind: '$vendor' });

    // Filter by verified vendors if requested
    if (dto.verifiedOnly) {
      pipeline.push({ $match: { 'vendor.isVerified': true } });
    }

    // Lookup state
    pipeline.push({
      $lookup: {
        from: 'states',
        localField: 'stateId',
        foreignField: '_id',
        as: 'state',
      },
    });
    pipeline.push({ $unwind: { path: '$state', preserveNullAndEmptyArrays: true } });

    // Lookup area
    pipeline.push({
      $lookup: {
        from: 'areas',
        localField: 'areaId',
        foreignField: '_id',
        as: 'area',
      },
    });
    pipeline.push({ $unwind: { path: '$area', preserveNullAndEmptyArrays: true } });

    // Lookup market
    pipeline.push({
      $lookup: {
        from: 'markets',
        localField: 'marketId',
        foreignField: '_id',
        as: 'market',
      },
    });
    pipeline.push({ $unwind: { path: '$market', preserveNullAndEmptyArrays: true } });

    // Add text score if text search
    if (dto.query) {
      pipeline.push({
        $addFields: {
          textScore: { $meta: 'textScore' },
        },
      });
    }

    // Sort
    const sortStage: any = {};
    switch (dto.sortBy) {
      case SortBy.PRICE_LOW:
        sortStage.price = 1;
        break;
      case SortBy.PRICE_HIGH:
        sortStage.price = -1;
        break;
      case SortBy.RATING:
        sortStage['vendor.rating'] = -1;
        break;
      case SortBy.NEWEST:
        sortStage.createdAt = -1;
        break;
      case SortBy.POPULARITY:
        sortStage.views = -1;
        break;
      case SortBy.RELEVANCE:
      default:
        if (dto.query) {
          sortStage.textScore = -1;
        }
        sortStage.createdAt = -1;
        break;
    }
    pipeline.push({ $sort: sortStage });

    // Count total before pagination
    const countPipeline = [...pipeline, { $count: 'total' }];
    const countResult = await this.productModel.aggregate(countPipeline);
    const total = countResult[0]?.total || 0;

    // Pagination
    pipeline.push({ $skip: skip });
    pipeline.push({ $limit: limit });

    // Project final shape
    pipeline.push({
      $project: {
        id: '$_id',
        name: 1,
        description: 1,
        brand: 1,
        category: 1,
        subcategory: 1,
        images: 1,
        price: 1,
        originalPrice: 1,
        currency: 1,
        inStock: 1,
        vendor: {
          id: '$vendor._id',
          businessName: '$vendor.businessName',
          logo: '$vendor.shopImages.logo',
          rating: '$vendor.rating',
          isVerified: '$vendor.isVerified',
          contactDetails: {
            phone: '$vendor.contactDetails.phone',
            whatsapp: '$vendor.contactDetails.whatsapp',
          },
        },
        location: {
          state: { id: '$state._id', name: '$state.name' },
          area: { id: '$area._id', name: '$area.name' },
          market: {
            id: '$market._id',
            name: '$market.name',
            type: '$market.type',
          },
          shopNumber: '$vendor.shopNumber',
          shopAddress: '$vendor.shopAddress',
          coordinates: '$location.coordinates',
        },
      },
    });

    const products = await this.productModel.aggregate(pipeline);

    // Update search appearances
    const productIds = products.map((p) => p.id);
    await this.productModel.updateMany(
      { _id: { $in: productIds } },
      { $inc: { searchAppearances: 1 } },
    );

    return {
      items: products as ProductSearchResult[],
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async getProductComparison(dto: SearchDto): Promise<{
    items: ProductWithVendors[];
    total: number;
  }> {
    // Group products by name/sku to show price comparison across vendors
    const pipeline: PipelineStage[] = [];

    const matchStage: Record<string, any> = {
      isActive: true,
      status: ProductStatus.APPROVED,
    };

    if (dto.query) {
      matchStage.$or = [
        { name: { $regex: dto.query, $options: 'i' } },
        { $text: { $search: dto.query } },
      ];
    }

    if (dto.stateId) matchStage.stateId = dto.stateId;
    if (dto.areaId) matchStage.areaId = dto.areaId;
    if (dto.marketId) matchStage.marketId = dto.marketId;
    if (dto.category) matchStage.category = dto.category;

    pipeline.push({ $match: matchStage });

    // Lookup vendor details
    pipeline.push({
      $lookup: {
        from: 'vendors',
        localField: 'vendorId',
        foreignField: '_id',
        as: 'vendor',
      },
    });
    pipeline.push({ $unwind: '$vendor' });

    // Lookup location details
    pipeline.push({
      $lookup: {
        from: 'states',
        localField: 'stateId',
        foreignField: '_id',
        as: 'state',
      },
    });
    pipeline.push({ $unwind: { path: '$state', preserveNullAndEmptyArrays: true } });

    pipeline.push({
      $lookup: {
        from: 'areas',
        localField: 'areaId',
        foreignField: '_id',
        as: 'area',
      },
    });
    pipeline.push({ $unwind: { path: '$area', preserveNullAndEmptyArrays: true } });

    pipeline.push({
      $lookup: {
        from: 'markets',
        localField: 'marketId',
        foreignField: '_id',
        as: 'market',
      },
    });
    pipeline.push({ $unwind: { path: '$market', preserveNullAndEmptyArrays: true } });

    // Group by product name (or sku/barcode if available)
    pipeline.push({
      $group: {
        _id: {
          $cond: [
            { $ne: ['$sku', null] },
            '$sku',
            { $toLower: '$name' },
          ],
        },
        name: { $first: '$name' },
        description: { $first: '$description' },
        brand: { $first: '$brand' },
        category: { $first: '$category' },
        subcategory: { $first: '$subcategory' },
        images: { $first: '$images' },
        catalogItemId: { $first: '$catalogItemId' },
        lowestPrice: { $min: '$price' },
        highestPrice: { $max: '$price' },
        averagePrice: { $avg: '$price' },
        totalVendors: { $sum: 1 },
        vendors: {
          $push: {
            vendorId: '$vendor._id',
            productId: '$_id',
            businessName: '$vendor.businessName',
            logo: '$vendor.shopImages.logo',
            entrancePhoto: '$vendor.shopImages.entrancePhoto',
            rating: '$vendor.rating',
            isVerified: '$vendor.isVerified',
            price: '$price',
            originalPrice: '$originalPrice',
            inStock: '$inStock',
            quantity: '$quantity',
            contactDetails: '$vendor.contactDetails',
            bankDetails: '$vendor.bankDetails',
            location: {
              state: { id: '$state._id', name: '$state.name' },
              area: { id: '$area._id', name: '$area.name' },
              market: { id: '$market._id', name: '$market.name', type: '$market.type' },
              shopNumber: '$vendor.shopNumber',
              shopFloor: '$vendor.shopFloor',
              shopBlock: '$vendor.shopBlock',
              shopAddress: '$vendor.shopAddress',
              landmark: '$vendor.landmark',
              coordinates: '$vendor.location.coordinates',
            },
            operatingHours: {
              openingTime: '$vendor.operatingHours.openingTime',
              closingTime: '$vendor.operatingHours.closingTime',
              operatingDays: '$vendor.operatingHours.operatingDays',
              isOpen: '$vendor.isOpen',
            },
          },
        },
      },
    });

    // Sort vendors within each product by price
    pipeline.push({
      $addFields: {
        vendors: {
          $sortArray: {
            input: '$vendors',
            sortBy: { price: 1 },
          },
        },
      },
    });

    // Sort products by number of vendors (popularity)
    pipeline.push({ $sort: { totalVendors: -1 } });

    // Limit
    pipeline.push({ $limit: 20 });

    // Project final shape
    pipeline.push({
      $project: {
        id: '$_id',
        catalogItemId: 1,
        name: 1,
        description: 1,
        brand: 1,
        category: 1,
        subcategory: 1,
        images: 1,
        priceRange: {
          lowest: '$lowestPrice',
          highest: '$highestPrice',
          average: { $round: ['$averagePrice', 2] },
          currency: 'NGN',
        },
        totalVendors: 1,
        vendors: 1,
      },
    });

    const results = await this.productModel.aggregate(pipeline);

    return {
      items: results as ProductWithVendors[],
      total: results.length,
    };
  }

  async searchShops(dto: ShopSearchDto): Promise<{
    items: ShopSearchResult[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const { page = 1, limit = 20 } = dto;
    const skip = (page - 1) * limit;

    const pipeline: PipelineStage[] = [];

    const matchStage: Record<string, any> = {
      isActive: true,
    };

    // Text search
    if (dto.query) {
      matchStage.$or = [
        { businessName: { $regex: dto.query, $options: 'i' } },
        { businessDescription: { $regex: dto.query, $options: 'i' } },
        { categories: { $in: [new RegExp(dto.query, 'i')] } },
        { tags: { $in: [new RegExp(dto.query, 'i')] } },
      ];
    }

    // Location filters
    if (dto.stateId) matchStage.stateId = dto.stateId;
    if (dto.areaId) matchStage.areaId = dto.areaId;
    if (dto.marketId) matchStage.marketId = dto.marketId;

    // Vendor type
    if (dto.vendorType) matchStage.vendorType = dto.vendorType;

    // Verified only
    if (dto.verifiedOnly) matchStage.isVerified = true;

    // Is open
    if (dto.isOpen !== undefined) matchStage.isOpen = dto.isOpen;

    // Category filter
    if (dto.category) {
      matchStage.categories = { $in: [dto.category] };
    }

    // Geo query
    if (dto.longitude && dto.latitude) {
      matchStage.location = {
        $near: {
          $geometry: {
            type: 'Point',
            coordinates: [dto.longitude, dto.latitude],
          },
          $maxDistance: (dto.maxDistance || 10) * 1000,
        },
      };
    }

    pipeline.push({ $match: matchStage });

    // Lookup state
    pipeline.push({
      $lookup: {
        from: 'states',
        localField: 'stateId',
        foreignField: '_id',
        as: 'state',
      },
    });
    pipeline.push({ $unwind: { path: '$state', preserveNullAndEmptyArrays: true } });

    // Lookup area
    pipeline.push({
      $lookup: {
        from: 'areas',
        localField: 'areaId',
        foreignField: '_id',
        as: 'area',
      },
    });
    pipeline.push({ $unwind: { path: '$area', preserveNullAndEmptyArrays: true } });

    // Lookup market
    pipeline.push({
      $lookup: {
        from: 'markets',
        localField: 'marketId',
        foreignField: '_id',
        as: 'market',
      },
    });
    pipeline.push({ $unwind: { path: '$market', preserveNullAndEmptyArrays: true } });

    // Lookup featured products
    pipeline.push({
      $lookup: {
        from: 'products',
        let: { vendorId: '$_id' },
        pipeline: [
          {
            $match: {
              $expr: { $eq: ['$vendorId', '$$vendorId'] },
              isActive: true,
              status: 'approved',
            },
          },
          { $sort: { views: -1 } },
          { $limit: 4 },
          {
            $project: {
              id: '$_id',
              name: 1,
              price: 1,
              image: { $arrayElemAt: ['$images', 0] },
            },
          },
        ],
        as: 'featuredProducts',
      },
    });

    // Sort
    const sortStage: any = {};
    switch (dto.sortBy) {
      case SortBy.RATING:
        sortStage.rating = -1;
        break;
      case SortBy.POPULARITY:
        sortStage.totalViews = -1;
        break;
      case SortBy.NEWEST:
        sortStage.createdAt = -1;
        break;
      default:
        sortStage.isFeatured = -1;
        sortStage.isVerified = -1;
        sortStage.rating = -1;
        break;
    }
    pipeline.push({ $sort: sortStage });

    // Count total
    const countPipeline = [...pipeline, { $count: 'total' }];
    const countResult = await this.vendorModel.aggregate(countPipeline);
    const total = countResult[0]?.total || 0;

    // Pagination
    pipeline.push({ $skip: skip });
    pipeline.push({ $limit: limit });

    // Project final shape
    pipeline.push({
      $project: {
        id: '$_id',
        businessName: 1,
        businessDescription: 1,
        vendorType: 1,
        logo: '$shopImages.logo',
        entrancePhoto: '$shopImages.entrancePhoto',
        layoutMap: '$shopImages.layoutMap',
        rating: 1,
        reviewCount: 1,
        totalProducts: 1,
        isVerified: 1,
        isFeatured: 1,
        categories: 1,
        priceRange: {
          min: '$minProductPrice',
          max: '$maxProductPrice',
        },
        contactDetails: {
          phone: '$contactDetails.phone',
          whatsapp: '$contactDetails.whatsapp',
          email: '$contactDetails.email',
          instagram: '$contactDetails.instagram',
        },
        bankDetails: 1,
        location: {
          state: { id: '$state._id', name: '$state.name' },
          area: { id: '$area._id', name: '$area.name' },
          market: { id: '$market._id', name: '$market.name', type: '$market.type' },
          shopNumber: 1,
          shopFloor: 1,
          shopBlock: 1,
          shopAddress: 1,
          landmark: 1,
          coordinates: '$location.coordinates',
        },
        operatingHours: {
          openingTime: '$operatingHours.openingTime',
          closingTime: '$operatingHours.closingTime',
          operatingDays: '$operatingHours.operatingDays',
          isOpen: 1,
        },
        featuredProducts: 1,
      },
    });

    const shops = await this.vendorModel.aggregate(pipeline);

    // Update search appearances
    const vendorIds = shops.map((s) => s.id);
    await this.vendorModel.updateMany(
      { _id: { $in: vendorIds } },
      { $inc: { searchAppearances: 1 } },
    );

    return {
      items: shops as ShopSearchResult[],
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async getAvailableFilters(dto: SearchDto): Promise<{
    states: { id: string; name: string; count: number }[];
    areas: { id: string; name: string; count: number }[];
    markets: { id: string; name: string; count: number }[];
    categories: { name: string; count: number }[];
    brands: { name: string; count: number }[];
    priceRange: { min: number; max: number };
  }> {
    const matchStage: Record<string, any> = {
      isActive: true,
      status: ProductStatus.APPROVED,
    };

    if (dto.query) {
      matchStage.$or = [
        { name: { $regex: dto.query, $options: 'i' } },
        { description: { $regex: dto.query, $options: 'i' } },
      ];
    }

    // States
    const statesAgg = await this.productModel.aggregate([
      { $match: matchStage },
      {
        $lookup: {
          from: 'states',
          localField: 'stateId',
          foreignField: '_id',
          as: 'state',
        },
      },
      { $unwind: '$state' },
      {
        $group: {
          _id: '$state._id',
          name: { $first: '$state.name' },
          count: { $sum: 1 },
        },
      },
      { $sort: { count: -1 } },
      { $limit: 20 },
      {
        $project: {
          id: '$_id',
          name: 1,
          count: 1,
          _id: 0,
        },
      },
    ]);

    // Areas (filtered by state if provided)
    const areasMatch = { ...matchStage };
    if (dto.stateId) areasMatch.stateId = dto.stateId;

    const areasAgg = await this.productModel.aggregate([
      { $match: areasMatch },
      {
        $lookup: {
          from: 'areas',
          localField: 'areaId',
          foreignField: '_id',
          as: 'area',
        },
      },
      { $unwind: '$area' },
      {
        $group: {
          _id: '$area._id',
          name: { $first: '$area.name' },
          count: { $sum: 1 },
        },
      },
      { $sort: { count: -1 } },
      { $limit: 20 },
      {
        $project: {
          id: '$_id',
          name: 1,
          count: 1,
          _id: 0,
        },
      },
    ]);

    // Markets (filtered by area if provided)
    const marketsMatch = { ...matchStage };
    if (dto.stateId) marketsMatch.stateId = dto.stateId;
    if (dto.areaId) marketsMatch.areaId = dto.areaId;

    const marketsAgg = await this.productModel.aggregate([
      { $match: { ...marketsMatch, marketId: { $exists: true, $ne: null } } },
      {
        $lookup: {
          from: 'markets',
          localField: 'marketId',
          foreignField: '_id',
          as: 'market',
        },
      },
      { $unwind: '$market' },
      {
        $group: {
          _id: '$market._id',
          name: { $first: '$market.name' },
          count: { $sum: 1 },
        },
      },
      { $sort: { count: -1 } },
      { $limit: 20 },
      {
        $project: {
          id: '$_id',
          name: 1,
          count: 1,
          _id: 0,
        },
      },
    ]);

    // Categories
    const categoriesAgg = await this.productModel.aggregate([
      { $match: matchStage },
      {
        $group: {
          _id: '$category',
          count: { $sum: 1 },
        },
      },
      { $sort: { count: -1 } },
      { $limit: 20 },
      {
        $project: {
          name: '$_id',
          count: 1,
          _id: 0,
        },
      },
    ]);

    // Brands
    const brandsAgg = await this.productModel.aggregate([
      { $match: { ...matchStage, brand: { $exists: true, $ne: null } } },
      {
        $group: {
          _id: '$brand',
          count: { $sum: 1 },
        },
      },
      { $sort: { count: -1 } },
      { $limit: 20 },
      {
        $project: {
          name: '$_id',
          count: 1,
          _id: 0,
        },
      },
    ]);

    // Price range
    const priceAgg = await this.productModel.aggregate([
      { $match: matchStage },
      {
        $group: {
          _id: null,
          min: { $min: '$price' },
          max: { $max: '$price' },
        },
      },
    ]);

    return {
      states: statesAgg,
      areas: areasAgg,
      markets: marketsAgg,
      categories: categoriesAgg,
      brands: brandsAgg,
      priceRange: priceAgg[0] || { min: 0, max: 0 },
    };
  }

  async getProductVendors(productName: string, filters: SearchDto): Promise<ProductWithVendors> {
    const pipeline: PipelineStage[] = [];

    const matchStage: Record<string, any> = {
      isActive: true,
      status: ProductStatus.APPROVED,
      $or: [
        { name: { $regex: productName, $options: 'i' } },
        { sku: productName },
        { barcode: productName },
      ],
    };

    if (filters.stateId) matchStage.stateId = filters.stateId;
    if (filters.areaId) matchStage.areaId = filters.areaId;
    if (filters.marketId) matchStage.marketId = filters.marketId;
    if (filters.minPrice !== undefined) {
      matchStage.price = { ...matchStage.price, $gte: filters.minPrice };
    }
    if (filters.maxPrice !== undefined) {
      matchStage.price = { ...matchStage.price, $lte: filters.maxPrice };
    }

    pipeline.push({ $match: matchStage });

    // Full vendor lookup with all details
    pipeline.push({
      $lookup: {
        from: 'vendors',
        localField: 'vendorId',
        foreignField: '_id',
        as: 'vendor',
      },
    });
    pipeline.push({ $unwind: '$vendor' });

    // Location lookups
    pipeline.push({
      $lookup: {
        from: 'states',
        localField: 'stateId',
        foreignField: '_id',
        as: 'state',
      },
    });
    pipeline.push({ $unwind: { path: '$state', preserveNullAndEmptyArrays: true } });

    pipeline.push({
      $lookup: {
        from: 'areas',
        localField: 'areaId',
        foreignField: '_id',
        as: 'area',
      },
    });
    pipeline.push({ $unwind: { path: '$area', preserveNullAndEmptyArrays: true } });

    pipeline.push({
      $lookup: {
        from: 'markets',
        localField: 'marketId',
        foreignField: '_id',
        as: 'market',
      },
    });
    pipeline.push({ $unwind: { path: '$market', preserveNullAndEmptyArrays: true } });

    // Group to get all vendors
    pipeline.push({
      $group: {
        _id: { $toLower: '$name' },
        name: { $first: '$name' },
        description: { $first: '$description' },
        brand: { $first: '$brand' },
        category: { $first: '$category' },
        subcategory: { $first: '$subcategory' },
        images: { $first: '$images' },
        catalogItemId: { $first: '$catalogItemId' },
        lowestPrice: { $min: '$price' },
        highestPrice: { $max: '$price' },
        averagePrice: { $avg: '$price' },
        totalVendors: { $sum: 1 },
        vendors: {
          $push: {
            vendorId: '$vendor._id',
            productId: '$_id',
            businessName: '$vendor.businessName',
            logo: '$vendor.shopImages.logo',
            entrancePhoto: '$vendor.shopImages.entrancePhoto',
            rating: '$vendor.rating',
            isVerified: '$vendor.isVerified',
            price: '$price',
            originalPrice: '$originalPrice',
            inStock: '$inStock',
            quantity: '$quantity',
            contactDetails: '$vendor.contactDetails',
            bankDetails: '$vendor.bankDetails',
            location: {
              state: { id: '$state._id', name: '$state.name' },
              area: { id: '$area._id', name: '$area.name' },
              market: { id: '$market._id', name: '$market.name', type: '$market.type' },
              shopNumber: '$vendor.shopNumber',
              shopFloor: '$vendor.shopFloor',
              shopBlock: '$vendor.shopBlock',
              shopAddress: '$vendor.shopAddress',
              landmark: '$vendor.landmark',
              coordinates: '$vendor.location.coordinates',
            },
            operatingHours: {
              openingTime: '$vendor.operatingHours.openingTime',
              closingTime: '$vendor.operatingHours.closingTime',
              operatingDays: '$vendor.operatingHours.operatingDays',
              isOpen: '$vendor.isOpen',
            },
          },
        },
      },
    });

    // Sort vendors by price
    pipeline.push({
      $addFields: {
        vendors: {
          $sortArray: {
            input: '$vendors',
            sortBy: { price: 1 },
          },
        },
      },
    });

    pipeline.push({
      $project: {
        id: '$_id',
        catalogItemId: 1,
        name: 1,
        description: 1,
        brand: 1,
        category: 1,
        subcategory: 1,
        images: 1,
        priceRange: {
          lowest: '$lowestPrice',
          highest: '$highestPrice',
          average: { $round: ['$averagePrice', 2] },
          currency: 'NGN',
        },
        totalVendors: 1,
        vendors: 1,
      },
    });

    const result = await this.productModel.aggregate(pipeline);
    return result[0] as ProductWithVendors;
  }

  async getShopProducts(
    vendorId: string,
    filters: { category?: string; minPrice?: number; maxPrice?: number; page?: number; limit?: number },
  ): Promise<{
    shop: ShopSearchResult;
    products: ProductSearchResult[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const { page = 1, limit = 20 } = filters;
    const skip = (page - 1) * limit;

    // Get shop details
    const shopPipeline: PipelineStage[] = [
      { $match: { _id: vendorId } },
      {
        $lookup: {
          from: 'states',
          localField: 'stateId',
          foreignField: '_id',
          as: 'state',
        },
      },
      { $unwind: { path: '$state', preserveNullAndEmptyArrays: true } },
      {
        $lookup: {
          from: 'areas',
          localField: 'areaId',
          foreignField: '_id',
          as: 'area',
        },
      },
      { $unwind: { path: '$area', preserveNullAndEmptyArrays: true } },
      {
        $lookup: {
          from: 'markets',
          localField: 'marketId',
          foreignField: '_id',
          as: 'market',
        },
      },
      { $unwind: { path: '$market', preserveNullAndEmptyArrays: true } },
    ];

    const shopResult = await this.vendorModel.aggregate(shopPipeline);
    const shop = shopResult[0];

    // Get products
    const productMatch: Record<string, any> = {
      vendorId: vendorId,
      isActive: true,
      status: ProductStatus.APPROVED,
    };

    if (filters.category) productMatch.category = filters.category;
    if (filters.minPrice !== undefined || filters.maxPrice !== undefined) {
      productMatch.price = {};
      if (filters.minPrice !== undefined) productMatch.price.$gte = filters.minPrice;
      if (filters.maxPrice !== undefined) productMatch.price.$lte = filters.maxPrice;
    }

    const [products, total] = await Promise.all([
      this.productModel
        .find(productMatch)
        .skip(skip)
        .limit(limit)
        .sort({ createdAt: -1 }),
      this.productModel.countDocuments(productMatch),
    ]);

    return {
      shop: shop as ShopSearchResult,
      products: products.map((p) => ({
        id: p._id.toString(),
        name: p.name,
        description: p.description,
        brand: p.brand,
        category: p.category,
        subcategory: p.subcategory,
        images: p.images || [],
        price: p.price,
        originalPrice: p.originalPrice,
        currency: p.currency,
        inStock: p.inStock,
        vendor: {
          id: shop._id.toString(),
          businessName: shop.businessName,
          logo: shop.shopImages?.logo,
          rating: shop.rating,
          isVerified: shop.isVerified,
          contactDetails: {
            phone: shop.contactDetails?.phone,
            whatsapp: shop.contactDetails?.whatsapp,
          },
        },
        location: {
          state: { id: shop.state?._id?.toString(), name: shop.state?.name },
          area: { id: shop.area?._id?.toString(), name: shop.area?.name },
          market: { id: shop.market?._id?.toString(), name: shop.market?.name, type: shop.market?.type },
          shopNumber: shop.shopNumber,
          shopAddress: shop.shopAddress,
        },
      })) as ProductSearchResult[],
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async getSimilarProducts(productId: string, limit: number = 10): Promise<ProductSearchResult[]> {
    const product = await this.productModel.findById(productId);
    if (!product) return [];

    const pipeline: PipelineStage[] = [
      {
        $match: {
          _id: { $ne: product._id },
          category: product.category,
          isActive: true,
          status: ProductStatus.APPROVED,
        },
      },
      {
        $lookup: {
          from: 'vendors',
          localField: 'vendorId',
          foreignField: '_id',
          as: 'vendor',
        },
      },
      { $unwind: '$vendor' },
      {
        $lookup: {
          from: 'states',
          localField: 'stateId',
          foreignField: '_id',
          as: 'state',
        },
      },
      { $unwind: { path: '$state', preserveNullAndEmptyArrays: true } },
      {
        $lookup: {
          from: 'areas',
          localField: 'areaId',
          foreignField: '_id',
          as: 'area',
        },
      },
      { $unwind: { path: '$area', preserveNullAndEmptyArrays: true } },
      { $sample: { size: limit } },
      {
        $project: {
          id: '$_id',
          name: 1,
          description: 1,
          brand: 1,
          category: 1,
          subcategory: 1,
          images: 1,
          price: 1,
          originalPrice: 1,
          currency: 1,
          inStock: 1,
          vendor: {
            id: '$vendor._id',
            businessName: '$vendor.businessName',
            logo: '$vendor.shopImages.logo',
            rating: '$vendor.rating',
            isVerified: '$vendor.isVerified',
            contactDetails: {
              phone: '$vendor.contactDetails.phone',
              whatsapp: '$vendor.contactDetails.whatsapp',
            },
          },
          location: {
            state: { id: '$state._id', name: '$state.name' },
            area: { id: '$area._id', name: '$area.name' },
          },
        },
      },
    ];

    return this.productModel.aggregate(pipeline);
  }
}
import { IsString, IsOptional, IsArray, IsNumber, IsBoolean } from 'class-validator';

export class CreateStateDto {
  @IsString()
  name: string;

  @IsString()
  code: string;

  @IsString()
  @IsOptional()
  capital?: string;

  @IsArray()
  @IsNumber({}, { each: true })
  @IsOptional()
  coordinates?: [number, number];

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;
}
import { IsString, IsOptional, IsArray, IsNumber, IsBoolean } from 'class-validator';

export class UpdateStateDto {
  @IsString()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  code?: string;

  @IsString()
  @IsOptional()
  capital?: string;

  @IsArray()
  @IsNumber({}, { each: true })
  @IsOptional()
  coordinates?: [number, number];

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;
}
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document } from 'mongoose';

@Schema({ timestamps: true })
export class State extends Document {
  @Prop({ required: true, unique: true })
  name: string;

  @Prop({ required: true, unique: true })
  code: string;

  @Prop()
  capital?: string;

  @Prop({ default: 'Nigeria' })
  country: string;

  @Prop({ type: { type: String, enum: ['Point'], default: 'Point' }, coordinates: [Number] })
  location?: {
    type: 'Point';
    coordinates: [number, number];
  };

  @Prop({ default: true })
  isActive: boolean;
}

export const StateSchema = SchemaFactory.createForClass(State);

StateSchema.index({ location: '2dsphere' });
StateSchema.index({ name: 1 });
StateSchema.index({ code: 1 });
import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  UseGuards,
} from '@nestjs/common';
import { StatesService } from './states.service';
import { CreateStateDto } from './dto/create-state.dto';
import { UpdateStateDto } from './dto/update-state.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { Role } from '../common/enums/role.enum';

@Controller('states')
export class StatesController {
  constructor(private statesService: StatesService) {}

  @Get()
  findAll() {
    return this.statesService.findAll();
  }

  @Get('seed')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  seedStates() {
    return this.statesService.seedNigerianStates();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.statesService.findById(id);
  }

  @Get('code/:code')
  findByCode(@Param('code') code: string) {
    return this.statesService.findByCode(code);
  }

  @Post()
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  create(@Body() dto: CreateStateDto) {
    return this.statesService.create(dto);
  }

  @Put(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  update(@Param('id') id: string, @Body() dto: UpdateStateDto) {
    return this.statesService.update(id, dto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.SUPER_ADMIN)
  delete(@Param('id') id: string) {
    return this.statesService.delete(id);
  }
}
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { StatesService } from './states.service';
import { StatesController } from './states.controller';
import { State, StateSchema } from './schemas/state.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: State.name, schema: StateSchema }]),
  ],
  controllers: [StatesController],
  providers: [StatesService],
  exports: [StatesService],
})
export class StatesModule {}
import { Injectable, NotFoundException, ConflictException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { State } from './schemas/state.schema';
import { CreateStateDto } from './dto/create-state.dto';
import { UpdateStateDto } from './dto/update-state.dto';

@Injectable()
export class StatesService {
  constructor(@InjectModel(State.name) private stateModel: Model<State>) {}

  async create(dto: CreateStateDto): Promise<State> {
    const exists = await this.stateModel.findOne({
      $or: [{ name: dto.name }, { code: dto.code }],
    });
    if (exists) {
      throw new ConflictException('State already exists');
    }

    const stateData: any = { ...dto };
    if (dto.coordinates) {
      stateData.location = {
        type: 'Point',
        coordinates: dto.coordinates,
      };
    }
    delete stateData.coordinates;

    return this.stateModel.create(stateData);
  }

  async findAll(): Promise<State[]> {
    return this.stateModel.find({ isActive: true }).sort({ name: 1 });
  }

  async findById(id: string): Promise<State> {
    const state = await this.stateModel.findById(id);
    if (!state) {
      throw new NotFoundException('State not found');
    }
    return state;
  }

  async findByCode(code: string): Promise<State> {
    const state = await this.stateModel.findOne({ code: code.toUpperCase() });
    if (!state) {
      throw new NotFoundException('State not found');
    }
    return state;
  }

  async update(id: string, dto: UpdateStateDto): Promise<State> {
    const updateData: any = { ...dto };
    if (dto.coordinates) {
      updateData.location = {
        type: 'Point',
        coordinates: dto.coordinates,
      };
    }
    delete updateData.coordinates;

    const state = await this.stateModel.findByIdAndUpdate(id, updateData, {
      new: true,
    });
    if (!state) {
      throw new NotFoundException('State not found');
    }
    return state;
  }

  async delete(id: string): Promise<void> {
    const result = await this.stateModel.deleteOne({ _id: id });
    if (result.deletedCount === 0) {
      throw new NotFoundException('State not found');
    }
  }

  async seedNigerianStates(): Promise<State[]> {
    const nigerianStates = [
      { name: 'Abia', code: 'AB', capital: 'Umuahia' },
      { name: 'Adamawa', code: 'AD', capital: 'Yola' },
      { name: 'Akwa Ibom', code: 'AK', capital: 'Uyo' },
      { name: 'Anambra', code: 'AN', capital: 'Awka' },
      { name: 'Bauchi', code: 'BA', capital: 'Bauchi' },
      { name: 'Bayelsa', code: 'BY', capital: 'Yenagoa' },
      { name: 'Benue', code: 'BE', capital: 'Makurdi' },
      { name: 'Borno', code: 'BO', capital: 'Maiduguri' },
      { name: 'Cross River', code: 'CR', capital: 'Calabar' },
      { name: 'Delta', code: 'DE', capital: 'Asaba' },
      { name: 'Ebonyi', code: 'EB', capital: 'Abakaliki' },
      { name: 'Edo', code: 'ED', capital: 'Benin City' },
      { name: 'Ekiti', code: 'EK', capital: 'Ado-Ekiti' },
      { name: 'Enugu', code: 'EN', capital: 'Enugu' },
      { name: 'FCT', code: 'FC', capital: 'Abuja' },
      { name: 'Gombe', code: 'GO', capital: 'Gombe' },
      { name: 'Imo', code: 'IM', capital: 'Owerri' },
      { name: 'Jigawa', code: 'JI', capital: 'Dutse' },
      { name: 'Kaduna', code: 'KD', capital: 'Kaduna' },
      { name: 'Kano', code: 'KN', capital: 'Kano' },
      { name: 'Katsina', code: 'KT', capital: 'Katsina' },
      { name: 'Kebbi', code: 'KE', capital: 'Birnin Kebbi' },
      { name: 'Kogi', code: 'KO', capital: 'Lokoja' },
      { name: 'Kwara', code: 'KW', capital: 'Ilorin' },
      { name: 'Lagos', code: 'LA', capital: 'Ikeja' },
      { name: 'Nasarawa', code: 'NA', capital: 'Lafia' },
      { name: 'Niger', code: 'NI', capital: 'Minna' },
      { name: 'Ogun', code: 'OG', capital: 'Abeokuta' },
      { name: 'Ondo', code: 'ON', capital: 'Akure' },
      { name: 'Osun', code: 'OS', capital: 'Osogbo' },
      { name: 'Oyo', code: 'OY', capital: 'Ibadan' },
      { name: 'Plateau', code: 'PL', capital: 'Jos' },
      { name: 'Rivers', code: 'RI', capital: 'Port Harcourt' },
      { name: 'Sokoto', code: 'SO', capital: 'Sokoto' },
      { name: 'Taraba', code: 'TA', capital: 'Jalingo' },
      { name: 'Yobe', code: 'YO', capital: 'Damaturu' },
      { name: 'Zamfara', code: 'ZA', capital: 'Gusau' },
    ];

    const createdStates: State[] = [];
    for (const stateData of nigerianStates) {
      const exists = await this.stateModel.findOne({ code: stateData.code });
      if (!exists) {
        const state = await this.stateModel.create(stateData);
        createdStates.push(state);
      }
    }
    return createdStates;
  }
}

import {
  Controller,
  Post,
  UseGuards,
  UseInterceptors,
  UploadedFile,
  UploadedFiles,
  BadRequestException,
  Param,
  Delete,
} from '@nestjs/common';
import { FileInterceptor, FilesInterceptor } from '@nestjs/platform-express';
import { UploadService } from './upload.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';

@Controller('upload')
@UseGuards(JwtAuthGuard)
export class UploadController {
  constructor(private uploadService: UploadService) {}

  @Post('image')
  @UseInterceptors(FileInterceptor('file'))
  async uploadImage(@UploadedFile() file: Express.Multer.File) {
    if (!file) {
      throw new BadRequestException('No file provided');
    }
    return this.uploadService.uploadImage(file);
  }

  @Post('images')
  @UseInterceptors(FilesInterceptor('files', 10))
  async uploadImages(@UploadedFiles() files: Express.Multer.File[]) {
    if (!files || files.length === 0) {
      throw new BadRequestException('No files provided');
    }
    return this.uploadService.uploadMultipleImages(files);
  }

  @Post('shop-entrance')
  @UseInterceptors(FileInterceptor('file'))
  async uploadShopEntrance(@UploadedFile() file: Express.Multer.File) {
    if (!file) {
      throw new BadRequestException('No file provided');
    }
    return this.uploadService.uploadShopEntrance(file);
  }

  @Post('shop-logo')
  @UseInterceptors(FileInterceptor('file'))
  async uploadShopLogo(@UploadedFile() file: Express.Multer.File) {
    if (!file) {
      throw new BadRequestException('No file provided');
    }
    return this.uploadService.uploadShopLogo(file);
  }

  @Post('market-layout')
  @UseInterceptors(FileInterceptor('file'))
  async uploadMarketLayout(@UploadedFile() file: Express.Multer.File) {
    if (!file) {
      throw new BadRequestException('No file provided');
    }
    return this.uploadService.uploadMarketLayout(file);
  }

  @Post('product')
  @UseInterceptors(FileInterceptor('file'))
  async uploadProductImage(@UploadedFile() file: Express.Multer.File) {
    if (!file) {
      throw new BadRequestException('No file provided');
    }
    return this.uploadService.uploadProductImage(file);
  }

  @Delete(':publicId')
  async deleteImage(@Param('publicId') publicId: string) {
    return this.uploadService.deleteImage(publicId);
  }
}
import { Module } from '@nestjs/common';
import { MulterModule } from '@nestjs/platform-express';
import { memoryStorage } from 'multer';
import { UploadController } from './upload.controller';
import { UploadService } from './upload.service';

@Module({
  imports: [
    MulterModule.register({
      storage: memoryStorage(),
      limits: {
        fileSize: 10 * 1024 * 1024, // 10MB limit
      },
      fileFilter: (req, file, callback) => {
        if (!file.mimetype.match(/\/(jpg|jpeg|png|gif|webp)$/)) {
          return callback(new Error('Only image files are allowed!'), false);
        }
        callback(null, true);
      },
    }),
  ],
  controllers: [UploadController],
  providers: [UploadService],
  exports: [UploadService],
})
export class UploadModule {}
import { Injectable, BadRequestException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { v2 as cloudinary, UploadApiResponse, UploadApiErrorResponse } from 'cloudinary';
import * as streamifier from 'streamifier';

export interface CloudinaryResponse {
  url: string;
  publicId: string;
  width?: number;
  height?: number;
  format?: string;
}

@Injectable()
export class UploadService {
  constructor(private configService: ConfigService) {
    cloudinary.config({
      cloud_name: this.configService.get<string>('CLOUDINARY_CLOUD_NAME'),
      api_key: this.configService.get<string>('CLOUDINARY_API_KEY'),
      api_secret: this.configService.get<string>('CLOUDINARY_API_SECRET'),
    });
  }

  async uploadImage(
    file: Express.Multer.File,
    folder: string = 'sureshops',
  ): Promise<CloudinaryResponse> {
    return new Promise((resolve, reject) => {
      const uploadStream = cloudinary.uploader.upload_stream(
        {
          folder: folder,
          resource_type: 'image',
          transformation: [
            { width: 1200, height: 1200, crop: 'limit' },
            { quality: 'auto' },
            { fetch_format: 'auto' },
          ],
        },
        (error: UploadApiErrorResponse, result: UploadApiResponse) => {
          if (error) {
            reject(new BadRequestException('Failed to upload image'));
          } else {
            resolve({
              url: result.secure_url,
              publicId: result.public_id,
              width: result.width,
              height: result.height,
              format: result.format,
            });
          }
        },
      );

      streamifier.createReadStream(file.buffer).pipe(uploadStream);
    });
  }

  async uploadMultipleImages(
    files: Express.Multer.File[],
    folder: string = 'sureshops',
  ): Promise<CloudinaryResponse[]> {
    const uploadPromises = files.map((file) => this.uploadImage(file, folder));
    return Promise.all(uploadPromises);
  }

  async deleteImage(publicId: string): Promise<boolean> {
    try {
      const result = await cloudinary.uploader.destroy(publicId);
      return result.result === 'ok';
    } catch (error) {
      throw new BadRequestException('Failed to delete image');
    }
  }

  async uploadShopEntrance(file: Express.Multer.File): Promise<CloudinaryResponse> {
    return this.uploadImage(file, 'sureshops/shop-entrances');
  }

  async uploadShopLogo(file: Express.Multer.File): Promise<CloudinaryResponse> {
    return new Promise((resolve, reject) => {
      const uploadStream = cloudinary.uploader.upload_stream(
        {
          folder: 'sureshops/logos',
          resource_type: 'image',
          transformation: [
            { width: 500, height: 500, crop: 'fill' },
            { quality: 'auto' },
            { fetch_format: 'auto' },
          ],
        },
        (error: UploadApiErrorResponse, result: UploadApiResponse) => {
          if (error) {
            reject(new BadRequestException('Failed to upload logo'));
          } else {
            resolve({
              url: result.secure_url,
              publicId: result.public_id,
              width: result.width,
              height: result.height,
              format: result.format,
            });
          }
        },
      );

      streamifier.createReadStream(file.buffer).pipe(uploadStream);
    });
  }

  async uploadMarketLayout(file: Express.Multer.File): Promise<CloudinaryResponse> {
    return this.uploadImage(file, 'sureshops/market-layouts');
  }

  async uploadProductImage(file: Express.Multer.File): Promise<CloudinaryResponse> {
    return this.uploadImage(file, 'sureshops/products');
  }
}

import {
  IsEmail,
  IsString,
  MinLength,
  IsOptional,
  IsEnum,
} from 'class-validator';
import { Role } from '../../common/enums/role.enum';

export class CreateUserDto {
  @IsString()
  @MinLength(2)
  firstName: string;

  @IsString()
  @MinLength(2)
  lastName: string;

  @IsEmail()
  email: string;

  @IsString()
  @MinLength(6)
  password: string;

  @IsString()
  phone: string;

  @IsEnum(Role)
  @IsOptional()
  role?: Role;

  @IsString()
  @IsOptional()
  avatar?: string;
}
import { IsString, IsOptional, IsEnum, IsBoolean } from 'class-validator';
import { Role } from '../../common/enums/role.enum';

export class UpdateUserDto {
  @IsString()
  @IsOptional()
  firstName?: string;

  @IsString()
  @IsOptional()
  lastName?: string;

  @IsString()
  @IsOptional()
  phone?: string;

  @IsEnum(Role)
  @IsOptional()
  role?: Role;

  @IsString()
  @IsOptional()
  avatar?: string;

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;
}
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { Role } from '../../common/enums/role.enum';

@Schema({ timestamps: true })
export class User extends Document {
  @Prop({ required: true })
  firstName: string;

  @Prop({ required: true })
  lastName: string;

  @Prop({ required: true, unique: true, lowercase: true })
  email: string;

  @Prop({ required: true })
  password: string;

  @Prop({ required: true })
  phone: string;

  @Prop({ type: String, enum: Role, default: Role.USER })
  role: Role;

  @Prop()
  avatar?: string;

  @Prop({ default: true })
  isActive: boolean;

  @Prop({ default: false })
  isEmailVerified: boolean;

  @Prop()
  lastLoginAt?: Date;

  @Prop({ type: Types.ObjectId, ref: 'Vendor' })
  vendorProfile?: Types.ObjectId;
}

export const UserSchema = SchemaFactory.createForClass(User);

UserSchema.index({ email: 1 });
UserSchema.index({ phone: 1 });
UserSchema.index({ role: 1 });
import {
  Controller,
  Get,
  Put,
  Delete,
  Body,
  Param,
  UseGuards,
  Request,
} from '@nestjs/common';
import { UsersService } from './users.service';
import { UpdateUserDto } from './dto/update-user.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { Role } from '../common/enums/role.enum';

@Controller('users')
@UseGuards(JwtAuthGuard)
export class UsersController {
  constructor(private usersService: UsersService) {}

  @Get()
  @UseGuards(RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  findAll() {
    return this.usersService.findAll();
  }

  @Get('profile')
  getProfile(@Request() req) {
    return this.usersService.findById(req.user.id);
  }

  @Get(':id')
  @UseGuards(RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  findOne(@Param('id') id: string) {
    return this.usersService.findById(id);
  }

  @Put('profile')
  updateProfile(@Request() req, @Body() dto: UpdateUserDto) {
    return this.usersService.update(req.user.id, dto);
  }

  @Put(':id')
  @UseGuards(RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  update(@Param('id') id: string, @Body() dto: UpdateUserDto) {
    return this.usersService.update(id, dto);
  }

  @Delete(':id')
  @UseGuards(RolesGuard)
  @Roles(Role.SUPER_ADMIN)
  delete(@Param('id') id: string) {
    return this.usersService.delete(id);
  }
}
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';
import { User, UserSchema } from './schemas/user.schema';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: User.name, schema: UserSchema }]),
  ],
  controllers: [UsersController],
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { User } from './schemas/user.schema';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';

@Injectable()
export class UsersService {
  constructor(@InjectModel(User.name) private userModel: Model<User>) {}

  async create(dto: CreateUserDto): Promise<User> {
    return this.userModel.create(dto);
  }

  async findAll(): Promise<User[]> {
    return this.userModel.find().select('-password').sort({ createdAt: -1 });
  }

  async findById(id: string): Promise<User | null> {
    return this.userModel.findById(id).select('-password');
  }

  async findByEmail(email: string): Promise<User | null> {
    return this.userModel.findOne({ email: email.toLowerCase() });
  }

  async update(id: string, dto: UpdateUserDto): Promise<User> {
    const user = await this.userModel
      .findByIdAndUpdate(id, dto, { new: true })
      .select('-password');
    if (!user) {
      throw new NotFoundException('User not found');
    }
    return user;
  }

  async updateVendorProfile(userId: string, vendorId: string): Promise<User> {
    const user = await this.userModel
      .findByIdAndUpdate(
        userId,
        { vendorProfile: vendorId },
        { new: true },
      )
      .select('-password');
    if (!user) {
      throw new NotFoundException('User not found');
    }
    return user;
  }

  async delete(id: string): Promise<void> {
    const result = await this.userModel.deleteOne({ _id: id });
    if (result.deletedCount === 0) {
      throw new NotFoundException('User not found');
    }
  }
}
import {
  IsString,
  IsOptional,
  IsArray,
  IsNumber,
  IsMongoId,
  IsEnum,
  IsObject,
  ValidateNested,
  IsEmail,
} from 'class-validator';
import { Type } from 'class-transformer';
import { VendorType } from '../../common/enums/vendor-type.enum';

class BankDetailsDto {
  @IsString()
  bankName: string;

  @IsString()
  accountName: string;

  @IsString()
  accountNumber: string;

  @IsString()
  @IsOptional()
  bankCode?: string;
}

class ContactDetailsDto {
  @IsString()
  phone: string;

  @IsString()
  @IsOptional()
  alternatePhone?: string;

  @IsEmail()
  @IsOptional()
  email?: string;

  @IsString()
  @IsOptional()
  whatsapp?: string;

  @IsString()
  @IsOptional()
  instagram?: string;

  @IsString()
  @IsOptional()
  facebook?: string;

  @IsString()
  @IsOptional()
  twitter?: string;

  @IsString()
  @IsOptional()
  website?: string;
}

class ShopImagesDto {
  @IsString()
  @IsOptional()
  entrancePhoto?: string;

  @IsString()
  @IsOptional()
  logo?: string;

  @IsString()
  @IsOptional()
  layoutMap?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  additionalImages?: string[];
}

export class CreateVendorDto {
  @IsString()
  businessName: string;

  @IsString()
  @IsOptional()
  businessDescription?: string;

  @IsEnum(VendorType)
  vendorType: VendorType;

  @IsMongoId()
  stateId: string;

  @IsMongoId()
  areaId: string;

  @IsMongoId()
  @IsOptional()
  marketId?: string;

  @IsString()
  @IsOptional()
  shopNumber?: string;

  @IsString()
  @IsOptional()
  shopFloor?: string;

  @IsString()
  @IsOptional()
  shopBlock?: string;

  @IsString()
  @IsOptional()
  shopAddress?: string;

  @IsString()
  @IsOptional()
  landmark?: string;

  @IsArray()
  @IsNumber({}, { each: true })
  @IsOptional()
  coordinates?: [number, number];

  @IsObject()
  @ValidateNested()
  @Type(() => ShopImagesDto)
  @IsOptional()
  shopImages?: ShopImagesDto;

  @IsObject()
  @ValidateNested()
  @Type(() => ContactDetailsDto)
  contactDetails: ContactDetailsDto;

  @IsObject()
  @ValidateNested()
  @Type(() => BankDetailsDto)
  @IsOptional()
  bankDetails?: BankDetailsDto;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  categories?: string[];

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  tags?: string[];

  @IsString()
  @IsOptional()
  openingTime?: string;

  @IsString()
  @IsOptional()
  closingTime?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  operatingDays?: string[];
}
import { IsOptional, IsString, IsEnum, IsNumber, IsMongoId, IsBoolean } from 'class-validator';
import { Type } from 'class-transformer';
import { VendorType } from '../../common/enums/vendor-type.enum';

export class FilterVendorDto {
  @IsOptional()
  @IsMongoId()
  stateId?: string;

  @IsOptional()
  @IsMongoId()
  areaId?: string;

  @IsOptional()
  @IsMongoId()
  marketId?: string;

  @IsOptional()
  @IsEnum(VendorType)
  vendorType?: VendorType;

  @IsOptional()
  @IsString()
  category?: string;

  @IsOptional()
  @IsString()
  search?: string;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  longitude?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  latitude?: number;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  maxDistance?: number;

  @IsOptional()
  @Type(() => Boolean)
  @IsBoolean()
  isVerified?: boolean;

  @IsOptional()
  @Type(() => Boolean)
  @IsBoolean()
  isFeatured?: boolean;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  page?: number = 1;

  @IsOptional()
  @Type(() => Number)
  @IsNumber()
  limit?: number = 20;
}
import {
  IsString,
  IsOptional,
  IsArray,
  IsNumber,
  IsMongoId,
  IsEnum,
  IsObject,
  ValidateNested,
  IsEmail,
  IsBoolean,
} from 'class-validator';
import { Type } from 'class-transformer';
import { VendorType } from '../../common/enums/vendor-type.enum';

class BankDetailsDto {
  @IsString()
  @IsOptional()
  bankName?: string;

  @IsString()
  @IsOptional()
  accountName?: string;

  @IsString()
  @IsOptional()
  accountNumber?: string;

  @IsString()
  @IsOptional()
  bankCode?: string;
}

class ContactDetailsDto {
  @IsString()
  @IsOptional()
  phone?: string;

  @IsString()
  @IsOptional()
  alternatePhone?: string;

  @IsEmail()
  @IsOptional()
  email?: string;

  @IsString()
  @IsOptional()
  whatsapp?: string;

  @IsString()
  @IsOptional()
  instagram?: string;

  @IsString()
  @IsOptional()
  facebook?: string;

  @IsString()
  @IsOptional()
  twitter?: string;

  @IsString()
  @IsOptional()
  website?: string;
}

class ShopImagesDto {
  @IsString()
  @IsOptional()
  entrancePhoto?: string;

  @IsString()
  @IsOptional()
  logo?: string;

  @IsString()
  @IsOptional()
  layoutMap?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  additionalImages?: string[];
}

export class UpdateVendorDto {
  @IsString()
  @IsOptional()
  businessName?: string;

  @IsString()
  @IsOptional()
  businessDescription?: string;

  @IsEnum(VendorType)
  @IsOptional()
  vendorType?: VendorType;

  @IsMongoId()
  @IsOptional()
  stateId?: string;

  @IsMongoId()
  @IsOptional()
  areaId?: string;

  @IsMongoId()
  @IsOptional()
  marketId?: string;

  @IsString()
  @IsOptional()
  shopNumber?: string;

  @IsString()
  @IsOptional()
  shopFloor?: string;

  @IsString()
  @IsOptional()
  shopBlock?: string;

  @IsString()
  @IsOptional()
  shopAddress?: string;

  @IsString()
  @IsOptional()
  landmark?: string;

  @IsArray()
  @IsNumber({}, { each: true })
  @IsOptional()
  coordinates?: [number, number];

  @IsObject()
  @ValidateNested()
  @Type(() => ShopImagesDto)
  @IsOptional()
  shopImages?: ShopImagesDto;

  @IsObject()
  @ValidateNested()
  @Type(() => ContactDetailsDto)
  @IsOptional()
  contactDetails?: ContactDetailsDto;

  @IsObject()
  @ValidateNested()
  @Type(() => BankDetailsDto)
  @IsOptional()
  bankDetails?: BankDetailsDto;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  categories?: string[];

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  tags?: string[];

  @IsString()
  @IsOptional()
  openingTime?: string;

  @IsString()
  @IsOptional()
  closingTime?: string;

  @IsArray()
  @IsString({ each: true })
  @IsOptional()
  operatingDays?: string[];

  @IsBoolean()
  @IsOptional()
  isActive?: boolean;

  @IsBoolean()
  @IsOptional()
  isVerified?: boolean;

  @IsBoolean()
  @IsOptional()
  isFeatured?: boolean;
}

import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';
import { VendorType } from '../../common/enums/vendor-type.enum';

@Schema({ _id: false })
class BankDetails {
  @Prop({ required: true })
  bankName: string;

  @Prop({ required: true })
  accountName: string;

  @Prop({ required: true })
  accountNumber: string;

  @Prop()
  bankCode?: string;
}

@Schema({ _id: false })
class ContactDetails {
  @Prop({ required: true })
  phone: string;

  @Prop()
  alternatePhone?: string;

  @Prop()
  email?: string;

  @Prop()
  whatsapp?: string;

  @Prop()
  instagram?: string;

  @Prop()
  facebook?: string;

  @Prop()
  twitter?: string;

  @Prop()
  website?: string;
}

@Schema({ _id: false })
class ShopImages {
  @Prop()
  entrancePhoto?: string;

  @Prop()
  logo?: string;

  @Prop()
  layoutMap?: string;

  @Prop([String])
  additionalImages?: string[];
}

@Schema({ _id: false })
class OperatingHours {
  @Prop()
  openingTime?: string;

  @Prop()
  closingTime?: string;

  @Prop([String])
  operatingDays?: string[];

  @Prop({ default: false })
  is24Hours?: boolean;
}

@Schema({ timestamps: true })
export class Vendor extends Document {
  @Prop({ type: Types.ObjectId, ref: 'User', required: true })
  userId: Types.ObjectId;

  @Prop({ required: true })
  businessName: string;

  @Prop()
  businessDescription?: string;

  @Prop({ type: String, enum: VendorType, required: true })
  vendorType: VendorType;

  // Location Hierarchy
  @Prop({ type: Types.ObjectId, ref: 'State', required: true })
  stateId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Area', required: true })
  areaId: Types.ObjectId;

  @Prop({ type: Types.ObjectId, ref: 'Market' })
  marketId?: Types.ObjectId;

  // Shop Details
  @Prop()
  shopNumber?: string;

  @Prop()
  shopFloor?: string;

  @Prop()
  shopBlock?: string;

  @Prop()
  shopAddress?: string;

  @Prop()
  landmark?: string;

  // Geolocation
  @Prop({ type: { type: String, enum: ['Point'], default: 'Point' }, coordinates: [Number] })
  location?: {
    type: 'Point';
    coordinates: [number, number];
  };

  // Images
  @Prop({ type: ShopImages })
  shopImages?: ShopImages;

  // Contact & Banking
  @Prop({ type: ContactDetails, required: true })
  contactDetails: ContactDetails;

  @Prop({ type: BankDetails })
  bankDetails?: BankDetails;

  // Operating Hours
  @Prop({ type: OperatingHours })
  operatingHours?: OperatingHours;

  // Categories of products sold
  @Prop([String])
  categories?: string[];

  @Prop([String])
  tags?: string[];

  // Statistics
  @Prop({ default: 0 })
  totalProducts: number;

  @Prop({ default: 0 })
  totalViews: number;

  @Prop({ default: 0 })
  searchAppearances: number;

  @Prop({ default: 0 })
  rating: number;

  @Prop({ default: 0 })
  reviewCount: number;

  // Price Range (computed from products)
  @Prop({ default: 0 })
  minProductPrice: number;

  @Prop({ default: 0 })
  maxProductPrice: number;

  // Status
  @Prop({ default: true })
  isActive: boolean;

  @Prop({ default: false })
  isVerified: boolean;

  @Prop({ default: false })
  isFeatured: boolean;

  @Prop({ default: true })
  isOpen: boolean;
}

export const VendorSchema = SchemaFactory.createForClass(Vendor);

VendorSchema.index({ location: '2dsphere' });
VendorSchema.index({ stateId: 1, areaId: 1, marketId: 1 });
VendorSchema.index({ userId: 1 });
VendorSchema.index({ vendorType: 1 });
VendorSchema.index({ categories: 1 });
VendorSchema.index({ isActive: 1, isVerified: 1 });
VendorSchema.index({ businessName: 'text', businessDescription: 'text', tags: 'text' });

import {
  Controller,
  Get,
  Post,
  Put,
  Delete,
  Body,
  Param,
  Query,
  UseGuards,
  Request,
} from '@nestjs/common';
import { VendorsService } from './vendors.service';
import { CreateVendorDto } from './dto/create-vendor.dto';
import { UpdateVendorDto } from './dto/update-vendor.dto';
import { FilterVendorDto } from './dto/filter-vendor.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { Role } from '../common/enums/role.enum';

@Controller('vendors')
export class VendorsController {
  constructor(private vendorsService: VendorsService) {}

  @Get()
  findAll(@Query() filterDto: FilterVendorDto) {
    return this.vendorsService.findAll(filterDto);
  }

  @Get('my-profile')
  @UseGuards(JwtAuthGuard)
  getMyProfile(@Request() req) {
    return this.vendorsService.findByUser(req.user.id);
  }

  @Get('market/:marketId')
  findByMarket(@Param('marketId') marketId: string) {
    return this.vendorsService.findByMarket(marketId);
  }

  @Get('nearby')
  findNearby(
    @Query('longitude') longitude: number,
    @Query('latitude') latitude: number,
    @Query('distance') distance?: number,
  ) {
    return this.vendorsService.findNearby(longitude, latitude, distance);
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.vendorsService.findById(id);
  }

  @Post()
  @UseGuards(JwtAuthGuard)
  create(@Body() dto: CreateVendorDto, @Request() req) {
    return this.vendorsService.create(dto, req.user.id);
  }

  @Put(':id')
  @UseGuards(JwtAuthGuard)
  update(@Param('id') id: string, @Body() dto: UpdateVendorDto, @Request() req) {
    return this.vendorsService.update(id, dto, req.user.id);
  }

  @Put(':id/admin')
  @UseGuards(JwtAuthGuard, RolesGuard)
  @Roles(Role.ADMIN, Role.SUPER_ADMIN)
  adminUpdate(@Param('id') id: string, @Body() dto: UpdateVendorDto) {
    return this.vendorsService.adminUpdate(id, dto);
  }

  @Delete(':id')
  @UseGuards(JwtAuthGuard)
  delete(@Param('id') id: string, @Request() req) {
    return this.vendorsService.delete(id, req.user.id);
  }
}
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { VendorsService } from './vendors.service';
import { VendorsController } from './vendors.controller';
import { Vendor, VendorSchema } from './schemas/vendor.schema';
import { MarketsModule } from '../markets/markets.module';
import { UsersModule } from '../users/users.module';

@Module({
  imports: [
    MongooseModule.forFeature([{ name: Vendor.name, schema: VendorSchema }]),
    MarketsModule,
    UsersModule,
  ],
  controllers: [VendorsController],
  providers: [VendorsService],
  exports: [VendorsService],
})
export class VendorsModule {}
import { Injectable, NotFoundException, ForbiddenException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { Vendor } from './schemas/vendor.schema';
import { CreateVendorDto } from './dto/create-vendor.dto';
import { UpdateVendorDto } from './dto/update-vendor.dto';
import { FilterVendorDto } from './dto/filter-vendor.dto';
import { MarketsService } from '../markets/markets.service';
import { UsersService } from '../users/users.service';
import { Role } from '../common/enums/role.enum';

@Injectable()
export class VendorsService {
  constructor(
    @InjectModel(Vendor.name) private vendorModel: Model<Vendor>,
    private marketsService: MarketsService,
    private usersService: UsersService,
  ) {}

  async create(dto: CreateVendorDto, userId: string): Promise<Vendor> {
    const vendorData: any = { ...dto, userId };
    
    if (dto.coordinates) {
      vendorData.location = {
        type: 'Point',
        coordinates: dto.coordinates,
      };
    }
    delete vendorData.coordinates;

    const vendor = await this.vendorModel.create(vendorData);

    // Update user role to vendor
    await this.usersService.update(userId, { role: Role.VENDOR });
    await this.usersService.updateVendorProfile(userId, vendor._id.toString());

    // Increment market shop count if applicable
    if (dto.marketId) {
      await this.marketsService.incrementShopCount(dto.marketId);
    }

    return vendor;
  }

  async findAll(filterDto: FilterVendorDto): Promise<{
    vendors: Vendor[];
    total: number;
    page: number;
    totalPages: number;
  }> {
    const {
      page = 1,
      limit = 20,
      stateId,
      areaId,
      marketId,
      vendorType,
      category,
      search,
      longitude,
      latitude,
      maxDistance,
      isVerified,
      isFeatured,
    } = filterDto;

    const query: Record<string, any> = { isActive: true };

    if (stateId) query.stateId = stateId;
    if (areaId) query.areaId = areaId;
    if (marketId) query.marketId = marketId;
    if (vendorType) query.vendorType = vendorType;
    if (category) query.categories = { $in: [category] };
    if (isVerified !== undefined) query.isVerified = isVerified;
    if (isFeatured !== undefined) query.isFeatured = isFeatured;

    if (search) {
      query.$or = [
        { businessName: { $regex: search, $options: 'i' } },
        { businessDescription: { $regex: search, $options: 'i' } },
        { tags: { $in: [new RegExp(search, 'i')] } },
      ];
    }

    // Geospatial query
    if (longitude && latitude) {
      query.location = {
        $near: {
          $geometry: {
            type: 'Point',
            coordinates: [longitude, latitude],
          },
          $maxDistance: (maxDistance || 10) * 1000,
        },
      };
    }

    const skip = (page - 1) * limit;
    const [vendors, total] = await Promise.all([
      this.vendorModel
        .find(query)
        .populate('stateId', 'name code')
        .populate('areaId', 'name')
        .populate('marketId', 'name type')
        .populate('userId', 'firstName lastName email')
        .skip(skip)
        .limit(limit)
        .sort({ isFeatured: -1, rating: -1, createdAt: -1 }),
      this.vendorModel.countDocuments(query),
    ]);

    return {
      vendors,
      total,
      page,
      totalPages: Math.ceil(total / limit),
    };
  }

  async findById(id: string): Promise<Vendor> {
    const vendor = await this.vendorModel
      .findById(id)
      .populate('stateId', 'name code')
      .populate('areaId', 'name localGovernment')
      .populate('marketId', 'name type address entrancePhoto layoutMap')
      .populate('userId', 'firstName lastName email phone');
    
    if (!vendor) {
      throw new NotFoundException('Vendor not found');
    }

    // Increment view count
    await this.vendorModel.findByIdAndUpdate(id, { $inc: { totalViews: 1 } });

    return vendor;
  }

  async findByUser(userId: string): Promise<Vendor> {
    const vendor = await this.vendorModel
      .findOne({ userId })
      .populate('stateId', 'name code')
      .populate('areaId', 'name')
      .populate('marketId', 'name type');
    
    if (!vendor) {
      throw new NotFoundException('Vendor profile not found');
    }
    return vendor;
  }

  async findByMarket(marketId: string): Promise<Vendor[]> {
    return this.vendorModel
      .find({ marketId, isActive: true })
      .populate('userId', 'firstName lastName')
      .sort({ shopNumber: 1 });
  }

  async findNearby(
    longitude: number,
    latitude: number,
    maxDistanceKm: number = 5,
  ): Promise<Vendor[]> {
    return this.vendorModel.find({
      location: {
        $near: {
          $geometry: {
            type: 'Point',
            coordinates: [longitude, latitude],
          },
          $maxDistance: maxDistanceKm * 1000,
        },
      },
      isActive: true,
    })
    .populate('stateId', 'name code')
    .populate('areaId', 'name')
    .populate('marketId', 'name type');
  }

  async update(id: string, dto: UpdateVendorDto, userId: string): Promise<Vendor> {
    const vendor = await this.vendorModel.findById(id);
    if (!vendor) {
      throw new NotFoundException('Vendor not found');
    }

    // Check ownership
    if (vendor.userId.toString() !== userId) {
      throw new ForbiddenException('You can only update your own vendor profile');
    }

    const updateData: any = { ...dto };
    if (dto.coordinates) {
      updateData.location = {
        type: 'Point',
        coordinates: dto.coordinates,
      };
    }
    delete updateData.coordinates;

    const updatedVendor = await this.vendorModel
      .findByIdAndUpdate(id, updateData, { new: true })
      .populate('stateId', 'name code')
      .populate('areaId', 'name')
      .populate('marketId', 'name type');

    if (!updatedVendor) {
      throw new NotFoundException('Vendor not found after update');
    }

    return updatedVendor;
  }

  async adminUpdate(id: string, dto: UpdateVendorDto): Promise<Vendor> {
    const updateData: any = { ...dto };
    if (dto.coordinates) {
      updateData.location = {
        type: 'Point',
        coordinates: dto.coordinates,
      };
    }
    delete updateData.coordinates;

    const vendor = await this.vendorModel
      .findByIdAndUpdate(id, updateData, { new: true })
      .populate('stateId', 'name code')
      .populate('areaId', 'name')
      .populate('marketId', 'name type');

    if (!vendor) {
      throw new NotFoundException('Vendor not found');
    }
    return vendor;
  }

  async incrementProductCount(id: string): Promise<void> {
    await this.vendorModel.findByIdAndUpdate(id, { $inc: { totalProducts: 1 } });
  }

  async decrementProductCount(id: string): Promise<void> {
    await this.vendorModel.findByIdAndUpdate(id, { $inc: { totalProducts: -1 } });
  }

  async delete(id: string, userId: string): Promise<void> {
    const vendor = await this.vendorModel.findById(id);
    if (!vendor) {
      throw new NotFoundException('Vendor not found');
    }

    if (vendor.userId.toString() !== userId) {
      throw new ForbiddenException('You can only delete your own vendor profile');
    }

    // Decrement market shop count if applicable
    if (vendor.marketId) {
      await this.marketsService.decrementShopCount(vendor.marketId.toString());
    }

    await this.vendorModel.deleteOne({ _id: id });
  }
  async updatePriceRange(vendorId: string, minPrice: number, maxPrice: number): Promise<void> {
    await this.vendorModel.findByIdAndUpdate(vendorId, {
      minProductPrice: minPrice || 0,
      maxProductPrice: maxPrice || 0,
    });
  }
}
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { MongooseModule } from '@nestjs/mongoose';
import { AuthModule } from './auth/auth.module';
import { UsersModule } from './users/users.module';
import { StatesModule } from './states/states.module';
import { AreasModule } from './areas/areas.module';
import { MarketsModule } from './markets/markets.module';
import { VendorsModule } from './vendors/vendors.module';
import { ProductsModule } from './products/products.module';
import { CatalogModule } from './catalog/catalog.module';
import { SearchModule } from './search/search.module';
import { UploadModule } from './upload/upload.module';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: '.env',
    }),
    MongooseModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => ({
        uri: configService.get<string>('MONGODB_URI'),
      }),
      inject: [ConfigService],
    }),
    AuthModule,
    UsersModule,
    StatesModule,
    AreasModule,
    MarketsModule,
    VendorsModule,
    ProductsModule,
    CatalogModule,
    SearchModule,
    UploadModule,
  ],
})
export class AppModule {}
import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { AppModule } from './app.module';
import { HttpExceptionFilter } from './common/filters/http-exception.filter';
import { TransformInterceptor } from './common/interceptors/transform.interceptor';

let cachedApp: any;

async function createApp() {
  const app = await NestFactory.create(AppModule);

  // CORS
  app.enableCors({
    origin: true,
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS',
    allowedHeaders: 'Content-Type, Accept, Authorization',
    credentials: true,
  });

  // Global prefix
  app.setGlobalPrefix('api/v1');

  // Validation
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
      transformOptions: {
        enableImplicitConversion: true,
      },
    }),
  );

  // Global filters
  app.useGlobalFilters(new HttpExceptionFilter());

  // Global interceptors
  app.useGlobalInterceptors(new TransformInterceptor());

  await app.init();
  return app;
}

// Vercel Serverless Handler
export default async function handler(req: any, res: any) {
  if (!cachedApp) {
    cachedApp = await createApp();
  }

  const instance = cachedApp.getHttpAdapter().getInstance();
  return instance(req, res);
}

// Local Development
if (process.env.NODE_ENV !== 'production') {
  createApp().then(async (app) => {
    await app.listen(4000);
    console.log(' SureShops API running on http://localhost:4000/api/v1');
    console.log(' Health check: http://localhost:4000/api/v1/auth/health');
  });
}
import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { AppModule } from './app.module';
import { HttpExceptionFilter } from './common/filters/http-exception.filter';
import { TransformInterceptor } from './common/interceptors/transform.interceptor';

let cachedApp: any;

async function createApp() {
  const app = await NestFactory.create(AppModule);

  // CORS
  app.enableCors({
    origin: true,
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS',
    allowedHeaders: 'Content-Type, Accept, Authorization',
    credentials: true,
  });

  // Global prefix
  app.setGlobalPrefix('api/v1');

  // Validation
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
      transformOptions: {
        enableImplicitConversion: true,
      },
    }),
  );

  // Global filters
  app.useGlobalFilters(new HttpExceptionFilter());

  // Global interceptors
  app.useGlobalInterceptors(new TransformInterceptor());

  await app.init();
  return app;
}

// Vercel Serverless Handler
export default async function handler(req: any, res: any) {
  if (!cachedApp) {
    cachedApp = await createApp();
  }

  const instance = cachedApp.getHttpAdapter().getInstance();
  return instance(req, res);
}

// Local Development
if (process.env.NODE_ENV !== 'production') {
  createApp().then(async (app) => {
    await app.listen(4000);
    console.log(' SureShops API running on http://localhost:4000/api/v1');
    console.log(' Health check: http://localhost:4000/api/v1/auth/health');
  });
}
